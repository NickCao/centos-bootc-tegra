From 8935f2e3106a46d8abdf2f09436b2529ffb4cbab Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Mon, 27 May 2024 10:08:04 +0000
Subject: [PATCH 01/26] NVIDIA: SAUCE: phy: tegra: xusb: Add Tegra264 support

Add support for the XUSB pad controller for Tegra264. Most of
the Tegra264 XUSB PADCTL registers definition and programming sequence
are the same as Tegra234, Tegra264 XUSB PADCTL can share the same
driver with Tegra186, Tegra194, and Tegra234 XUSB PADCTL.

http://nvbugs/4295138

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/phy/tegra/Makefile        |  1 +
 drivers/phy/tegra/xusb-tegra186.c | 26 +++++++++++++++++++++++++-
 drivers/phy/tegra/xusb.c          |  6 ++++++
 drivers/phy/tegra/xusb.h          |  3 +++
 4 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/drivers/phy/tegra/Makefile b/drivers/phy/tegra/Makefile
index eeeea72de117..33a695d4ed59 100644
--- a/drivers/phy/tegra/Makefile
+++ b/drivers/phy/tegra/Makefile
@@ -8,4 +8,5 @@ phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_210_SOC) += xusb-tegra210.o
 phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_186_SOC) += xusb-tegra186.o
 phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_194_SOC) += xusb-tegra186.o
 phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_234_SOC) += xusb-tegra186.o
+phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_264_SOC) += xusb-tegra186.o
 obj-$(CONFIG_PHY_TEGRA194_P2U) += phy-tegra194-p2u.o
diff --git a/drivers/phy/tegra/xusb-tegra186.c b/drivers/phy/tegra/xusb-tegra186.c
index e818f6c3980e..b6dee225bc15 100644
--- a/drivers/phy/tegra/xusb-tegra186.c
+++ b/drivers/phy/tegra/xusb-tegra186.c
@@ -1648,7 +1648,8 @@ EXPORT_SYMBOL_GPL(tegra186_xusb_padctl_soc);
 #endif
 
 #if IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC) || \
-	IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)
+	IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC) || \
+	IS_ENABLED(CONFIG_ARCH_TEGRA_264_SOC)
 static const char * const tegra194_xusb_padctl_supply_names[] = {
 	"avdd-usb",
 	"vclamp-usb",
@@ -1731,6 +1732,29 @@ const struct tegra_xusb_padctl_soc tegra234_xusb_padctl_soc = {
 	.supports_lp_cfg_en = true,
 };
 EXPORT_SYMBOL_GPL(tegra234_xusb_padctl_soc);
+
+const struct tegra_xusb_padctl_soc tegra264_xusb_padctl_soc = {
+	.num_pads = ARRAY_SIZE(tegra194_pads),
+	.pads = tegra194_pads,
+	.ports = {
+		.usb2 = {
+			.ops = &tegra186_usb2_port_ops,
+			.count = 4,
+		},
+		.usb3 = {
+			.ops = &tegra186_usb3_port_ops,
+			.count = 4,
+		},
+	},
+	.ops = &tegra186_xusb_padctl_ops,
+	.supply_names = tegra194_xusb_padctl_supply_names,
+	.num_supplies = ARRAY_SIZE(tegra194_xusb_padctl_supply_names),
+	.supports_gen2 = true,
+	.poll_trk_completed = true,
+	.trk_hw_mode = true,
+	.supports_lp_cfg_en = true,
+};
+EXPORT_SYMBOL_GPL(tegra264_xusb_padctl_soc);
 #endif
 
 MODULE_AUTHOR("JC Kuo <jckuo@nvidia.com>");
diff --git a/drivers/phy/tegra/xusb.c b/drivers/phy/tegra/xusb.c
index c89df95aa6ca..12bcc9754b37 100644
--- a/drivers/phy/tegra/xusb.c
+++ b/drivers/phy/tegra/xusb.c
@@ -77,6 +77,12 @@ static const struct of_device_id tegra_xusb_padctl_of_match[] = {
 		.compatible = "nvidia,tegra234-xusb-padctl",
 		.data = &tegra234_xusb_padctl_soc,
 	},
+#endif
+#if defined(CONFIG_ARCH_TEGRA_264_SOC)
+	{
+		.compatible = "nvidia,tegra264-xusb-padctl",
+		.data = &tegra264_xusb_padctl_soc,
+	},
 #endif
 	{ }
 };
diff --git a/drivers/phy/tegra/xusb.h b/drivers/phy/tegra/xusb.h
index d2b5f9565132..b3302e9c7896 100644
--- a/drivers/phy/tegra/xusb.h
+++ b/drivers/phy/tegra/xusb.h
@@ -514,5 +514,8 @@ extern const struct tegra_xusb_padctl_soc tegra194_xusb_padctl_soc;
 #if defined(CONFIG_ARCH_TEGRA_234_SOC)
 extern const struct tegra_xusb_padctl_soc tegra234_xusb_padctl_soc;
 #endif
+#if defined(CONFIG_ARCH_TEGRA_264_SOC)
+extern const struct tegra_xusb_padctl_soc tegra264_xusb_padctl_soc;
+#endif
 
 #endif /* __PHY_TEGRA_XUSB_H */
-- 
2.52.0


From 64d01e62b3a1cccecb8840d665bc2f108d901293 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Mon, 27 May 2024 10:48:46 +0000
Subject: [PATCH 02/26] NVIDIA: SAUCE: usb: host: xhci-tegra: Add Tegra264 XHCI
 support

This commit adds Tegra264 XUSB host mode controller support.

http://nvbugs/4295138

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/usb/host/xhci-tegra.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/drivers/usb/host/xhci-tegra.c b/drivers/usb/host/xhci-tegra.c
index 0c7af44d4dae..718e2ae6cd21 100644
--- a/drivers/usb/host/xhci-tegra.c
+++ b/drivers/usb/host/xhci-tegra.c
@@ -2656,12 +2656,38 @@ static const struct tegra_xusb_soc tegra234_soc = {
 	.has_bar2 = true,
 };
 
+static const struct tegra_xusb_soc tegra264_soc = {
+	.supply_names = tegra194_supply_names,
+	.num_supplies = ARRAY_SIZE(tegra194_supply_names),
+	.phy_types = tegra194_phy_types,
+	.num_types = ARRAY_SIZE(tegra194_phy_types),
+	.context = &tegra186_xusb_context,
+	.ports = {
+		.usb3 = { .offset = 0, .count = 4, },
+		.usb2 = { .offset = 4, .count = 4, },
+	},
+	.scale_ss_clock = false,
+	.has_ipfs = false,
+	.otg_reset_sspi = false,
+	.ops = &tegra234_ops,
+	.mbox = {
+		.cmd = XUSB_BAR2_ARU_MBOX_CMD,
+		.data_in = XUSB_BAR2_ARU_MBOX_DATA_IN,
+		.data_out = XUSB_BAR2_ARU_MBOX_DATA_OUT,
+		.owner = XUSB_BAR2_ARU_MBOX_OWNER,
+		.smi_intr = XUSB_BAR2_ARU_SMI_INTR,
+	},
+	.lpm_support = true,
+	.has_bar2 = true,
+};
+
 static const struct of_device_id tegra_xusb_of_match[] = {
 	{ .compatible = "nvidia,tegra124-xusb", .data = &tegra124_soc },
 	{ .compatible = "nvidia,tegra210-xusb", .data = &tegra210_soc },
 	{ .compatible = "nvidia,tegra186-xusb", .data = &tegra186_soc },
 	{ .compatible = "nvidia,tegra194-xusb", .data = &tegra194_soc },
 	{ .compatible = "nvidia,tegra234-xusb", .data = &tegra234_soc },
+	{ .compatible = "nvidia,tegra264-xusb", .data = &tegra264_soc },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, tegra_xusb_of_match);
-- 
2.52.0


From 71a405862cb49edda3eee93ac770d8be8f2d7372 Mon Sep 17 00:00:00 2001
From: Prathamesh Shete <pshete@nvidia.com>
Date: Wed, 19 Jun 2024 09:58:54 +0000
Subject: [PATCH 03/26] NVIDIA: SAUCE: gpio: t264: add GPIO support for T264

Add required support for T264 GPIO

Signed-off-by: Prathamesh Shete <pshete@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/gpio/gpio-tegra186.c             | 99 ++++++++++++++++++++++++
 include/dt-bindings/gpio/tegra264-gpio.h | 61 +++++++++++++++
 2 files changed, 160 insertions(+)
 create mode 100644 include/dt-bindings/gpio/tegra264-gpio.h

diff --git a/drivers/gpio/gpio-tegra186.c b/drivers/gpio/gpio-tegra186.c
index 1ecb733a5e88..76eaf4f44a29 100644
--- a/drivers/gpio/gpio-tegra186.c
+++ b/drivers/gpio/gpio-tegra186.c
@@ -20,6 +20,7 @@
 #include <dt-bindings/gpio/tegra194-gpio.h>
 #include <dt-bindings/gpio/tegra234-gpio.h>
 #include <dt-bindings/gpio/tegra241-gpio.h>
+#include <dt-bindings/gpio/tegra264-gpio.h>
 
 /* security registers */
 #define TEGRA186_GPIO_CTL_SCR 0x0c
@@ -743,6 +744,7 @@ static const struct of_device_id tegra186_pmc_of_match[] = {
 	{ .compatible = "nvidia,tegra186-pmc" },
 	{ .compatible = "nvidia,tegra194-pmc" },
 	{ .compatible = "nvidia,tegra234-pmc" },
+	{ .compatible = "nvidia,tegra264-pmc" },
 	{ /* sentinel */ }
 };
 
@@ -1272,6 +1274,94 @@ static const struct tegra_gpio_soc tegra241_aon_soc = {
 	.num_irqs_per_bank = 8,
 	.has_vm_support = false,
 };
+#define TEGRA264_MAIN_GPIO_PORT(_name, _bank, _port, _pins)	\
+	[TEGRA264_MAIN_GPIO_PORT_##_name] = {		\
+		.name = #_name,					\
+		.bank = _bank,					\
+		.port = _port,					\
+		.pins = _pins,					\
+	}
+
+static const struct tegra_gpio_port tegra264_main_ports[] = {
+	TEGRA264_MAIN_GPIO_PORT(T, 0, 0, 7),
+	TEGRA264_MAIN_GPIO_PORT(U, 0, 1, 8),
+	TEGRA264_MAIN_GPIO_PORT(V, 0, 2, 8),
+	TEGRA264_MAIN_GPIO_PORT(W, 0, 3, 8),
+	TEGRA264_MAIN_GPIO_PORT(AL, 0, 4, 3),
+	TEGRA264_MAIN_GPIO_PORT(Y, 0, 5, 8),
+	TEGRA264_MAIN_GPIO_PORT(Z, 0, 6, 8),
+	TEGRA264_MAIN_GPIO_PORT(X, 0, 7, 6),
+	TEGRA264_MAIN_GPIO_PORT(H, 1, 0, 8),
+	TEGRA264_MAIN_GPIO_PORT(J, 1, 1, 8),
+	TEGRA264_MAIN_GPIO_PORT(K, 1, 2, 8),
+	TEGRA264_MAIN_GPIO_PORT(L, 1, 3, 8),
+	TEGRA264_MAIN_GPIO_PORT(M, 1, 4, 6),
+	TEGRA264_MAIN_GPIO_PORT(P, 2, 0, 8),
+	TEGRA264_MAIN_GPIO_PORT(Q, 2, 1, 8),
+	TEGRA264_MAIN_GPIO_PORT(R, 2, 2, 8),
+	TEGRA264_MAIN_GPIO_PORT(S, 2, 3, 2),
+	TEGRA264_MAIN_GPIO_PORT(F, 3, 0, 8),
+	TEGRA264_MAIN_GPIO_PORT(G, 3, 1, 5),
+};
+
+static const struct tegra_gpio_soc tegra264_main_soc = {
+	.num_ports = ARRAY_SIZE(tegra264_main_ports),
+	.ports = tegra264_main_ports,
+	.name = "tegra264-gpio-main",
+	.instance = 0,
+	.num_irqs_per_bank = 8,
+	.has_vm_support = true,
+};
+
+#define TEGRA264_UPHY_GPIO_PORT(_name, _bank, _port, _pins)	\
+	[TEGRA264_UPHY_GPIO_PORT_##_name] = {			\
+		.name = #_name,					\
+		.bank = _bank,					\
+		.port = _port,					\
+		.pins = _pins,					\
+	}
+
+static const struct tegra_gpio_port tegra264_uphy_ports[] = {
+	TEGRA264_UPHY_GPIO_PORT(A, 0, 0, 6),
+	TEGRA264_UPHY_GPIO_PORT(B, 0, 1, 8),
+	TEGRA264_UPHY_GPIO_PORT(C, 0, 2, 3),
+	TEGRA264_UPHY_GPIO_PORT(D, 1, 0, 8),
+	TEGRA264_UPHY_GPIO_PORT(E, 1, 1, 4),
+};
+
+static const struct tegra_gpio_soc tegra264_uphy_soc = {
+	.num_ports = ARRAY_SIZE(tegra264_uphy_ports),
+	.ports = tegra264_uphy_ports,
+	.name = "tegra264-gpio-uphy",
+	.instance = 0,
+	.num_irqs_per_bank = 8,
+	.has_vm_support = true,
+};
+
+#define TEGRA264_AON_GPIO_PORT(_name, _bank, _port, _pins)	\
+	[TEGRA264_AON_GPIO_PORT_##_name] = {			\
+		.name = #_name,					\
+		.bank = _bank,					\
+		.port = _port,					\
+		.pins = _pins,					\
+	}
+
+static const struct tegra_gpio_port tegra264_aon_ports[] = {
+	TEGRA264_AON_GPIO_PORT(AA, 0, 0, 8),
+	TEGRA264_AON_GPIO_PORT(BB, 0, 1, 2),
+	TEGRA264_AON_GPIO_PORT(CC, 0, 2, 8),
+	TEGRA264_AON_GPIO_PORT(DD, 0, 3, 8),
+	TEGRA264_AON_GPIO_PORT(EE, 0, 4, 4)
+};
+
+static const struct tegra_gpio_soc tegra264_aon_soc = {
+	.num_ports = ARRAY_SIZE(tegra264_aon_ports),
+	.ports = tegra264_aon_ports,
+	.name = "tegra264-gpio-aon",
+	.instance = 1,
+	.num_irqs_per_bank = 8,
+	.has_vm_support = true,
+};
 
 static const struct of_device_id tegra186_gpio_of_match[] = {
 	{
@@ -1292,6 +1382,15 @@ static const struct of_device_id tegra186_gpio_of_match[] = {
 	}, {
 		.compatible = "nvidia,tegra234-gpio-aon",
 		.data = &tegra234_aon_soc
+	}, {
+		.compatible = "nvidia,tegra264-gpio-main",
+		.data = &tegra264_main_soc
+	}, {
+		.compatible = "nvidia,tegra264-gpio-uphy",
+		.data = &tegra264_uphy_soc
+	}, {
+		.compatible = "nvidia,tegra264-gpio-aon",
+		.data = &tegra264_aon_soc
 	}, {
 		/* sentinel */
 	}
diff --git a/include/dt-bindings/gpio/tegra264-gpio.h b/include/dt-bindings/gpio/tegra264-gpio.h
new file mode 100644
index 000000000000..c5749e489e03
--- /dev/null
+++ b/include/dt-bindings/gpio/tegra264-gpio.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2023, NVIDIA CORPORATION. All rights reserved. */
+
+/*
+ * This header provides constants for binding nvidia,tegra234-gpio*.
+ *
+ * The first cell in Tegra's GPIO specifier is the GPIO ID. The macros below
+ * provide names for this.
+ *
+ * The second cell contains standard flag values specified in gpio.h.
+ */
+
+#ifndef _DT_BINDINGS_GPIO_TEGRA264_GPIO_H
+#define _DT_BINDINGS_GPIO_TEGRA264_GPIO_H
+
+#include <dt-bindings/gpio/gpio.h>
+
+/* GPIOs implemented by main GPIO controller */
+#define TEGRA264_MAIN_GPIO_PORT_T  0
+#define TEGRA264_MAIN_GPIO_PORT_U  1
+#define TEGRA264_MAIN_GPIO_PORT_V  2
+#define TEGRA264_MAIN_GPIO_PORT_W  3
+#define TEGRA264_MAIN_GPIO_PORT_AL 4
+#define TEGRA264_MAIN_GPIO_PORT_Y  5
+#define TEGRA264_MAIN_GPIO_PORT_Z  6
+#define TEGRA264_MAIN_GPIO_PORT_X  7
+#define TEGRA264_MAIN_GPIO_PORT_H  8
+#define TEGRA264_MAIN_GPIO_PORT_J  9
+#define TEGRA264_MAIN_GPIO_PORT_K  10
+#define TEGRA264_MAIN_GPIO_PORT_L  11
+#define TEGRA264_MAIN_GPIO_PORT_M  12
+#define TEGRA264_MAIN_GPIO_PORT_P  13
+#define TEGRA264_MAIN_GPIO_PORT_Q  14
+#define TEGRA264_MAIN_GPIO_PORT_R  15
+#define TEGRA264_MAIN_GPIO_PORT_S  16
+#define TEGRA264_MAIN_GPIO_PORT_F  17
+#define TEGRA264_MAIN_GPIO_PORT_G  18
+
+#define TEGRA264_MAIN_GPIO(port, offset) \
+	((TEGRA264_MAIN_GPIO_PORT_##port * 8) + offset)
+
+/* GPIOs implemented by AON GPIO controller */
+#define TEGRA264_AON_GPIO_PORT_AA  0
+#define TEGRA264_AON_GPIO_PORT_BB  1
+#define TEGRA264_AON_GPIO_PORT_CC  2
+#define TEGRA264_AON_GPIO_PORT_DD  3
+#define TEGRA264_AON_GPIO_PORT_EE  4
+
+#define TEGRA264_AON_GPIO(port, offset) \
+	((TEGRA264_AON_GPIO_PORT_##port * 8) + offset)
+
+#define TEGRA264_UPHY_GPIO_PORT_A  0
+#define TEGRA264_UPHY_GPIO_PORT_B  1
+#define TEGRA264_UPHY_GPIO_PORT_C  2
+#define TEGRA264_UPHY_GPIO_PORT_D  3
+#define TEGRA264_UPHY_GPIO_PORT_E  4
+
+#define TEGRA264_UPHY_GPIO(port, offset) \
+	((TEGRA264_UPHY_GPIO_PORT_##port * 8) + offset)
+
+#endif
-- 
2.52.0


From dcc7e221319089be5d9a6ea4268e739fb875af3d Mon Sep 17 00:00:00 2001
From: Prathamesh Shete <pshete@nvidia.com>
Date: Wed, 19 Jun 2024 10:46:38 +0000
Subject: [PATCH 04/26] NVIDIA: SAUCE: pinctrl: t264: Add pinctrl support for
 T264

Add pinctrl support for T264

Signed-off-by: Prathamesh Shete <pshete@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/pinctrl/Kconfig                  |    7 +
 drivers/pinctrl/tegra/Kconfig            |    4 +
 drivers/pinctrl/tegra/Makefile           |    1 +
 drivers/pinctrl/tegra/pinctrl-tegra264.c | 2223 ++++++++++++++++++++++
 4 files changed, 2235 insertions(+)
 create mode 100644 drivers/pinctrl/tegra/pinctrl-tegra264.c

diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 9aae4f5b6562..8ecc568feb2c 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -31,6 +31,13 @@ config DEBUG_PINCTRL
 	help
 	  Say Y here to add some extra checks and diagnostics to PINCTRL calls.
 
+config PINCTRL_TEGRA264
+	bool "NVIDIA Tegra264 Pinmux support"
+	select PINCTRL_TEGRA
+	default y
+	help
+	Support for the NVIDIA Tegra264 PINCTRL controller driver.
+
 config PINCTRL_AMD
 	bool "AMD GPIO pin control"
 	depends on HAS_IOMEM
diff --git a/drivers/pinctrl/tegra/Kconfig b/drivers/pinctrl/tegra/Kconfig
index 4e87d19323ba..68bd01ba6830 100644
--- a/drivers/pinctrl/tegra/Kconfig
+++ b/drivers/pinctrl/tegra/Kconfig
@@ -32,6 +32,10 @@ config PINCTRL_TEGRA234
 	bool
 	select PINCTRL_TEGRA
 
+config PINCTRL_TEGRA264
+	bool
+	select PINCTRL_TEGRA
+
 config PINCTRL_TEGRA_XUSB
 	def_bool y if ARCH_TEGRA
 	select GENERIC_PHY
diff --git a/drivers/pinctrl/tegra/Makefile b/drivers/pinctrl/tegra/Makefile
index a93973701d4c..8aef7d4cf71a 100644
--- a/drivers/pinctrl/tegra/Makefile
+++ b/drivers/pinctrl/tegra/Makefile
@@ -7,4 +7,5 @@ obj-$(CONFIG_PINCTRL_TEGRA124)		+= pinctrl-tegra124.o
 obj-$(CONFIG_PINCTRL_TEGRA210)		+= pinctrl-tegra210.o
 obj-$(CONFIG_PINCTRL_TEGRA194)		+= pinctrl-tegra194.o
 obj-$(CONFIG_PINCTRL_TEGRA234)		+= pinctrl-tegra234.o
+obj-$(CONFIG_PINCTRL_TEGRA264)		+= pinctrl-tegra264.o
 obj-$(CONFIG_PINCTRL_TEGRA_XUSB)	+= pinctrl-tegra-xusb.o
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra264.c b/drivers/pinctrl/tegra/pinctrl-tegra264.c
new file mode 100644
index 000000000000..8b953b8bf1e6
--- /dev/null
+++ b/drivers/pinctrl/tegra/pinctrl-tegra264.c
@@ -0,0 +1,2223 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Pinctrl data for the NVIDIA Tegra264 pinmux
+ *
+ * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
+ */
+
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+
+#include "pinctrl-tegra.h"
+
+/* Define unique ID for each pins */
+enum {
+	TEGRA_PIN_PEX_L4_CLKREQ_N_PD0,
+	TEGRA_PIN_PEX_L4_RST_N_PD1,
+	TEGRA_PIN_PEX_L5_CLKREQ_N_PD2,
+	TEGRA_PIN_PEX_L5_RST_N_PD3,
+	TEGRA_PIN_ETH0_MDIO_PD4,
+	TEGRA_PIN_ETH0_MDC_PD5,
+	TEGRA_PIN_ETH3_MDIO_PD6,
+	TEGRA_PIN_ETH3_MDC_PD7,
+	TEGRA_PIN_ETH1_MDIO_PE0,
+	TEGRA_PIN_ETH1_MDC_PE1,
+	TEGRA_PIN_ETH2_MDIO_PE2,
+	TEGRA_PIN_ETH2_MDC_PE3,
+	TEGRA_PIN_PEX_L1_CLKREQ_N_PB0,
+	TEGRA_PIN_PEX_L1_RST_N_PB1,
+	TEGRA_PIN_PEX_L2_CLKREQ_N_PB2,
+	TEGRA_PIN_PEX_L2_RST_N_PB3,
+	TEGRA_PIN_PEX_L3_CLKREQ_N_PB4,
+	TEGRA_PIN_PEX_L3_RST_N_PB5,
+	TEGRA_PIN_SOC_GPIO113_PB6,
+	TEGRA_PIN_SOC_GPIO114_PB7,
+	TEGRA_PIN_SGMII0_SMA_MDIO_PC0,
+	TEGRA_PIN_SGMII0_SMA_MDC_PC1,
+	TEGRA_PIN_PEX_WAKE_N_PC2,
+	TEGRA_PIN_PWM1_PA0,
+	TEGRA_PIN_PWM6_PA1,
+	TEGRA_PIN_PWM7_PA2,
+	TEGRA_PIN_PWM8_PA3,
+	TEGRA_PIN_UFS0_REF_CLK_PA4,
+	TEGRA_PIN_UFS0_RST_N_PA5,
+};
+
+enum {
+	TEGRA_PIN_SOC_GPIO250_PF0,
+	TEGRA_PIN_SOC_GPIO251_PF1,
+	TEGRA_PIN_SOC_GPIO252_PF2,
+	TEGRA_PIN_DP_AUX_CH0_HPD_PF3,
+	TEGRA_PIN_DP_AUX_CH1_HPD_PF4,
+	TEGRA_PIN_DP_AUX_CH2_HPD_PF5,
+	TEGRA_PIN_DP_AUX_CH3_HPD_PF6,
+	TEGRA_PIN_PWM2_PF7,
+	TEGRA_PIN_PWM3_PG0,
+	TEGRA_PIN_GEN7_I2C_SCL_PG1,
+	TEGRA_PIN_GEN7_I2C_SDA_PG2,
+	TEGRA_PIN_GEN9_I2C_SCL_PG3,
+	TEGRA_PIN_GEN9_I2C_SDA_PG4,
+	TEGRA_PIN_SDMMC1_CLK_PX0,
+	TEGRA_PIN_SDMMC1_CMD_PX1,
+	TEGRA_PIN_SDMMC1_DAT0_PX2,
+	TEGRA_PIN_SDMMC1_DAT1_PX3,
+	TEGRA_PIN_SDMMC1_DAT2_PX4,
+	TEGRA_PIN_SDMMC1_DAT3_PX5,
+	TEGRA_PIN_SDMMC1_COMP,
+	TEGRA_PIN_SOC_GPIO124_PL0,
+	TEGRA_PIN_SOC_GPIO125_PL1,
+	TEGRA_PIN_FAN_TACH0_PL2,
+	TEGRA_PIN_SOC_GPIO127_PL3,
+	TEGRA_PIN_SOC_GPIO128_PL4,
+	TEGRA_PIN_SOC_GPIO129_PL5,
+	TEGRA_PIN_SOC_GPIO130_PL6,
+	TEGRA_PIN_SOC_GPIO131_PL7,
+	TEGRA_PIN_GP_PWM9_PM0,
+	TEGRA_PIN_SOC_GPIO133_PM1,
+	TEGRA_PIN_UART9_TX_PM2,
+	TEGRA_PIN_UART9_RX_PM3,
+	TEGRA_PIN_UART9_RTS_N_PM4,
+	TEGRA_PIN_UART9_CTS_N_PM5,
+	TEGRA_PIN_SOC_GPIO170_PU0,
+	TEGRA_PIN_SOC_GPIO171_PU1,
+	TEGRA_PIN_SOC_GPIO172_PU2,
+	TEGRA_PIN_SOC_GPIO173_PU3,
+	TEGRA_PIN_SOC_GPIO174_PU4,
+	TEGRA_PIN_SOC_GPIO175_PU5,
+	TEGRA_PIN_SOC_GPIO176_PU6,
+	TEGRA_PIN_SOC_GPIO177_PU7,
+	TEGRA_PIN_SOC_GPIO178_PV0,
+	TEGRA_PIN_PWM10_PV1,
+	TEGRA_PIN_UART4_TX_PV2,
+	TEGRA_PIN_UART4_RX_PV3,
+	TEGRA_PIN_UART4_RTS_N_PV4,
+	TEGRA_PIN_UART4_CTS_N_PV5,
+	TEGRA_PIN_DAP2_CLK_PV6,
+	TEGRA_PIN_DAP2_DIN_PW0,
+	TEGRA_PIN_DAP2_DOUT_PV7,
+	TEGRA_PIN_DAP2_FS_PW1,
+	TEGRA_PIN_GEN1_I2C_SCL_PW2,
+	TEGRA_PIN_GEN1_I2C_SDA_PW3,
+	TEGRA_PIN_GEN0_I2C_SCL_PW4,
+	TEGRA_PIN_GEN0_I2C_SDA_PW5,
+	TEGRA_PIN_PWR_I2C_SCL_PW6,
+	TEGRA_PIN_PWR_I2C_SDA_PW7,
+	TEGRA_PIN_SOC_GPIO138_PP0,
+	TEGRA_PIN_SOC_GPIO139_PP1,
+	TEGRA_PIN_DAP6_SCLK_PP2,
+	TEGRA_PIN_DAP6_DOUT_PP3,
+	TEGRA_PIN_DAP6_DIN_PP4,
+	TEGRA_PIN_DAP6_FS_PP5,
+	TEGRA_PIN_DAP4_SCLK_PP6,
+	TEGRA_PIN_DAP4_DOUT_PP7,
+	TEGRA_PIN_DAP4_DIN_PQ0,
+	TEGRA_PIN_DAP4_FS_PQ1,
+	TEGRA_PIN_SPI5_SCK_PQ2,
+	TEGRA_PIN_SPI5_MISO_PQ3,
+	TEGRA_PIN_SPI5_MOSI_PQ4,
+	TEGRA_PIN_SPI5_CS0_PQ5,
+	TEGRA_PIN_SOC_GPIO152_PQ6,
+	TEGRA_PIN_SOC_GPIO153_PQ7,
+	TEGRA_PIN_AUD_MCLK_PR0,
+	TEGRA_PIN_SOC_GPIO155_PR1,
+	TEGRA_PIN_DAP1_SCLK_PR2,
+	TEGRA_PIN_DAP1_OUT_PR3,
+	TEGRA_PIN_DAP1_IN_PR4,
+	TEGRA_PIN_DAP1_FS_PR5,
+	TEGRA_PIN_GEN11_I2C_SCL_PR6,
+	TEGRA_PIN_GEN11_I2C_SDA_PR7,
+	TEGRA_PIN_SOC_GPIO350_PS0,
+	TEGRA_PIN_SOC_GPIO351_PS1,
+	TEGRA_PIN_QSPI0_SCK_PT0,
+	TEGRA_PIN_QSPI0_CS_N_PT1,
+	TEGRA_PIN_QSPI0_IO0_PT2,
+	TEGRA_PIN_QSPI0_IO1_PT3,
+	TEGRA_PIN_QSPI0_IO2_PT4,
+	TEGRA_PIN_QSPI0_IO3_PT5,
+	TEGRA_PIN_SOC_GPIO192_PT6,
+	TEGRA_PIN_SOC_GPIO270_PY0,
+	TEGRA_PIN_SOC_GPIO271_PY1,
+	TEGRA_PIN_SOC_GPIO272_PY2,
+	TEGRA_PIN_SOC_GPIO273_PY3,
+	TEGRA_PIN_SOC_GPIO274_PY4,
+	TEGRA_PIN_SOC_GPIO275_PY5,
+	TEGRA_PIN_SOC_GPIO276_PY6,
+	TEGRA_PIN_SOC_GPIO277_PY7,
+	TEGRA_PIN_SOC_GPIO278_PZ0,
+	TEGRA_PIN_SOC_GPIO279_PZ1,
+	TEGRA_PIN_XHALT_TRIG_PZ2,
+	TEGRA_PIN_SOC_GPIO281_PZ3,
+	TEGRA_PIN_SOC_GPIO282_PZ4,
+	TEGRA_PIN_SOC_GPIO283_PZ5,
+	TEGRA_PIN_SOC_GPIO284_PZ6,
+	TEGRA_PIN_SOC_GPIO285_PZ7,
+	TEGRA_PIN_SOC_GPIO286_PAL0,
+	TEGRA_PIN_SOC_GPIO287_PAL1,
+	TEGRA_PIN_SOC_GPIO288_PAL2,
+	TEGRA_PIN_CPU_PWR_REQ_PH0,
+	TEGRA_PIN_GPU_PWR_REQ_PH1,
+	TEGRA_PIN_UART10_TX_PH2,
+	TEGRA_PIN_UART10_RX_PH3,
+	TEGRA_PIN_UART10_RTS_N_PH4,
+	TEGRA_PIN_UART10_CTS_N_PH5,
+	TEGRA_PIN_SPI3_SCK_PH6,
+	TEGRA_PIN_SPI3_MISO_PH7,
+	TEGRA_PIN_SPI3_MOSI_PJ0,
+	TEGRA_PIN_SPI3_CS0_PJ1,
+	TEGRA_PIN_SPI3_CS3_PJ2,
+	TEGRA_PIN_UART5_TX_PJ3,
+	TEGRA_PIN_UART5_RX_PJ4,
+	TEGRA_PIN_UART5_RTS_N_PJ5,
+	TEGRA_PIN_UART5_CTS_N_PJ6,
+	TEGRA_PIN_SPI1_SCK_PJ7,
+	TEGRA_PIN_SPI1_MISO_PK0,
+	TEGRA_PIN_SPI1_MOSI_PK1,
+	TEGRA_PIN_SPI1_CS0_PK2,
+	TEGRA_PIN_SPI1_CS1_PK3,
+	TEGRA_PIN_EXTPERIPH1_CLK_PK4,
+	TEGRA_PIN_EXTPERIPH2_CLK_PK5,
+	TEGRA_PIN_GEN12_I2C_SCL_PK6,
+	TEGRA_PIN_GEN12_I2C_SDA_PK7,
+};
+
+enum {
+	TEGRA_PIN_SOC_GPIO00_PAA0,
+	TEGRA_PIN_VCOMP_ALERT_PAA1,
+	TEGRA_PIN_AO_RETENTION_N_PAA2,
+	TEGRA_PIN_BATT_OC_PAA3,
+	TEGRA_PIN_BOOTV_CTL_N_PAA4,
+	TEGRA_PIN_POWER_ON_PAA5,
+	TEGRA_PIN_HDMI_CEC_PAA6,
+	TEGRA_PIN_SOC_GPIO07_PAA7,
+	TEGRA_PIN_SOC_GPIO08_PBB0,
+	TEGRA_PIN_SOC_GPIO09_PBB1,
+	TEGRA_PIN_GEN2_I2C_SCL_PCC0,
+	TEGRA_PIN_GEN2_I2C_SDA_PCC1,
+	TEGRA_PIN_GEN3_I2C_SCL_PCC2,
+	TEGRA_PIN_GEN3_I2C_SDA_PCC3,
+	TEGRA_PIN_GP_PWM4_PCC4,
+	TEGRA_PIN_UART0_TX_PCC5,
+	TEGRA_PIN_UART0_RX_PCC6,
+	TEGRA_PIN_SPI2_SCK_PCC7,
+	TEGRA_PIN_SPI2_MISO_PDD0,
+	TEGRA_PIN_SPI2_MOSI_PDD1,
+	TEGRA_PIN_SPI2_CS0_N_PDD2,
+	TEGRA_PIN_SOC_GPIO21_PDD3,
+	TEGRA_PIN_SOC_GPIO22_PDD4,
+	TEGRA_PIN_SOC_GPIO23_PDD5,
+	TEGRA_PIN_SOC_GPIO24_PDD6,
+	TEGRA_PIN_SOC_GPIO25_PDD7,
+	TEGRA_PIN_SOC_GPIO26_PEE0,
+	TEGRA_PIN_SOC_GPIO27_PEE1,
+	TEGRA_PIN_SOC_GPIO28_PEE2,
+	TEGRA_PIN_SOC_GPIO29_PEE3,
+};
+
+static const struct pinctrl_pin_desc tegra264_uphy_pins[] = {
+	PINCTRL_PIN(TEGRA_PIN_PEX_L4_CLKREQ_N_PD0, "PEX_L4_CLKREQ_N_PD0"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L4_RST_N_PD1, "PEX_L4_RST_N_PD1"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L5_CLKREQ_N_PD2, "PEX_L5_CLKREQ_N_PD2"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L5_RST_N_PD3, "PEX_L5_RST_N_PD3"),
+	PINCTRL_PIN(TEGRA_PIN_ETH0_MDIO_PD4, "ETH0_MDIO_PD4"),
+	PINCTRL_PIN(TEGRA_PIN_ETH0_MDC_PD5, "ETH0_MDC_PD5"),
+	PINCTRL_PIN(TEGRA_PIN_ETH3_MDIO_PD6, "ETH3_MDIO_PD6"),
+	PINCTRL_PIN(TEGRA_PIN_ETH3_MDC_PD7, "ETH3_MDC_PD7"),
+	PINCTRL_PIN(TEGRA_PIN_ETH1_MDIO_PE0, "ETH1_MDIO_PE0"),
+	PINCTRL_PIN(TEGRA_PIN_ETH1_MDC_PE1, "ETH1_MDC_PE1"),
+	PINCTRL_PIN(TEGRA_PIN_ETH2_MDIO_PE2, "ETH2_MDIO_PE2"),
+	PINCTRL_PIN(TEGRA_PIN_ETH2_MDC_PE3, "ETH2_MDC_PE3"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L1_CLKREQ_N_PB0, "PEX_L1_CLKREQ_N_PB0"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L1_RST_N_PB1, "PEX_L1_RST_N_PB1"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L2_CLKREQ_N_PB2, "PEX_L2_CLKREQ_N_PB2"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L2_RST_N_PB3, "PEX_L2_RST_N_PB3"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L3_CLKREQ_N_PB4, "PEX_L3_CLKREQ_N_PB4"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L3_RST_N_PB5, "PEX_L3_RST_N_PB5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO113_PB6, "SOC_GPIO113_PB6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO114_PB7, "SOC_GPIO114_PB7"),
+	PINCTRL_PIN(TEGRA_PIN_SGMII0_SMA_MDIO_PC0, "SGMII0_SMA_MDIO_PC0"),
+	PINCTRL_PIN(TEGRA_PIN_SGMII0_SMA_MDC_PC1, "SGMII0_SMA_MDC_PC1"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_WAKE_N_PC2, "PEX_WAKE_N_PC2"),
+	PINCTRL_PIN(TEGRA_PIN_PWM1_PA0, "PWM1_PA0"),
+	PINCTRL_PIN(TEGRA_PIN_PWM6_PA1, "PWM6_PA1"),
+	PINCTRL_PIN(TEGRA_PIN_PWM7_PA2, "PWM7_PA2"),
+	PINCTRL_PIN(TEGRA_PIN_PWM8_PA3, "PWM8_PA3"),
+	PINCTRL_PIN(TEGRA_PIN_UFS0_REF_CLK_PA4, "UFS0_REF_CLK_PA4"),
+	PINCTRL_PIN(TEGRA_PIN_UFS0_RST_N_PA5, "UFS0_RST_N_PA5"),
+};
+
+static const struct pinctrl_pin_desc tegra264_main_pins[] = {
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO250_PF0, "SOC_GPIO250_PF0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO251_PF1, "SOC_GPIO251_PF1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO252_PF2, "SOC_GPIO252_PF2"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH0_HPD_PF3, "DP_AUX_CH0_HPD_PF3"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH1_HPD_PF4, "DP_AUX_CH1_HPD_PF4"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH2_HPD_PF5, "DP_AUX_CH2_HPD_PF5"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH3_HPD_PF6, "DP_AUX_CH3_HPD_PF6"),
+	PINCTRL_PIN(TEGRA_PIN_PWM2_PF7, "PWM2_PF7"),
+	PINCTRL_PIN(TEGRA_PIN_PWM3_PG0, "PWM3_PG0"),
+	PINCTRL_PIN(TEGRA_PIN_GEN7_I2C_SCL_PG1, "GEN7_I2C_SCL_PG1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN7_I2C_SDA_PG2, "GEN7_I2C_SDA_PG2"),
+	PINCTRL_PIN(TEGRA_PIN_GEN9_I2C_SCL_PG3, "GEN9_I2C_SCL_PG3"),
+	PINCTRL_PIN(TEGRA_PIN_GEN9_I2C_SDA_PG4, "GEN9_I2C_SDA_PG4"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_CLK_PX0, "SDMMC1_CLK_PX0"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_CMD_PX1, "SDMMC1_CMD_PX1"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT0_PX2, "SDMMC1_DAT0_PX2"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT1_PX3, "SDMMC1_DAT1_PX3"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT2_PX4, "SDMMC1_DAT2_PX4"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT3_PX5, "SDMMC1_DAT3_PX5"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_COMP, "SDMMC1_COMP"),
+	PINCTRL_PIN(TEGRA_PIN_CPU_PWR_REQ_PH0, "CPU_PWR_REQ_PH0"),
+	PINCTRL_PIN(TEGRA_PIN_GPU_PWR_REQ_PH1, "GPU_PWR_REQ_PH1"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_TX_PH2, "UART10_TX_PH2"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_RX_PH3, "UART10_RX_PH3"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_RTS_N_PH4, "UART10_RTS_N_PH4"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_CTS_N_PH5, "UART10_CTS_N_PH5"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_SCK_PH6, "SPI3_SCK_PH6"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_MISO_PH7, "SPI3_MISO_PH7"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_MOSI_PJ0, "SPI3_MOSI_PJ0"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_CS0_PJ1, "SPI3_CS0_PJ1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_CS3_PJ2, "SPI3_CS3_PJ2"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_TX_PJ3, "UART5_TX_PJ3"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_RX_PJ4, "UART5_RX_PJ4"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_RTS_N_PJ5, "UART5_RTS_N_PJ5"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_CTS_N_PJ6, "UART5_CTS_N_PJ6"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_SCK_PJ7, "SPI1_SCK_PJ7"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_MISO_PK0, "SPI1_MISO_PK0"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_MOSI_PK1, "SPI1_MOSI_PK1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_CS0_PK2, "SPI1_CS0_PK2"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_CS1_PK3, "SPI1_CS1_PK3"),
+	PINCTRL_PIN(TEGRA_PIN_EXTPERIPH1_CLK_PK4, "EXTPERIPH1_CLK_PK4"),
+	PINCTRL_PIN(TEGRA_PIN_EXTPERIPH2_CLK_PK5, "EXTPERIPH2_CLK_PK5"),
+	PINCTRL_PIN(TEGRA_PIN_GEN12_I2C_SCL_PK6, "GEN12_I2C_SCL_PK6"),
+	PINCTRL_PIN(TEGRA_PIN_GEN12_I2C_SDA_PK7, "GEN12_I2C_SDA_PK7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO124_PL0, "SOC_GPIO124_PL0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO125_PL1, "SOC_GPIO125_PL1"),
+	PINCTRL_PIN(TEGRA_PIN_FAN_TACH0_PL2, "FAN_TACH0_PL2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO127_PL3, "SOC_GPIO127_PL3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO128_PL4, "SOC_GPIO128_PL4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO129_PL5, "SOC_GPIO129_PL5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO130_PL6, "SOC_GPIO130_PL6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO131_PL7, "SOC_GPIO131_PL7"),
+	PINCTRL_PIN(TEGRA_PIN_GP_PWM9_PM0, "GP_PWM9_PM0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO133_PM1, "SOC_GPIO133_PM1"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_TX_PM2, "UART9_TX_PM2"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_RX_PM3, "UART9_RX_PM3"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_RTS_N_PM4, "UART9_RTS_N_PM4"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_CTS_N_PM5, "UART9_CTS_N_PM5"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_SCK_PT0, "QSPI0_SCK_PT0"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_CS_N_PT1, "QSPI0_CS_N_PT1"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO0_PT2, "QSPI0_IO0_PT2"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO1_PT3, "QSPI0_IO1_PT3"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO2_PT4, "QSPI0_IO2_PT4"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO3_PT5, "QSPI0_IO3_PT5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO192_PT6, "SOC_GPIO192_PT6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO170_PU0, "SOC_GPIO170_PU0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO171_PU1, "SOC_GPIO171_PU1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO172_PU2, "SOC_GPIO172_PU2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO173_PU3, "SOC_GPIO173_PU3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO174_PU4, "SOC_GPIO174_PU4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO175_PU5, "SOC_GPIO175_PU5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO176_PU6, "SOC_GPIO176_PU6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO177_PU7, "SOC_GPIO177_PU7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO178_PV0, "SOC_GPIO178_PV0"),
+	PINCTRL_PIN(TEGRA_PIN_PWM10_PV1, "PWM10_PV1"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_TX_PV2, "UART4_TX_PV2"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_RX_PV3, "UART4_RX_PV3"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_RTS_N_PV4, "UART4_RTS_N_PV4"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_CTS_N_PV5, "UART4_CTS_N_PV5"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_CLK_PV6, "DAP2_CLK_PV6"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_DIN_PW0, "DAP2_DIN_PW0"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_DOUT_PV7, "DAP2_DOUT_PV7"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_FS_PW1, "DAP2_FS_PW1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN1_I2C_SCL_PW2, "GEN1_I2C_SCL_PW2"),
+	PINCTRL_PIN(TEGRA_PIN_GEN1_I2C_SDA_PW3, "GEN1_I2C_SDA_PW3"),
+	PINCTRL_PIN(TEGRA_PIN_GEN0_I2C_SCL_PW4, "GEN0_I2C_SCL_PW4"),
+	PINCTRL_PIN(TEGRA_PIN_GEN0_I2C_SDA_PW5, "GEN0_I2C_SDA_PW5"),
+	PINCTRL_PIN(TEGRA_PIN_PWR_I2C_SCL_PW6, "PWR_I2C_SCL_PW6"),
+	PINCTRL_PIN(TEGRA_PIN_PWR_I2C_SDA_PW7, "PWR_I2C_SDA_PW7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO270_PY0, "SOC_GPIO270_PY0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO271_PY1, "SOC_GPIO271_PY1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO272_PY2, "SOC_GPIO272_PY2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO273_PY3, "SOC_GPIO273_PY3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO274_PY4, "SOC_GPIO274_PY4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO275_PY5, "SOC_GPIO275_PY5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO276_PY6, "SOC_GPIO276_PY6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO277_PY7, "SOC_GPIO277_PY7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO278_PZ0, "SOC_GPIO278_PZ0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO279_PZ1, "SOC_GPIO279_PZ1"),
+	PINCTRL_PIN(TEGRA_PIN_XHALT_TRIG_PZ2, "XHALT_TRIG_PZ2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO281_PZ3, "SOC_GPIO281_PZ3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO282_PZ4, "SOC_GPIO282_PZ4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO283_PZ5, "SOC_GPIO283_PZ5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO284_PZ6, "SOC_GPIO284_PZ6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO285_PZ7, "SOC_GPIO285_PZ7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO286_PAL0, "SOC_GPIO286_PAL0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO287_PAL1, "SOC_GPIO287_PAL1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO288_PAL2, "SOC_GPIO288_PAL2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO138_PP0, "SOC_GPIO138_PP0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO139_PP1, "SOC_GPIO139_PP1"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_SCLK_PP2, "DAP6_SCLK_PP2"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_DOUT_PP3, "DAP6_DOUT_PP3"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_DIN_PP4, "DAP6_DIN_PP4"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_FS_PP5, "DAP6_FS_PP5"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_SCLK_PP6, "DAP4_SCLK_PP6"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_DOUT_PP7, "DAP4_DOUT_PP7"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_DIN_PQ0, "DAP4_DIN_PQ0"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_FS_PQ1, "DAP4_FS_PQ1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_SCK_PQ2, "SPI5_SCK_PQ2"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_MISO_PQ3, "SPI5_MISO_PQ3"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_MOSI_PQ4, "SPI5_MOSI_PQ4"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_CS0_PQ5, "SPI5_CS0_PQ5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO152_PQ6, "SOC_GPIO152_PQ6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO153_PQ7, "SOC_GPIO153_PQ7"),
+	PINCTRL_PIN(TEGRA_PIN_AUD_MCLK_PR0, "AUD_MCLK_PR0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO155_PR1, "SOC_GPIO155_PR1"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_SCLK_PR2, "DAP1_SCLK_PR2"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_OUT_PR3, "DAP1_OUT_PR3"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_IN_PR4, "DAP1_IN_PR4"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_FS_PR5, "DAP1_FS_PR5"),
+	PINCTRL_PIN(TEGRA_PIN_GEN11_I2C_SCL_PR6, "GEN11_I2C_SCL_PR6"),
+	PINCTRL_PIN(TEGRA_PIN_GEN11_I2C_SDA_PR7, "GEN11_I2C_SDA_PR7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO350_PS0, "SOC_GPIO350_PS0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO351_PS1, "SOC_GPIO351_PS1"),
+
+};
+
+static const struct pinctrl_pin_desc tegra264_aon_pins[] = {
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO00_PAA0, "SOC_GPIO00_PAA0"),
+	PINCTRL_PIN(TEGRA_PIN_VCOMP_ALERT_PAA1, "VCOMP_ALERT_PAA1"),
+	PINCTRL_PIN(TEGRA_PIN_AO_RETENTION_N_PAA2, "AO_RETENTION_N_PAA2"),
+	PINCTRL_PIN(TEGRA_PIN_BATT_OC_PAA3, "BATT_OC_PAA3"),
+	PINCTRL_PIN(TEGRA_PIN_BOOTV_CTL_N_PAA4, "BOOTV_CTL_N_PAA4"),
+	PINCTRL_PIN(TEGRA_PIN_POWER_ON_PAA5, "POWER_ON_PAA5"),
+	PINCTRL_PIN(TEGRA_PIN_HDMI_CEC_PAA6, "HDMI_CEC_PAA6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO07_PAA7, "SOC_GPIO07_PAA7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO08_PBB0, "SOC_GPIO08_PBB0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO09_PBB1, "SOC_GPIO09_PBB1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN2_I2C_SCL_PCC0, "GEN2_I2C_SCL_PCC0"),
+	PINCTRL_PIN(TEGRA_PIN_GEN2_I2C_SDA_PCC1, "GEN2_I2C_SDA_PCC1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN3_I2C_SCL_PCC2, "GEN3_I2C_SCL_PCC2"),
+	PINCTRL_PIN(TEGRA_PIN_GEN3_I2C_SDA_PCC3, "GEN3_I2C_SDA_PCC3"),
+	PINCTRL_PIN(TEGRA_PIN_GP_PWM4_PCC4, "GP_PWM4_PCC4"),
+	PINCTRL_PIN(TEGRA_PIN_UART0_TX_PCC5, "UART0_TX_PCC5"),
+	PINCTRL_PIN(TEGRA_PIN_UART0_RX_PCC6, "UART0_RX_PCC6"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_SCK_PCC7, "SPI2_SCK_PCC7"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_MISO_PDD0, "SPI2_MISO_PDD0"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_MOSI_PDD1, "SPI2_MOSI_PDD1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_CS0_N_PDD2, "SPI2_CS0_N_PDD2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO21_PDD3, "SOC_GPIO21_PDD3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO22_PDD4, "SOC_GPIO22_PDD4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO23_PDD5, "SOC_GPIO23_PDD5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO24_PDD6, "SOC_GPIO24_PDD6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO25_PDD7, "SOC_GPIO25_PDD7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO26_PEE0, "SOC_GPIO26_PEE0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO27_PEE1, "SOC_GPIO27_PEE1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO28_PEE2, "SOC_GPIO28_PEE2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO29_PEE3, "SOC_GPIO29_PEE3"),
+};
+
+
+static const unsigned int soc_gpio250_pf0_pins[] = {
+		TEGRA_PIN_SOC_GPIO250_PF0,
+};
+
+static const unsigned int soc_gpio251_pf1_pins[] = {
+	TEGRA_PIN_SOC_GPIO251_PF1,
+};
+
+static const unsigned int soc_gpio252_pf2_pins[] = {
+	TEGRA_PIN_SOC_GPIO252_PF2,
+};
+
+static const unsigned int dp_aux_ch0_hpd_pf3_pins[] = {
+	TEGRA_PIN_DP_AUX_CH0_HPD_PF3,
+};
+
+static const unsigned int dp_aux_ch1_hpd_pf4_pins[] = {
+	TEGRA_PIN_DP_AUX_CH1_HPD_PF4,
+};
+
+static const unsigned int dp_aux_ch2_hpd_pf5_pins[] = {
+	TEGRA_PIN_DP_AUX_CH2_HPD_PF5,
+};
+
+static const unsigned int dp_aux_ch3_hpd_pf6_pins[] = {
+	TEGRA_PIN_DP_AUX_CH3_HPD_PF6,
+};
+
+static const unsigned int pwm2_pf7_pins[] = {
+	TEGRA_PIN_PWM2_PF7,
+};
+
+static const unsigned int pwm3_pg0_pins[] = {
+	TEGRA_PIN_PWM3_PG0,
+};
+
+static const unsigned int gen7_i2c_scl_pg1_pins[] = {
+	TEGRA_PIN_GEN7_I2C_SCL_PG1,
+};
+
+static const unsigned int gen7_i2c_sda_pg2_pins[] = {
+	TEGRA_PIN_GEN7_I2C_SDA_PG2,
+};
+
+static const unsigned int gen9_i2c_scl_pg3_pins[] = {
+	TEGRA_PIN_GEN9_I2C_SCL_PG3,
+};
+
+static const unsigned int gen9_i2c_sda_pg4_pins[] = {
+	TEGRA_PIN_GEN9_I2C_SDA_PG4,
+};
+
+static const unsigned int pwm1_pa0_pins[] = {
+	TEGRA_PIN_PWM1_PA0,
+};
+
+static const unsigned int pwm6_pa1_pins[] = {
+	TEGRA_PIN_PWM6_PA1,
+};
+
+static const unsigned int pwm7_pa2_pins[] = {
+	TEGRA_PIN_PWM7_PA2,
+};
+
+static const unsigned int pwm8_pa3_pins[] = {
+	TEGRA_PIN_PWM8_PA3,
+};
+
+static const unsigned int ufs0_ref_clk_pa4_pins[] = {
+	TEGRA_PIN_UFS0_REF_CLK_PA4,
+};
+
+static const unsigned int ufs0_rst_n_pa5_pins[] = {
+	TEGRA_PIN_UFS0_RST_N_PA5,
+};
+
+
+static const unsigned int pex_l1_clkreq_n_pb0_pins[] = {
+	TEGRA_PIN_PEX_L1_CLKREQ_N_PB0,
+};
+
+static const unsigned int pex_l1_rst_n_pb1_pins[] = {
+	TEGRA_PIN_PEX_L1_RST_N_PB1,
+};
+
+static const unsigned int pex_l2_clkreq_n_pb2_pins[] = {
+	TEGRA_PIN_PEX_L2_CLKREQ_N_PB2,
+};
+
+static const unsigned int pex_l2_rst_n_pb3_pins[] = {
+	TEGRA_PIN_PEX_L2_RST_N_PB3,
+};
+
+static const unsigned int pex_l3_clkreq_n_pb4_pins[] = {
+	TEGRA_PIN_PEX_L3_CLKREQ_N_PB4,
+};
+
+static const unsigned int pex_l3_rst_n_pb5_pins[] = {
+	TEGRA_PIN_PEX_L3_RST_N_PB5,
+};
+
+static const unsigned int soc_gpio113_pb6_pins[] = {
+	TEGRA_PIN_SOC_GPIO113_PB6,
+};
+
+static const unsigned int soc_gpio114_pb7_pins[] = {
+	TEGRA_PIN_SOC_GPIO114_PB7,
+};
+
+static const unsigned int sgmii0_sma_mdio_pc0_pins[] = {
+	TEGRA_PIN_SGMII0_SMA_MDIO_PC0,
+};
+
+static const unsigned int sgmii0_sma_mdc_pc1_pins[] = {
+	TEGRA_PIN_SGMII0_SMA_MDC_PC1,
+};
+
+static const unsigned int pex_wake_n_pc2_pins[] = {
+	TEGRA_PIN_PEX_WAKE_N_PC2,
+};
+
+
+static const unsigned int pex_l4_clkreq_n_pd0_pins[] = {
+	TEGRA_PIN_PEX_L4_CLKREQ_N_PD0,
+};
+
+static const unsigned int pex_l4_rst_n_pd1_pins[] = {
+	TEGRA_PIN_PEX_L4_RST_N_PD1,
+};
+
+static const unsigned int pex_l5_clkreq_n_pd2_pins[] = {
+	TEGRA_PIN_PEX_L5_CLKREQ_N_PD2,
+};
+
+static const unsigned int pex_l5_rst_n_pd3_pins[] = {
+	TEGRA_PIN_PEX_L5_RST_N_PD3,
+};
+
+static const unsigned int eth0_mdio_pd4_pins[] = {
+	TEGRA_PIN_ETH0_MDIO_PD4,
+};
+
+static const unsigned int eth0_mdc_pd5_pins[] = {
+	TEGRA_PIN_ETH0_MDC_PD5,
+};
+
+static const unsigned int eth3_mdio_pd6_pins[] = {
+	TEGRA_PIN_ETH3_MDIO_PD6,
+};
+
+static const unsigned int eth3_mdc_pd7_pins[] = {
+	TEGRA_PIN_ETH3_MDC_PD7,
+};
+
+static const unsigned int eth1_mdio_pe0_pins[] = {
+	TEGRA_PIN_ETH1_MDIO_PE0,
+};
+
+static const unsigned int eth1_mdc_pe1_pins[] = {
+	TEGRA_PIN_ETH1_MDC_PE1,
+};
+
+static const unsigned int eth2_mdio_pe2_pins[] = {
+	TEGRA_PIN_ETH2_MDIO_PE2,
+};
+
+static const unsigned int eth2_mdc_pe3_pins[] = {
+	TEGRA_PIN_ETH2_MDC_PE3,
+};
+
+
+static const unsigned int sdmmc1_clk_px0_pins[] = {
+	TEGRA_PIN_SDMMC1_CLK_PX0,
+};
+
+static const unsigned int sdmmc1_cmd_px1_pins[] = {
+	TEGRA_PIN_SDMMC1_CMD_PX1,
+};
+
+static const unsigned int sdmmc1_dat0_px2_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT0_PX2,
+};
+
+static const unsigned int sdmmc1_dat1_px3_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT1_PX3,
+};
+
+static const unsigned int sdmmc1_dat2_px4_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT2_PX4,
+};
+
+static const unsigned int sdmmc1_dat3_px5_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT3_PX5,
+};
+
+static const unsigned int sdmmc1_comp_pins[] = {
+	TEGRA_PIN_SDMMC1_COMP,
+};
+
+static const unsigned int cpu_pwr_req_ph0_pins[] = {
+	TEGRA_PIN_CPU_PWR_REQ_PH0,
+};
+
+static const unsigned int gpu_pwr_req_ph1_pins[] = {
+	TEGRA_PIN_GPU_PWR_REQ_PH1,
+};
+
+static const unsigned int uart10_tx_ph2_pins[] = {
+	TEGRA_PIN_UART10_TX_PH2,
+};
+
+static const unsigned int uart10_rx_ph3_pins[] = {
+	TEGRA_PIN_UART10_RX_PH3,
+};
+
+static const unsigned int uart10_rts_n_ph4_pins[] = {
+	TEGRA_PIN_UART10_RTS_N_PH4,
+};
+
+static const unsigned int uart10_cts_n_ph5_pins[] = {
+	TEGRA_PIN_UART10_CTS_N_PH5,
+};
+
+static const unsigned int spi3_sck_ph6_pins[] = {
+	TEGRA_PIN_SPI3_SCK_PH6,
+};
+
+static const unsigned int spi3_miso_ph7_pins[] = {
+	TEGRA_PIN_SPI3_MISO_PH7,
+};
+
+static const unsigned int spi3_mosi_pj0_pins[] = {
+	TEGRA_PIN_SPI3_MOSI_PJ0,
+};
+
+static const unsigned int spi3_cs0_pj1_pins[] = {
+	TEGRA_PIN_SPI3_CS0_PJ1,
+};
+
+static const unsigned int spi3_cs3_pj2_pins[] = {
+	TEGRA_PIN_SPI3_CS3_PJ2,
+};
+
+static const unsigned int uart5_tx_pj3_pins[] = {
+	TEGRA_PIN_UART5_TX_PJ3,
+};
+
+static const unsigned int uart5_rx_pj4_pins[] = {
+	TEGRA_PIN_UART5_RX_PJ4,
+};
+
+static const unsigned int uart5_rts_n_pj5_pins[] = {
+	TEGRA_PIN_UART5_RTS_N_PJ5,
+};
+
+static const unsigned int uart5_cts_n_pj6_pins[] = {
+	TEGRA_PIN_UART5_CTS_N_PJ6,
+};
+
+static const unsigned int spi1_sck_pj7_pins[] = {
+	TEGRA_PIN_SPI1_SCK_PJ7,
+};
+
+static const unsigned int spi1_miso_pk0_pins[] = {
+	TEGRA_PIN_SPI1_MISO_PK0,
+};
+
+static const unsigned int spi1_mosi_pk1_pins[] = {
+	TEGRA_PIN_SPI1_MOSI_PK1,
+};
+
+static const unsigned int spi1_cs0_pk2_pins[] = {
+	TEGRA_PIN_SPI1_CS0_PK2,
+};
+
+static const unsigned int spi1_cs1_pk3_pins[] = {
+	TEGRA_PIN_SPI1_CS1_PK3,
+};
+
+static const unsigned int extperiph1_clk_pk4_pins[] = {
+	TEGRA_PIN_EXTPERIPH1_CLK_PK4,
+};
+
+static const unsigned int extperiph2_clk_pk5_pins[] = {
+	TEGRA_PIN_EXTPERIPH2_CLK_PK5,
+};
+
+static const unsigned int gen12_i2c_scl_pk6_pins[] = {
+	TEGRA_PIN_GEN12_I2C_SCL_PK6,
+};
+
+static const unsigned int gen12_i2c_sda_pk7_pins[] = {
+	TEGRA_PIN_GEN12_I2C_SDA_PK7,
+};
+
+
+static const unsigned int soc_gpio124_pl0_pins[] = {
+	TEGRA_PIN_SOC_GPIO124_PL0,
+};
+
+static const unsigned int soc_gpio125_pl1_pins[] = {
+	TEGRA_PIN_SOC_GPIO125_PL1,
+};
+
+static const unsigned int fan_tach0_pl2_pins[] = {
+	TEGRA_PIN_FAN_TACH0_PL2,
+};
+
+static const unsigned int soc_gpio127_pl3_pins[] = {
+	TEGRA_PIN_SOC_GPIO127_PL3,
+};
+
+static const unsigned int soc_gpio128_pl4_pins[] = {
+	TEGRA_PIN_SOC_GPIO128_PL4,
+};
+
+static const unsigned int soc_gpio129_pl5_pins[] = {
+	TEGRA_PIN_SOC_GPIO129_PL5,
+};
+
+static const unsigned int soc_gpio130_pl6_pins[] = {
+	TEGRA_PIN_SOC_GPIO130_PL6,
+};
+
+static const unsigned int soc_gpio131_pl7_pins[] = {
+	TEGRA_PIN_SOC_GPIO131_PL7,
+};
+
+static const unsigned int gp_pwm9_pm0_pins[] = {
+	TEGRA_PIN_GP_PWM9_PM0,
+};
+
+static const unsigned int soc_gpio133_pm1_pins[] = {
+	TEGRA_PIN_SOC_GPIO133_PM1,
+};
+
+static const unsigned int uart9_tx_pm2_pins[] = {
+	TEGRA_PIN_UART9_TX_PM2,
+};
+
+static const unsigned int uart9_rx_pm3_pins[] = {
+	TEGRA_PIN_UART9_RX_PM3,
+};
+
+static const unsigned int uart9_rts_n_pm4_pins[] = {
+	TEGRA_PIN_UART9_RTS_N_PM4,
+};
+
+static const unsigned int uart9_cts_n_pm5_pins[] = {
+	TEGRA_PIN_UART9_CTS_N_PM5,
+};
+
+
+static const unsigned int soc_gpio170_pu0_pins[] = {
+	TEGRA_PIN_SOC_GPIO170_PU0,
+};
+
+static const unsigned int soc_gpio171_pu1_pins[] = {
+	TEGRA_PIN_SOC_GPIO171_PU1,
+};
+
+static const unsigned int soc_gpio172_pu2_pins[] = {
+	TEGRA_PIN_SOC_GPIO172_PU2,
+};
+
+static const unsigned int soc_gpio173_pu3_pins[] = {
+	TEGRA_PIN_SOC_GPIO173_PU3,
+};
+
+static const unsigned int soc_gpio174_pu4_pins[] = {
+	TEGRA_PIN_SOC_GPIO174_PU4,
+};
+
+static const unsigned int soc_gpio175_pu5_pins[] = {
+	TEGRA_PIN_SOC_GPIO175_PU5,
+};
+
+static const unsigned int soc_gpio176_pu6_pins[] = {
+	TEGRA_PIN_SOC_GPIO176_PU6,
+};
+
+static const unsigned int soc_gpio177_pu7_pins[] = {
+	TEGRA_PIN_SOC_GPIO177_PU7,
+};
+
+static const unsigned int soc_gpio178_pv0_pins[] = {
+	TEGRA_PIN_SOC_GPIO178_PV0,
+};
+
+static const unsigned int pwm10_pv1_pins[] = {
+	TEGRA_PIN_PWM10_PV1,
+};
+
+static const unsigned int uart4_tx_pv2_pins[] = {
+	TEGRA_PIN_UART4_TX_PV2,
+};
+
+static const unsigned int uart4_rx_pv3_pins[] = {
+	TEGRA_PIN_UART4_RX_PV3,
+};
+
+static const unsigned int uart4_rts_n_pv4_pins[] = {
+	TEGRA_PIN_UART4_RTS_N_PV4,
+};
+
+static const unsigned int uart4_cts_n_pv5_pins[] = {
+	TEGRA_PIN_UART4_CTS_N_PV5,
+};
+
+static const unsigned int dap2_clk_pv6_pins[] = {
+	TEGRA_PIN_DAP2_CLK_PV6,
+};
+
+static const unsigned int dap2_dout_pv7_pins[] = {
+	TEGRA_PIN_DAP2_DOUT_PV7,
+};
+
+static const unsigned int dap2_din_pw0_pins[] = {
+	TEGRA_PIN_DAP2_DIN_PW0,
+};
+
+static const unsigned int dap2_fs_pw1_pins[] = {
+	TEGRA_PIN_DAP2_FS_PW1,
+};
+
+static const unsigned int gen1_i2c_scl_pw2_pins[] = {
+	TEGRA_PIN_GEN1_I2C_SCL_PW2,
+};
+
+static const unsigned int gen1_i2c_sda_pw3_pins[] = {
+	TEGRA_PIN_GEN1_I2C_SDA_PW3,
+};
+
+static const unsigned int gen0_i2c_scl_pw4_pins[] = {
+	TEGRA_PIN_GEN0_I2C_SCL_PW4,
+};
+
+static const unsigned int gen0_i2c_sda_pw5_pins[] = {
+	TEGRA_PIN_GEN0_I2C_SDA_PW5,
+};
+
+static const unsigned int pwr_i2c_scl_pw6_pins[] = {
+	TEGRA_PIN_PWR_I2C_SCL_PW6,
+};
+
+static const unsigned int pwr_i2c_sda_pw7_pins[] = {
+	TEGRA_PIN_PWR_I2C_SDA_PW7,
+};
+
+
+static const unsigned int qspi0_sck_pt0_pins[] = {
+	TEGRA_PIN_QSPI0_SCK_PT0,
+};
+
+static const unsigned int qspi0_cs_n_pt1_pins[] = {
+	TEGRA_PIN_QSPI0_CS_N_PT1,
+};
+
+static const unsigned int qspi0_io0_pt2_pins[] = {
+	TEGRA_PIN_QSPI0_IO0_PT2,
+};
+
+static const unsigned int qspi0_io1_pt3_pins[] = {
+	TEGRA_PIN_QSPI0_IO1_PT3,
+};
+
+static const unsigned int qspi0_io2_pt4_pins[] = {
+	TEGRA_PIN_QSPI0_IO2_PT4,
+};
+
+static const unsigned int qspi0_io3_pt5_pins[] = {
+	TEGRA_PIN_QSPI0_IO3_PT5,
+};
+
+static const unsigned int soc_gpio192_pt6_pins[] = {
+	TEGRA_PIN_SOC_GPIO192_PT6,
+};
+
+
+static const unsigned int soc_gpio138_pp0_pins[] = {
+	TEGRA_PIN_SOC_GPIO138_PP0,
+};
+
+static const unsigned int soc_gpio139_pp1_pins[] = {
+	TEGRA_PIN_SOC_GPIO139_PP1,
+};
+
+static const unsigned int dap6_sclk_pp2_pins[] = {
+	TEGRA_PIN_DAP6_SCLK_PP2,
+};
+
+static const unsigned int dap6_dout_pp3_pins[] = {
+	TEGRA_PIN_DAP6_DOUT_PP3,
+};
+
+static const unsigned int dap6_din_pp4_pins[] = {
+	TEGRA_PIN_DAP6_DIN_PP4,
+};
+
+static const unsigned int dap6_fs_pp5_pins[] = {
+	TEGRA_PIN_DAP6_FS_PP5,
+};
+
+static const unsigned int dap4_sclk_pp6_pins[] = {
+	TEGRA_PIN_DAP4_SCLK_PP6,
+};
+
+static const unsigned int dap4_dout_pp7_pins[] = {
+	TEGRA_PIN_DAP4_DOUT_PP7,
+};
+
+static const unsigned int dap4_din_pq0_pins[] = {
+	TEGRA_PIN_DAP4_DIN_PQ0,
+};
+
+static const unsigned int dap4_fs_pq1_pins[] = {
+	TEGRA_PIN_DAP4_FS_PQ1,
+};
+
+static const unsigned int spi5_sck_pq2_pins[] = {
+	TEGRA_PIN_SPI5_SCK_PQ2,
+};
+
+static const unsigned int spi5_miso_pq3_pins[] = {
+	TEGRA_PIN_SPI5_MISO_PQ3,
+};
+
+static const unsigned int spi5_mosi_pq4_pins[] = {
+	TEGRA_PIN_SPI5_MOSI_PQ4,
+};
+
+static const unsigned int spi5_cs0_pq5_pins[] = {
+	TEGRA_PIN_SPI5_CS0_PQ5,
+};
+
+static const unsigned int soc_gpio152_pq6_pins[] = {
+	TEGRA_PIN_SOC_GPIO152_PQ6,
+};
+
+static const unsigned int soc_gpio153_pq7_pins[] = {
+	TEGRA_PIN_SOC_GPIO153_PQ7,
+};
+
+static const unsigned int aud_mclk_pr0_pins[] = {
+	TEGRA_PIN_AUD_MCLK_PR0,
+};
+
+static const unsigned int soc_gpio155_pr1_pins[] = {
+	TEGRA_PIN_SOC_GPIO155_PR1,
+};
+
+static const unsigned int dap1_sclk_pr2_pins[] = {
+	TEGRA_PIN_DAP1_SCLK_PR2,
+};
+
+static const unsigned int dap1_out_pr3_pins[] = {
+	TEGRA_PIN_DAP1_OUT_PR3,
+};
+
+static const unsigned int dap1_in_pr4_pins[] = {
+	TEGRA_PIN_DAP1_IN_PR4,
+};
+
+static const unsigned int dap1_fs_pr5_pins[] = {
+	TEGRA_PIN_DAP1_FS_PR5,
+};
+
+static const unsigned int gen11_i2c_scl_pr6_pins[] = {
+	TEGRA_PIN_GEN11_I2C_SCL_PR6,
+};
+
+static const unsigned int gen11_i2c_sda_pr7_pins[] = {
+	TEGRA_PIN_GEN11_I2C_SDA_PR7,
+};
+
+static const unsigned int soc_gpio350_ps0_pins[] = {
+	TEGRA_PIN_SOC_GPIO350_PS0,
+};
+
+static const unsigned int soc_gpio351_ps1_pins[] = {
+	TEGRA_PIN_SOC_GPIO351_PS1,
+};
+
+
+static const unsigned int soc_gpio270_py0_pins[] = {
+	TEGRA_PIN_SOC_GPIO270_PY0,
+};
+
+static const unsigned int soc_gpio271_py1_pins[] = {
+	TEGRA_PIN_SOC_GPIO271_PY1,
+};
+
+static const unsigned int soc_gpio272_py2_pins[] = {
+	TEGRA_PIN_SOC_GPIO272_PY2,
+};
+
+static const unsigned int soc_gpio273_py3_pins[] = {
+	TEGRA_PIN_SOC_GPIO273_PY3,
+};
+
+static const unsigned int soc_gpio274_py4_pins[] = {
+	TEGRA_PIN_SOC_GPIO274_PY4,
+};
+
+static const unsigned int soc_gpio275_py5_pins[] = {
+	TEGRA_PIN_SOC_GPIO275_PY5,
+};
+
+static const unsigned int soc_gpio276_py6_pins[] = {
+	TEGRA_PIN_SOC_GPIO276_PY6,
+};
+
+static const unsigned int soc_gpio277_py7_pins[] = {
+	TEGRA_PIN_SOC_GPIO277_PY7,
+};
+
+static const unsigned int soc_gpio278_pz0_pins[] = {
+	TEGRA_PIN_SOC_GPIO278_PZ0,
+};
+
+static const unsigned int soc_gpio279_pz1_pins[] = {
+	TEGRA_PIN_SOC_GPIO279_PZ1,
+};
+
+static const unsigned int xhalt_trig_pz2_pins[] = {
+	TEGRA_PIN_XHALT_TRIG_PZ2,
+};
+
+static const unsigned int soc_gpio281_pz3_pins[] = {
+	TEGRA_PIN_SOC_GPIO281_PZ3,
+};
+
+static const unsigned int soc_gpio282_pz4_pins[] = {
+	TEGRA_PIN_SOC_GPIO282_PZ4,
+};
+
+static const unsigned int soc_gpio283_pz5_pins[] = {
+	TEGRA_PIN_SOC_GPIO283_PZ5,
+};
+
+static const unsigned int soc_gpio284_pz6_pins[] = {
+	TEGRA_PIN_SOC_GPIO284_PZ6,
+};
+
+static const unsigned int soc_gpio285_pz7_pins[] = {
+	TEGRA_PIN_SOC_GPIO285_PZ7,
+};
+
+static const unsigned int soc_gpio286_pal0_pins[] = {
+	TEGRA_PIN_SOC_GPIO286_PAL0,
+};
+
+static const unsigned int soc_gpio287_pal1_pins[] = {
+	TEGRA_PIN_SOC_GPIO287_PAL1,
+};
+
+static const unsigned int soc_gpio288_pal2_pins[] = {
+	TEGRA_PIN_SOC_GPIO288_PAL2,
+};
+
+
+static const unsigned int soc_gpio00_paa0_pins[] = {
+	TEGRA_PIN_SOC_GPIO00_PAA0,
+};
+
+static const unsigned int vcomp_alert_paa1_pins[] = {
+	TEGRA_PIN_VCOMP_ALERT_PAA1,
+};
+
+static const unsigned int ao_retention_n_paa2_pins[] = {
+	TEGRA_PIN_AO_RETENTION_N_PAA2,
+};
+
+static const unsigned int batt_oc_paa3_pins[] = {
+	TEGRA_PIN_BATT_OC_PAA3,
+};
+
+static const unsigned int bootv_ctl_n_paa4_pins[] = {
+	TEGRA_PIN_BOOTV_CTL_N_PAA4,
+};
+
+static const unsigned int power_on_paa5_pins[] = {
+	TEGRA_PIN_POWER_ON_PAA5,
+};
+
+static const unsigned int hdmi_cec_paa6_pins[] = {
+	TEGRA_PIN_HDMI_CEC_PAA6,
+};
+
+static const unsigned int soc_gpio07_paa7_pins[] = {
+	TEGRA_PIN_SOC_GPIO07_PAA7,
+};
+
+static const unsigned int soc_gpio08_pbb0_pins[] = {
+	TEGRA_PIN_SOC_GPIO08_PBB0,
+};
+
+static const unsigned int soc_gpio09_pbb1_pins[] = {
+	TEGRA_PIN_SOC_GPIO09_PBB1,
+};
+
+
+static const unsigned int gen2_i2c_scl_pcc0_pins[] = {
+	TEGRA_PIN_GEN2_I2C_SCL_PCC0,
+};
+
+static const unsigned int gen2_i2c_sda_pcc1_pins[] = {
+	TEGRA_PIN_GEN2_I2C_SDA_PCC1,
+};
+
+static const unsigned int gen3_i2c_scl_pcc2_pins[] = {
+	TEGRA_PIN_GEN3_I2C_SCL_PCC2,
+};
+
+static const unsigned int gen3_i2c_sda_pcc3_pins[] = {
+	TEGRA_PIN_GEN3_I2C_SDA_PCC3,
+};
+
+static const unsigned int gp_pwm4_pcc4_pins[] = {
+	TEGRA_PIN_GP_PWM4_PCC4,
+};
+
+static const unsigned int uart0_tx_pcc5_pins[] = {
+	TEGRA_PIN_UART0_TX_PCC5,
+};
+
+static const unsigned int uart0_rx_pcc6_pins[] = {
+	TEGRA_PIN_UART0_RX_PCC6,
+};
+
+static const unsigned int spi2_sck_pcc7_pins[] = {
+	TEGRA_PIN_SPI2_SCK_PCC7,
+};
+
+static const unsigned int spi2_miso_pdd0_pins[] = {
+	TEGRA_PIN_SPI2_MISO_PDD0,
+};
+
+static const unsigned int spi2_mosi_pdd1_pins[] = {
+	TEGRA_PIN_SPI2_MOSI_PDD1,
+};
+
+static const unsigned int spi2_cs0_n_pdd2_pins[] = {
+	TEGRA_PIN_SPI2_CS0_N_PDD2,
+};
+
+static const unsigned int soc_gpio21_pdd3_pins[] = {
+	TEGRA_PIN_SOC_GPIO21_PDD3,
+};
+
+static const unsigned int soc_gpio22_pdd4_pins[] = {
+	TEGRA_PIN_SOC_GPIO22_PDD4,
+};
+
+static const unsigned int soc_gpio23_pdd5_pins[] = {
+	TEGRA_PIN_SOC_GPIO23_PDD5,
+};
+
+static const unsigned int soc_gpio24_pdd6_pins[] = {
+	TEGRA_PIN_SOC_GPIO24_PDD6,
+};
+
+static const unsigned int soc_gpio25_pdd7_pins[] = {
+	TEGRA_PIN_SOC_GPIO25_PDD7,
+};
+
+static const unsigned int soc_gpio26_pee0_pins[] = {
+	TEGRA_PIN_SOC_GPIO26_PEE0,
+};
+
+static const unsigned int soc_gpio27_pee1_pins[] = {
+	TEGRA_PIN_SOC_GPIO27_PEE1,
+};
+
+static const unsigned int soc_gpio28_pee2_pins[] = {
+	TEGRA_PIN_SOC_GPIO28_PEE2,
+};
+
+static const unsigned int soc_gpio29_pee3_pins[] = {
+	TEGRA_PIN_SOC_GPIO29_PEE3,
+};
+
+enum tegra_mux_dt {
+	TEGRA_MUX_DCA_VSYNC,
+	TEGRA_MUX_DCA_HSYNC,
+	TEGRA_MUX_RSVD0,
+	TEGRA_MUX_DP_AUX_CH0_HPD,
+	TEGRA_MUX_DP_AUX_CH1_HPD,
+	TEGRA_MUX_DP_AUX_CH2_HPD,
+	TEGRA_MUX_DP_AUX_CH3_HPD,
+	TEGRA_MUX_GP_PWM2,
+	TEGRA_MUX_GP_PWM3,
+	TEGRA_MUX_I2C7_CLK,
+	TEGRA_MUX_I2C7_DAT,
+	TEGRA_MUX_I2C9_CLK,
+	TEGRA_MUX_I2C9_DAT,
+	TEGRA_MUX_UARTK_CTS,
+	TEGRA_MUX_UARTK_RTS,
+	TEGRA_MUX_UARTK_RXD,
+	TEGRA_MUX_UARTK_TXD,
+	TEGRA_MUX_SPI3_CS0,
+	TEGRA_MUX_SPI3_CS3,
+	TEGRA_MUX_SPI3_DIN,
+	TEGRA_MUX_SPI3_DOUT,
+	TEGRA_MUX_SPI3_SCK,
+	TEGRA_MUX_UARTF_CTS,
+	TEGRA_MUX_UARTF_RTS,
+	TEGRA_MUX_UARTF_RXD,
+	TEGRA_MUX_UARTF_TXD,
+	TEGRA_MUX_SPI1_CS0,
+	TEGRA_MUX_SPI1_CS1,
+	TEGRA_MUX_SPI1_DIN,
+	TEGRA_MUX_SPI1_DOUT,
+	TEGRA_MUX_SPI1_SCK,
+	TEGRA_MUX_EXTPERIPH2_CLK,
+	TEGRA_MUX_EXTPERIPH1_CLK,
+	TEGRA_MUX_I2C12_CLK,
+	TEGRA_MUX_I2C12_DAT,
+	TEGRA_MUX_NV_THERM_FAN_TACH0,
+	TEGRA_MUX_GP_PWM9,
+	TEGRA_MUX_UARTJ_CTS,
+	TEGRA_MUX_UARTJ_RTS,
+	TEGRA_MUX_UARTJ_RXD,
+	TEGRA_MUX_UARTJ_TXD,
+	TEGRA_MUX_I2C0_CLK,
+	TEGRA_MUX_I2C0_DAT,
+	TEGRA_MUX_I2C1_CLK,
+	TEGRA_MUX_I2C1_DAT,
+	TEGRA_MUX_I2S2_LRCK,
+	TEGRA_MUX_I2S2_SCLK,
+	TEGRA_MUX_I2S2_SDATA_OUT,
+	TEGRA_MUX_I2S2_SDATA_IN,
+	TEGRA_MUX_GP_PWM10,
+	TEGRA_MUX_UARTE_CTS,
+	TEGRA_MUX_UARTE_RTS,
+	TEGRA_MUX_UARTE_RXD,
+	TEGRA_MUX_UARTE_TXD,
+	TEGRA_MUX_I2C5_DAT,
+	TEGRA_MUX_I2C5_CLK,
+	TEGRA_MUX_I2S6_SDATA_IN,
+	TEGRA_MUX_I2S6_SDATA_OUT,
+	TEGRA_MUX_I2S6_LRCK,
+	TEGRA_MUX_I2S6_SCLK,
+	TEGRA_MUX_I2S4_SDATA_OUT,
+	TEGRA_MUX_I2S4_SCLK,
+	TEGRA_MUX_I2S4_SDATA_IN,
+	TEGRA_MUX_I2S4_LRCK,
+	TEGRA_MUX_SPI5_CS0,
+	TEGRA_MUX_SPI5_DIN,
+	TEGRA_MUX_SPI5_DOUT,
+	TEGRA_MUX_SPI5_SCK,
+	TEGRA_MUX_AUD_MCLK,
+	TEGRA_MUX_I2S1_SCLK,
+	TEGRA_MUX_I2S1_SDATA_IN,
+	TEGRA_MUX_I2S1_SDATA_OUT,
+	TEGRA_MUX_I2S1_LRCK,
+	TEGRA_MUX_I2C11_CLK,
+	TEGRA_MUX_I2C11_DAT,
+	TEGRA_MUX_XHALT_TRIG,
+	TEGRA_MUX_GP_PWM1,
+	TEGRA_MUX_GP_PWM6,
+	TEGRA_MUX_GP_PWM7,
+	TEGRA_MUX_GP_PWM8,
+	TEGRA_MUX_UFS0,
+	TEGRA_MUX_PE1_CLKREQ_L,
+	TEGRA_MUX_PE1_RST_L,
+	TEGRA_MUX_PE2_RST_L,
+	TEGRA_MUX_PE2_CLKREQ_L,
+	TEGRA_MUX_PE3_CLKREQ_L,
+	TEGRA_MUX_PE3_RST_L,
+	TEGRA_MUX_SGMII0_SMA_MDIO,
+	TEGRA_MUX_SGMII0_SMA_MDC,
+	TEGRA_MUX_USB_VBUS_EN0,
+	TEGRA_MUX_USB_VBUS_EN1,
+	TEGRA_MUX_ETH1_MDIO,
+	TEGRA_MUX_PE4_CLKREQ_L,
+	TEGRA_MUX_PE4_RST_L,
+	TEGRA_MUX_PE5_CLKREQ_L,
+	TEGRA_MUX_PE5_RST_L,
+	TEGRA_MUX_ETH0_MDIO,
+	TEGRA_MUX_ETH0_MDC,
+	TEGRA_MUX_ETH1_MDC,
+	TEGRA_MUX_ETH2_MDIO,
+	TEGRA_MUX_ETH2_MDC,
+	TEGRA_MUX_ETH3_MDIO,
+	TEGRA_MUX_ETH3_MDC,
+	TEGRA_MUX_QSPI0_CS_N,
+	TEGRA_MUX_QSPI0_IO0,
+	TEGRA_MUX_QSPI0_IO1,
+	TEGRA_MUX_QSPI0_IO2,
+	TEGRA_MUX_QSPI0_IO3,
+	TEGRA_MUX_QSPI0_SCK,
+	TEGRA_MUX_SDMMC1_CLK,
+	TEGRA_MUX_SDMMC1_CMD,
+	TEGRA_MUX_SDMMC1_COMP,
+	TEGRA_MUX_SDMMC1_DAT3,
+	TEGRA_MUX_SDMMC1_DAT2,
+	TEGRA_MUX_SDMMC1_DAT1,
+	TEGRA_MUX_SDMMC1_DAT0,
+	TEGRA_MUX_QSPI3_SCK,
+	TEGRA_MUX_QSPI3_CS0,
+	TEGRA_MUX_QSPI3_IO0,
+	TEGRA_MUX_QSPI3_IO1,
+	TEGRA_MUX_DCB_VSYNC,
+	TEGRA_MUX_DCB_HSYNC,
+	TEGRA_MUX_DSA_LSPII,
+	TEGRA_MUX_DCE_VSYNC,
+	TEGRA_MUX_DCE_HSYNC,
+	TEGRA_MUX_DCH_VSYNC,
+	TEGRA_MUX_DCH_HSYNC,
+	TEGRA_MUX_BL_EN,
+	TEGRA_MUX_BL_PWM_DIM0,
+	TEGRA_MUX_RSVD1,
+	TEGRA_MUX_SOC_THERM_OC3,
+	TEGRA_MUX_I2S5_SCLK,
+	TEGRA_MUX_I2S5_SDATA_IN,
+	TEGRA_MUX_EXTPERIPH3_CLK,
+	TEGRA_MUX_EXTPERIPH4_CLK,
+	TEGRA_MUX_I2S5_SDATA_OUT,
+	TEGRA_MUX_I2S5_LRCK,
+	TEGRA_MUX_SDMMC1_CD,
+	TEGRA_MUX_I2S7_SDATA_IN,
+	TEGRA_MUX_SPI4_SCK,
+	TEGRA_MUX_SPI4_DIN,
+	TEGRA_MUX_SPI4_DOUT,
+	TEGRA_MUX_SPI4_CS0,
+	TEGRA_MUX_SPI4_CS1,
+	TEGRA_MUX_GP_PWM5,
+	TEGRA_MUX_I2C14_CLK,
+	TEGRA_MUX_I2C14_DAT,
+	TEGRA_MUX_I2S8_SCLK,
+	TEGRA_MUX_I2S8_SDATA_OUT,
+	TEGRA_MUX_I2S8_LRCK,
+	TEGRA_MUX_I2S8_SDATA_IN,
+	TEGRA_MUX_I2C16_CLK,
+	TEGRA_MUX_I2C16_DAT,
+	TEGRA_MUX_I2S3_SCLK,
+	TEGRA_MUX_I2S3_SDATA_OUT,
+	TEGRA_MUX_I2S3_SDATA_IN,
+	TEGRA_MUX_I2S3_LRCK,
+	TEGRA_MUX_PM_TRIG1,
+	TEGRA_MUX_PM_TRIG0,
+	TEGRA_MUX_QSPI2_SCK,
+	TEGRA_MUX_QSPI2_CS0,
+	TEGRA_MUX_QSPI2_IO0,
+	TEGRA_MUX_QSPI2_IO1,
+	TEGRA_MUX_DCC_VSYNC,
+	TEGRA_MUX_DCC_HSYNC,
+	TEGRA_MUX_RSVD2,
+	TEGRA_MUX_DCF_VSYNC,
+	TEGRA_MUX_DCF_HSYNC,
+	TEGRA_MUX_SOUNDWIRE1_CLK,
+	TEGRA_MUX_SOUNDWIRE1_DAT0,
+	TEGRA_MUX_SOUNDWIRE1_DAT1,
+	TEGRA_MUX_SOUNDWIRE1_DAT2,
+	TEGRA_MUX_DMIC2_CLK,
+	TEGRA_MUX_DMIC2_DAT,
+	TEGRA_MUX_NV_THERM_FAN_TACH1,
+	TEGRA_MUX_I2C15_CLK,
+	TEGRA_MUX_I2C15_DAT,
+	TEGRA_MUX_I2S7_LRCK,
+	TEGRA_MUX_CCLA_LA_TRIGGER_MUX,
+	TEGRA_MUX_I2S7_SCLK,
+	TEGRA_MUX_I2S7_SDATA_OUT,
+	TEGRA_MUX_DMIC1_DAT,
+	TEGRA_MUX_DMIC1_CLK,
+	TEGRA_MUX_DCD_VSYNC,
+	TEGRA_MUX_DCD_HSYNC,
+	TEGRA_MUX_RSVD3,
+	TEGRA_MUX_DCG_VSYNC,
+	TEGRA_MUX_DCG_HSYNC,
+	TEGRA_MUX_DSPK1_CLK,
+	TEGRA_MUX_DSPK1_DAT,
+	TEGRA_MUX_SOC_THERM_OC2,
+	TEGRA_MUX_ISTCTRL_IST_DONE_N,
+	TEGRA_MUX_SOC_THERM_OC1,
+	TEGRA_MUX_TSC_EDGE_OUT0C,
+	TEGRA_MUX_TSC_EDGE_OUT0D,
+	TEGRA_MUX_TSC_EDGE_OUT0A,
+	TEGRA_MUX_TSC_EDGE_OUT0B,
+	TEGRA_MUX_TOUCH_CLK,
+	TEGRA_MUX_HDMI_CEC,
+	TEGRA_MUX_I2C2_CLK,
+	TEGRA_MUX_I2C2_DAT,
+	TEGRA_MUX_I2C3_CLK,
+	TEGRA_MUX_I2C3_DAT,
+	TEGRA_MUX_GP_PWM4,
+	TEGRA_MUX_UARTA_TXD,
+	TEGRA_MUX_UARTA_RXD,
+	TEGRA_MUX_SPI2_SCK,
+	TEGRA_MUX_SPI2_DIN,
+	TEGRA_MUX_SPI2_DOUT,
+	TEGRA_MUX_SPI2_CS0,
+	TEGRA_MUX_TSC_SYNC1,
+	TEGRA_MUX_TSC_EDGE_OUT3,
+	TEGRA_MUX_TSC_EDGE_OUT0,
+	TEGRA_MUX_TSC_EDGE_OUT1,
+	TEGRA_MUX_TSC_SYNC0,
+	TEGRA_MUX_SOUNDWIRE0_CLK,
+	TEGRA_MUX_SOUNDWIRE0_DAT0,
+	TEGRA_MUX_L0L1_RST_OUT_N,
+	TEGRA_MUX_L2_RST_OUT_N,
+	TEGRA_MUX_UARTL_TXD,
+	TEGRA_MUX_UARTL_RXD,
+	TEGRA_MUX_I2S9_SCLK,
+	TEGRA_MUX_I2S9_SDATA_OUT,
+	TEGRA_MUX_I2S9_SDATA_IN,
+	TEGRA_MUX_I2S9_LRCK,
+	TEGRA_MUX_DMIC5_DAT,
+	TEGRA_MUX_DMIC5_CLK,
+	TEGRA_MUX_TSC_EDGE_OUT2,
+};
+
+/* Make list of each function name */
+#define TEGRA_PIN_FUNCTION(lid) #lid
+
+static const char * const tegra264_functions[] = {
+	TEGRA_PIN_FUNCTION(dca_vsync),
+	TEGRA_PIN_FUNCTION(dca_hsync),
+	TEGRA_PIN_FUNCTION(rsvd0),
+	TEGRA_PIN_FUNCTION(dp_aux_ch0_hpd),
+	TEGRA_PIN_FUNCTION(dp_aux_ch1_hpd),
+	TEGRA_PIN_FUNCTION(dp_aux_ch2_hpd),
+	TEGRA_PIN_FUNCTION(dp_aux_ch3_hpd),
+	TEGRA_PIN_FUNCTION(gp_pwm2),
+	TEGRA_PIN_FUNCTION(gp_pwm3),
+	TEGRA_PIN_FUNCTION(i2c7_clk),
+	TEGRA_PIN_FUNCTION(i2c7_dat),
+	TEGRA_PIN_FUNCTION(i2c9_clk),
+	TEGRA_PIN_FUNCTION(i2c9_dat),
+	TEGRA_PIN_FUNCTION(uartk_cts),
+	TEGRA_PIN_FUNCTION(uartk_rts),
+	TEGRA_PIN_FUNCTION(uartk_rxd),
+	TEGRA_PIN_FUNCTION(uartk_txd),
+	TEGRA_PIN_FUNCTION(spi3_cs0),
+	TEGRA_PIN_FUNCTION(spi3_cs3),
+	TEGRA_PIN_FUNCTION(spi3_din),
+	TEGRA_PIN_FUNCTION(spi3_dout),
+	TEGRA_PIN_FUNCTION(spi3_sck),
+	TEGRA_PIN_FUNCTION(uartf_cts),
+	TEGRA_PIN_FUNCTION(uartf_rts),
+	TEGRA_PIN_FUNCTION(uartf_rxd),
+	TEGRA_PIN_FUNCTION(uartf_txd),
+	TEGRA_PIN_FUNCTION(spi1_cs0),
+	TEGRA_PIN_FUNCTION(spi1_cs1),
+	TEGRA_PIN_FUNCTION(spi1_din),
+	TEGRA_PIN_FUNCTION(spi1_dout),
+	TEGRA_PIN_FUNCTION(spi1_sck),
+	TEGRA_PIN_FUNCTION(extperiph2_clk),
+	TEGRA_PIN_FUNCTION(extperiph1_clk),
+	TEGRA_PIN_FUNCTION(i2c12_clk),
+	TEGRA_PIN_FUNCTION(i2c12_dat),
+	TEGRA_PIN_FUNCTION(nv_therm_fan_tach0),
+	TEGRA_PIN_FUNCTION(gp_pwm9),
+	TEGRA_PIN_FUNCTION(uartj_cts),
+	TEGRA_PIN_FUNCTION(uartj_rts),
+	TEGRA_PIN_FUNCTION(uartj_rxd),
+	TEGRA_PIN_FUNCTION(uartj_txd),
+	TEGRA_PIN_FUNCTION(i2c0_clk),
+	TEGRA_PIN_FUNCTION(i2c0_dat),
+	TEGRA_PIN_FUNCTION(i2c1_clk),
+	TEGRA_PIN_FUNCTION(i2c1_dat),
+	TEGRA_PIN_FUNCTION(i2s2_lrck),
+	TEGRA_PIN_FUNCTION(i2s2_sclk),
+	TEGRA_PIN_FUNCTION(i2s2_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s2_sdata_in),
+	TEGRA_PIN_FUNCTION(gp_pwm10),
+	TEGRA_PIN_FUNCTION(uarte_cts),
+	TEGRA_PIN_FUNCTION(uarte_rts),
+	TEGRA_PIN_FUNCTION(uarte_rxd),
+	TEGRA_PIN_FUNCTION(uarte_txd),
+	TEGRA_PIN_FUNCTION(i2c5_dat),
+	TEGRA_PIN_FUNCTION(i2c5_clk),
+	TEGRA_PIN_FUNCTION(i2s6_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s6_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s6_lrck),
+	TEGRA_PIN_FUNCTION(i2s6_sclk),
+	TEGRA_PIN_FUNCTION(i2s4_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s4_sclk),
+	TEGRA_PIN_FUNCTION(i2s4_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s4_lrck),
+	TEGRA_PIN_FUNCTION(spi5_cs0),
+	TEGRA_PIN_FUNCTION(spi5_din),
+	TEGRA_PIN_FUNCTION(spi5_dout),
+	TEGRA_PIN_FUNCTION(spi5_sck),
+	TEGRA_PIN_FUNCTION(aud_mclk),
+	TEGRA_PIN_FUNCTION(i2s1_sclk),
+	TEGRA_PIN_FUNCTION(i2s1_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s1_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s1_lrck),
+	TEGRA_PIN_FUNCTION(i2c11_clk),
+	TEGRA_PIN_FUNCTION(i2c11_dat),
+	TEGRA_PIN_FUNCTION(xhalt_trig),
+	TEGRA_PIN_FUNCTION(gp_pwm1),
+	TEGRA_PIN_FUNCTION(gp_pwm6),
+	TEGRA_PIN_FUNCTION(gp_pwm7),
+	TEGRA_PIN_FUNCTION(gp_pwm8),
+	TEGRA_PIN_FUNCTION(ufs0),
+	TEGRA_PIN_FUNCTION(pe1_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe1_rst_l),
+	TEGRA_PIN_FUNCTION(pe2_rst_l),
+	TEGRA_PIN_FUNCTION(pe2_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe3_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe3_rst_l),
+	TEGRA_PIN_FUNCTION(sgmii0_sma_mdio),
+	TEGRA_PIN_FUNCTION(sgmii0_sma_mdc),
+	TEGRA_PIN_FUNCTION(usb_vbus_en0),
+	TEGRA_PIN_FUNCTION(usb_vbus_en1),
+	TEGRA_PIN_FUNCTION(eth1_mdio),
+	TEGRA_PIN_FUNCTION(pe4_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe4_rst_l),
+	TEGRA_PIN_FUNCTION(pe5_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe5_rst_l),
+	TEGRA_PIN_FUNCTION(eth0_mdio),
+	TEGRA_PIN_FUNCTION(eth0_mdc),
+	TEGRA_PIN_FUNCTION(eth1_mdc),
+	TEGRA_PIN_FUNCTION(eth2_mdio),
+	TEGRA_PIN_FUNCTION(eth2_mdc),
+	TEGRA_PIN_FUNCTION(eth3_mdio),
+	TEGRA_PIN_FUNCTION(eth3_mdc),
+	TEGRA_PIN_FUNCTION(qspi0_cs_n),
+	TEGRA_PIN_FUNCTION(qspi0_io0),
+	TEGRA_PIN_FUNCTION(qspi0_io1),
+	TEGRA_PIN_FUNCTION(qspi0_io2),
+	TEGRA_PIN_FUNCTION(qspi0_io3),
+	TEGRA_PIN_FUNCTION(qspi0_sck),
+	TEGRA_PIN_FUNCTION(sdmmc1_clk),
+	TEGRA_PIN_FUNCTION(sdmmc1_cmd),
+	TEGRA_PIN_FUNCTION(sdmmc1_comp),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat3),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat2),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat1),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat0),
+	TEGRA_PIN_FUNCTION(qspi3_sck),
+	TEGRA_PIN_FUNCTION(qspi3_cs0),
+	TEGRA_PIN_FUNCTION(qspi3_io0),
+	TEGRA_PIN_FUNCTION(qspi3_io1),
+	TEGRA_PIN_FUNCTION(dcb_vsync),
+	TEGRA_PIN_FUNCTION(dcb_hsync),
+	TEGRA_PIN_FUNCTION(dsa_lspii),
+	TEGRA_PIN_FUNCTION(dce_vsync),
+	TEGRA_PIN_FUNCTION(dce_hsync),
+	TEGRA_PIN_FUNCTION(dch_vsync),
+	TEGRA_PIN_FUNCTION(dch_hsync),
+	TEGRA_PIN_FUNCTION(bl_en),
+	TEGRA_PIN_FUNCTION(bl_pwm_dim0),
+	TEGRA_PIN_FUNCTION(rsvd1),
+	TEGRA_PIN_FUNCTION(soc_therm_oc3),
+	TEGRA_PIN_FUNCTION(i2s5_sclk),
+	TEGRA_PIN_FUNCTION(i2s5_sdata_in),
+	TEGRA_PIN_FUNCTION(extperiph3_clk),
+	TEGRA_PIN_FUNCTION(extperiph4_clk),
+	TEGRA_PIN_FUNCTION(i2s5_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s5_lrck),
+	TEGRA_PIN_FUNCTION(sdmmc1_cd),
+	TEGRA_PIN_FUNCTION(i2s7_sdata_in),
+	TEGRA_PIN_FUNCTION(spi4_sck),
+	TEGRA_PIN_FUNCTION(spi4_din),
+	TEGRA_PIN_FUNCTION(spi4_dout),
+	TEGRA_PIN_FUNCTION(spi4_cs0),
+	TEGRA_PIN_FUNCTION(spi4_cs1),
+	TEGRA_PIN_FUNCTION(gp_pwm5),
+	TEGRA_PIN_FUNCTION(i2c14_clk),
+	TEGRA_PIN_FUNCTION(i2c14_dat),
+	TEGRA_PIN_FUNCTION(i2s8_sclk),
+	TEGRA_PIN_FUNCTION(i2s8_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s8_lrck),
+	TEGRA_PIN_FUNCTION(i2s8_sdata_in),
+	TEGRA_PIN_FUNCTION(i2c16_clk),
+	TEGRA_PIN_FUNCTION(i2c16_dat),
+	TEGRA_PIN_FUNCTION(i2s3_sclk),
+	TEGRA_PIN_FUNCTION(i2s3_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s3_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s3_lrck),
+	TEGRA_PIN_FUNCTION(pm_trig1),
+	TEGRA_PIN_FUNCTION(pm_trig0),
+	TEGRA_PIN_FUNCTION(qspi2_sck),
+	TEGRA_PIN_FUNCTION(qspi2_cs0),
+	TEGRA_PIN_FUNCTION(qspi2_io0),
+	TEGRA_PIN_FUNCTION(qspi2_io1),
+	TEGRA_PIN_FUNCTION(dcc_vsync),
+	TEGRA_PIN_FUNCTION(dcc_hsync),
+	TEGRA_PIN_FUNCTION(rsvd2),
+	TEGRA_PIN_FUNCTION(dcf_vsync),
+	TEGRA_PIN_FUNCTION(dcf_hsync),
+	TEGRA_PIN_FUNCTION(soundwire1_clk),
+	TEGRA_PIN_FUNCTION(soundwire1_dat0),
+	TEGRA_PIN_FUNCTION(soundwire1_dat1),
+	TEGRA_PIN_FUNCTION(soundwire1_dat2),
+	TEGRA_PIN_FUNCTION(dmic2_clk),
+	TEGRA_PIN_FUNCTION(dmic2_dat),
+	TEGRA_PIN_FUNCTION(nv_therm_fan_tach1),
+	TEGRA_PIN_FUNCTION(i2c15_clk),
+	TEGRA_PIN_FUNCTION(i2c15_dat),
+	TEGRA_PIN_FUNCTION(i2s7_lrck),
+	TEGRA_PIN_FUNCTION(ccla_la_trigger_mux),
+	TEGRA_PIN_FUNCTION(i2s7_sclk),
+	TEGRA_PIN_FUNCTION(i2s7_sdata_out),
+	TEGRA_PIN_FUNCTION(dmic1_dat),
+	TEGRA_PIN_FUNCTION(dmic1_clk),
+	TEGRA_PIN_FUNCTION(dcd_vsync),
+	TEGRA_PIN_FUNCTION(dcd_hsync),
+	TEGRA_PIN_FUNCTION(rsvd3),
+	TEGRA_PIN_FUNCTION(dcg_vsync),
+	TEGRA_PIN_FUNCTION(dcg_hsync),
+	TEGRA_PIN_FUNCTION(dspk1_clk),
+	TEGRA_PIN_FUNCTION(dspk1_dat),
+	TEGRA_PIN_FUNCTION(soc_therm_oc2),
+	TEGRA_PIN_FUNCTION(istctrl_ist_done_n),
+	TEGRA_PIN_FUNCTION(soc_therm_oc1),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0c),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0d),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0a),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0b),
+	TEGRA_PIN_FUNCTION(touch_clk),
+	TEGRA_PIN_FUNCTION(hdmi_cec),
+	TEGRA_PIN_FUNCTION(i2c2_clk),
+	TEGRA_PIN_FUNCTION(i2c2_dat),
+	TEGRA_PIN_FUNCTION(i2c3_clk),
+	TEGRA_PIN_FUNCTION(i2c3_dat),
+	TEGRA_PIN_FUNCTION(gp_pwm4),
+	TEGRA_PIN_FUNCTION(uarta_txd),
+	TEGRA_PIN_FUNCTION(uarta_rxd),
+	TEGRA_PIN_FUNCTION(spi2_sck),
+	TEGRA_PIN_FUNCTION(spi2_din),
+	TEGRA_PIN_FUNCTION(spi2_dout),
+	TEGRA_PIN_FUNCTION(spi2_cs0),
+	TEGRA_PIN_FUNCTION(tsc_sync1),
+	TEGRA_PIN_FUNCTION(tsc_edge_out3),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0),
+	TEGRA_PIN_FUNCTION(tsc_edge_out1),
+	TEGRA_PIN_FUNCTION(tsc_sync0),
+	TEGRA_PIN_FUNCTION(soundwire0_clk),
+	TEGRA_PIN_FUNCTION(soundwire0_dat0),
+	TEGRA_PIN_FUNCTION(l0l1_rst_out_n),
+	TEGRA_PIN_FUNCTION(l2_rst_out_n),
+	TEGRA_PIN_FUNCTION(uartl_txd),
+	TEGRA_PIN_FUNCTION(uartl_rxd),
+	TEGRA_PIN_FUNCTION(i2s9_sclk),
+	TEGRA_PIN_FUNCTION(i2s9_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s9_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s9_lrck),
+	TEGRA_PIN_FUNCTION(dmic5_dat),
+	TEGRA_PIN_FUNCTION(dmic5_clk),
+	TEGRA_PIN_FUNCTION(tsc_edge_out2),
+};
+
+
+#define PINGROUP_REG_Y(r) ((r))
+#define PINGROUP_REG_N(r) -1
+
+#define DRV_PINGROUP_Y(r) ((r))
+#define DRV_PINGROUP_N(r) -1
+
+#define DRV_PINGROUP_ENTRY_N(pg_name)				\
+		.drv_reg = -1,					\
+		.drv_bank = -1,					\
+		.drvdn_bit = -1,				\
+		.drvup_bit = -1,				\
+		.slwr_bit = -1,					\
+		.slwf_bit = -1
+
+#define DRV_PINGROUP_ENTRY_Y(r, drvdn_b, drvdn_w, drvup_b,	\
+			     drvup_w, slwr_b, slwr_w, slwf_b,	\
+			     slwf_w, bank)			\
+		.drv_reg = DRV_PINGROUP_Y(r),			\
+		.drv_bank = bank,				\
+		.drvdn_bit = drvdn_b,				\
+		.drvdn_width = drvdn_w,				\
+		.drvup_bit = drvup_b,				\
+		.drvup_width = drvup_w,				\
+		.slwr_bit = slwr_b,				\
+		.slwr_width = slwr_w,				\
+		.slwf_bit = slwf_b,				\
+		.slwf_width = slwf_w
+
+#define PIN_PINGROUP_ENTRY_N(pg_name)				\
+		.mux_reg = -1,					\
+		.pupd_reg = -1,					\
+		.tri_reg = -1,					\
+		.einput_bit = -1,				\
+		.e_io_hv_bit = -1,				\
+		.odrain_bit = -1,				\
+		.lock_bit = -1,					\
+		.parked_bit = -1,				\
+		.lpmd_bit = -1,					\
+		.drvtype_bit = -1,				\
+		.lpdr_bit = -1,					\
+		.pbias_buf_bit = -1,				\
+		.preemp_bit = -1,				\
+		.rfu_in_bit = -1
+
+#define PIN_PINGROUP_ENTRY_Y(r, bank, pupd, e_io_hv, e_lpbk, e_input,	\
+				e_lpdr, e_pbias_buf, gpio_sfio_sel,	\
+				schmitt_b)				\
+		.mux_reg = PINGROUP_REG_Y(r),			\
+		.lpmd_bit = -1,					\
+		.lock_bit = -1,					\
+		.hsm_bit = -1,					\
+		.mux_bank = bank,				\
+		.mux_bit = 0,					\
+		.pupd_reg = PINGROUP_REG_##pupd(r),		\
+		.pupd_bank = bank,				\
+		.pupd_bit = 2,					\
+		.tri_reg = PINGROUP_REG_Y(r),			\
+		.tri_bank = bank,				\
+		.tri_bit = 4,					\
+		.einput_bit = e_input,				\
+		.sfsel_bit = gpio_sfio_sel,			\
+		.schmitt_bit = schmitt_b,			\
+		.drvtype_bit = 13,				\
+		.lpdr_bit = e_lpdr,				\
+		.drv_reg = -1,					\
+
+
+#define drive_eth1_mdio_pe0 DRV_PINGROUP_ENTRY_Y(0x4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l4_clkreq_n_pd0 DRV_PINGROUP_ENTRY_Y(0xc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l4_rst_n_pd1 DRV_PINGROUP_ENTRY_Y(0x14, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l5_clkreq_n_pd2 DRV_PINGROUP_ENTRY_Y(0x1c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l5_rst_n_pd3 DRV_PINGROUP_ENTRY_Y(0x24, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth0_mdio_pd4 DRV_PINGROUP_ENTRY_Y(0x2c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth0_mdc_pd5 DRV_PINGROUP_ENTRY_Y(0x34, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth1_mdc_pe1 DRV_PINGROUP_ENTRY_Y(0x3c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth2_mdio_pe2 DRV_PINGROUP_ENTRY_Y(0x44, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth2_mdc_pe3 DRV_PINGROUP_ENTRY_Y(0x4c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth3_mdio_pd6 DRV_PINGROUP_ENTRY_Y(0x54, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth3_mdc_pd7 DRV_PINGROUP_ENTRY_Y(0x5c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l1_clkreq_n_pb0 DRV_PINGROUP_ENTRY_Y(0x2004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l1_rst_n_pb1 DRV_PINGROUP_ENTRY_Y(0x200c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_wake_n_pc2 DRV_PINGROUP_ENTRY_Y(0x2014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l2_rst_n_pb3 DRV_PINGROUP_ENTRY_Y(0x201c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l2_clkreq_n_pb2 DRV_PINGROUP_ENTRY_Y(0x2024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l3_clkreq_n_pb4 DRV_PINGROUP_ENTRY_Y(0x202c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l3_rst_n_pb5 DRV_PINGROUP_ENTRY_Y(0x2034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_sgmii0_sma_mdio_pc0 DRV_PINGROUP_ENTRY_Y(0x203c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_sgmii0_sma_mdc_pc1 DRV_PINGROUP_ENTRY_Y(0x2044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio113_pb6 DRV_PINGROUP_ENTRY_Y(0x204c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio114_pb7 DRV_PINGROUP_ENTRY_Y(0x2054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm1_pa0 DRV_PINGROUP_ENTRY_Y(0x3004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm6_pa1 DRV_PINGROUP_ENTRY_Y(0x300c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm7_pa2 DRV_PINGROUP_ENTRY_Y(0x3014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm8_pa3 DRV_PINGROUP_ENTRY_Y(0x301c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_ufs0_ref_clk_pa4 DRV_PINGROUP_ENTRY_Y(0x3024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_ufs0_rst_n_pa5 DRV_PINGROUP_ENTRY_Y(0x302c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+
+#define drive_cpu_pwr_req_ph0 DRV_PINGROUP_ENTRY_Y(0x4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gpu_pwr_req_ph1 DRV_PINGROUP_ENTRY_Y(0xc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_cts_n_ph5 DRV_PINGROUP_ENTRY_Y(0x14, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_rts_n_ph4 DRV_PINGROUP_ENTRY_Y(0x1c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_rx_ph3 DRV_PINGROUP_ENTRY_Y(0x24, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_tx_ph2 DRV_PINGROUP_ENTRY_Y(0x2c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_cs0_pj1 DRV_PINGROUP_ENTRY_Y(0x34, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_cs3_pj2 DRV_PINGROUP_ENTRY_Y(0x3c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_miso_ph7 DRV_PINGROUP_ENTRY_Y(0x44, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_mosi_pj0 DRV_PINGROUP_ENTRY_Y(0x4c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_sck_ph6 DRV_PINGROUP_ENTRY_Y(0x54, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_cts_n_pj6 DRV_PINGROUP_ENTRY_Y(0x5c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_rts_n_pj5 DRV_PINGROUP_ENTRY_Y(0x64, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_rx_pj4 DRV_PINGROUP_ENTRY_Y(0x6c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_tx_pj3 DRV_PINGROUP_ENTRY_Y(0x74, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_cs0_pk2 DRV_PINGROUP_ENTRY_Y(0x7c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_cs1_pk3 DRV_PINGROUP_ENTRY_Y(0x84, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_miso_pk0 DRV_PINGROUP_ENTRY_Y(0x8c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_mosi_pk1 DRV_PINGROUP_ENTRY_Y(0x94, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_sck_pj7 DRV_PINGROUP_ENTRY_Y(0x9c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_extperiph2_clk_pk5 DRV_PINGROUP_ENTRY_Y(0xa4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_extperiph1_clk_pk4 DRV_PINGROUP_ENTRY_Y(0xac, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen12_i2c_scl_pk6 DRV_PINGROUP_ENTRY_Y(0xb4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen12_i2c_sda_pk7 DRV_PINGROUP_ENTRY_Y(0xbc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio124_pl0 DRV_PINGROUP_ENTRY_Y(0x1004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio125_pl1 DRV_PINGROUP_ENTRY_Y(0x100c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_fan_tach0_pl2 DRV_PINGROUP_ENTRY_Y(0x1014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio127_pl3 DRV_PINGROUP_ENTRY_Y(0x101c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio128_pl4 DRV_PINGROUP_ENTRY_Y(0x1024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio129_pl5 DRV_PINGROUP_ENTRY_Y(0x102c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio130_pl6 DRV_PINGROUP_ENTRY_Y(0x1034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio131_pl7 DRV_PINGROUP_ENTRY_Y(0x103c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gp_pwm9_pm0 DRV_PINGROUP_ENTRY_Y(0x1044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio133_pm1 DRV_PINGROUP_ENTRY_Y(0x104c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_cts_n_pm5 DRV_PINGROUP_ENTRY_Y(0x1054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_rts_n_pm4 DRV_PINGROUP_ENTRY_Y(0x105c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_rx_pm3 DRV_PINGROUP_ENTRY_Y(0x1064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_tx_pm2 DRV_PINGROUP_ENTRY_Y(0x106c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_comp DRV_PINGROUP_ENTRY_N(no_entry)
+#define drive_sdmmc1_clk_px0 DRV_PINGROUP_ENTRY_Y(0x2004, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_cmd_px1 DRV_PINGROUP_ENTRY_Y(0x200c, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat3_px5 DRV_PINGROUP_ENTRY_Y(0x201c, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat2_px4 DRV_PINGROUP_ENTRY_Y(0x2024, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat1_px3 DRV_PINGROUP_ENTRY_Y(0x202c, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat0_px2 DRV_PINGROUP_ENTRY_Y(0x2034, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_qspi0_cs_n_pt1 DRV_PINGROUP_ENTRY_Y(0x3004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io0_pt2 DRV_PINGROUP_ENTRY_Y(0x300c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io1_pt3 DRV_PINGROUP_ENTRY_Y(0x3014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io2_pt4 DRV_PINGROUP_ENTRY_Y(0x301c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io3_pt5 DRV_PINGROUP_ENTRY_Y(0x3024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_sck_pt0 DRV_PINGROUP_ENTRY_Y(0x302c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio192_pt6 DRV_PINGROUP_ENTRY_Y(0x3034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio138_pp0 DRV_PINGROUP_ENTRY_Y(0x5004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio139_pp1 DRV_PINGROUP_ENTRY_Y(0x500c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_din_pp4 DRV_PINGROUP_ENTRY_Y(0x5014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_dout_pp3 DRV_PINGROUP_ENTRY_Y(0x501c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_fs_pp5 DRV_PINGROUP_ENTRY_Y(0x5024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_sclk_pp2 DRV_PINGROUP_ENTRY_Y(0x502c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_dout_pp7 DRV_PINGROUP_ENTRY_Y(0x5034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_sclk_pp6 DRV_PINGROUP_ENTRY_Y(0x503c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_din_pq0 DRV_PINGROUP_ENTRY_Y(0x5044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_fs_pq1 DRV_PINGROUP_ENTRY_Y(0x504c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_cs0_pq5 DRV_PINGROUP_ENTRY_Y(0x5054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_miso_pq3 DRV_PINGROUP_ENTRY_Y(0x505c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_mosi_pq4 DRV_PINGROUP_ENTRY_Y(0x5064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_sck_pq2 DRV_PINGROUP_ENTRY_Y(0x506c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio152_pq6 DRV_PINGROUP_ENTRY_Y(0x5074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio153_pq7 DRV_PINGROUP_ENTRY_Y(0x507c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio155_pr1 DRV_PINGROUP_ENTRY_Y(0x5084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_aud_mclk_pr0 DRV_PINGROUP_ENTRY_Y(0x508c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_sclk_pr2 DRV_PINGROUP_ENTRY_Y(0x5094, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_in_pr4 DRV_PINGROUP_ENTRY_Y(0x509c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_out_pr3 DRV_PINGROUP_ENTRY_Y(0x50a4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_fs_pr5 DRV_PINGROUP_ENTRY_Y(0x50ac, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen11_i2c_scl_pr6 DRV_PINGROUP_ENTRY_Y(0x50b4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen11_i2c_sda_pr7 DRV_PINGROUP_ENTRY_Y(0x50bc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio350_ps0 DRV_PINGROUP_ENTRY_Y(0x50c4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio351_ps1 DRV_PINGROUP_ENTRY_Y(0x50cc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen0_i2c_scl_pw4 DRV_PINGROUP_ENTRY_Y(0x6004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen0_i2c_sda_pw5 DRV_PINGROUP_ENTRY_Y(0x600c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen1_i2c_scl_pw2 DRV_PINGROUP_ENTRY_Y(0x6014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen1_i2c_sda_pw3 DRV_PINGROUP_ENTRY_Y(0x601c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_fs_pw1 DRV_PINGROUP_ENTRY_Y(0x6044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_clk_pv6 DRV_PINGROUP_ENTRY_Y(0x604c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_din_pw0 DRV_PINGROUP_ENTRY_Y(0x6054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_dout_pv7 DRV_PINGROUP_ENTRY_Y(0x605c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm10_pv1 DRV_PINGROUP_ENTRY_Y(0x6064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio170_pu0 DRV_PINGROUP_ENTRY_Y(0x606c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio171_pu1 DRV_PINGROUP_ENTRY_Y(0x6074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio172_pu2 DRV_PINGROUP_ENTRY_Y(0x607c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio173_pu3 DRV_PINGROUP_ENTRY_Y(0x6084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio174_pu4 DRV_PINGROUP_ENTRY_Y(0x608c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio175_pu5 DRV_PINGROUP_ENTRY_Y(0x6094, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio176_pu6 DRV_PINGROUP_ENTRY_Y(0x609c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio177_pu7 DRV_PINGROUP_ENTRY_Y(0x60a4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio178_pv0 DRV_PINGROUP_ENTRY_Y(0x60ac, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_cts_n_pv5 DRV_PINGROUP_ENTRY_Y(0x60b4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_rts_n_pv4 DRV_PINGROUP_ENTRY_Y(0x60bc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_rx_pv3 DRV_PINGROUP_ENTRY_Y(0x60c4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_tx_pv2 DRV_PINGROUP_ENTRY_Y(0x60cc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwr_i2c_sda_pw7 DRV_PINGROUP_ENTRY_Y(0x60d4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwr_i2c_scl_pw6 DRV_PINGROUP_ENTRY_Y(0x60dc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio250_pf0 DRV_PINGROUP_ENTRY_Y(0x7004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio251_pf1 DRV_PINGROUP_ENTRY_Y(0x700c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio252_pf2 DRV_PINGROUP_ENTRY_Y(0x7014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch0_hpd_pf3 DRV_PINGROUP_ENTRY_Y(0x701c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch1_hpd_pf4 DRV_PINGROUP_ENTRY_Y(0x7024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch2_hpd_pf5 DRV_PINGROUP_ENTRY_Y(0x702c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch3_hpd_pf6 DRV_PINGROUP_ENTRY_Y(0x7034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm2_pf7 DRV_PINGROUP_ENTRY_Y(0x703c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm3_pg0 DRV_PINGROUP_ENTRY_Y(0x7044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen7_i2c_scl_pg1 DRV_PINGROUP_ENTRY_Y(0x704c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen7_i2c_sda_pg2 DRV_PINGROUP_ENTRY_Y(0x7054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen9_i2c_scl_pg3 DRV_PINGROUP_ENTRY_Y(0x705c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen9_i2c_sda_pg4 DRV_PINGROUP_ENTRY_Y(0x7064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio270_py0 DRV_PINGROUP_ENTRY_Y(0xa004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio271_py1 DRV_PINGROUP_ENTRY_Y(0xa00c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio272_py2 DRV_PINGROUP_ENTRY_Y(0xa014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio273_py3 DRV_PINGROUP_ENTRY_Y(0xa01c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio274_py4 DRV_PINGROUP_ENTRY_Y(0xa024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio275_py5 DRV_PINGROUP_ENTRY_Y(0xa02c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio276_py6 DRV_PINGROUP_ENTRY_Y(0xa034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio277_py7 DRV_PINGROUP_ENTRY_Y(0xa03c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio278_pz0 DRV_PINGROUP_ENTRY_Y(0xa044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio279_pz1 DRV_PINGROUP_ENTRY_Y(0xa04c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio282_pz4 DRV_PINGROUP_ENTRY_Y(0xa054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio283_pz5 DRV_PINGROUP_ENTRY_Y(0xa05c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio284_pz6 DRV_PINGROUP_ENTRY_Y(0xa064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio285_pz7 DRV_PINGROUP_ENTRY_Y(0xa06c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio286_pal0 DRV_PINGROUP_ENTRY_Y(0xa074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio287_pal1 DRV_PINGROUP_ENTRY_Y(0xa07c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio288_pal2 DRV_PINGROUP_ENTRY_Y(0xa084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_xhalt_trig_pz2 DRV_PINGROUP_ENTRY_Y(0xa08c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio281_pz3 DRV_PINGROUP_ENTRY_Y(0xa094, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+
+#define drive_ao_retention_n_paa2 DRV_PINGROUP_ENTRY_Y(0x2c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_batt_oc_paa3 DRV_PINGROUP_ENTRY_Y(0x34, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_power_on_paa5 DRV_PINGROUP_ENTRY_Y(0x3c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_vcomp_alert_paa1 DRV_PINGROUP_ENTRY_Y(0x44, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_bootv_ctl_n_paa4 DRV_PINGROUP_ENTRY_Y(0x4c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio00_paa0 DRV_PINGROUP_ENTRY_Y(0x54, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio07_paa7 DRV_PINGROUP_ENTRY_Y(0x5c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio08_pbb0 DRV_PINGROUP_ENTRY_Y(0x64, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio09_pbb1 DRV_PINGROUP_ENTRY_Y(0x6c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_hdmi_cec_paa6 DRV_PINGROUP_ENTRY_Y(0x74, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen2_i2c_scl_pcc0 DRV_PINGROUP_ENTRY_Y(0x1004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen2_i2c_sda_pcc1 DRV_PINGROUP_ENTRY_Y(0x100c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen3_i2c_scl_pcc2 DRV_PINGROUP_ENTRY_Y(0x1014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen3_i2c_sda_pcc3 DRV_PINGROUP_ENTRY_Y(0x101c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gp_pwm4_pcc4 DRV_PINGROUP_ENTRY_Y(0x1024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart0_tx_pcc5 DRV_PINGROUP_ENTRY_Y(0x102c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart0_rx_pcc6 DRV_PINGROUP_ENTRY_Y(0x1034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_sck_pcc7 DRV_PINGROUP_ENTRY_Y(0x103c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_miso_pdd0 DRV_PINGROUP_ENTRY_Y(0x1044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_mosi_pdd1 DRV_PINGROUP_ENTRY_Y(0x104c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_cs0_n_pdd2 DRV_PINGROUP_ENTRY_Y(0x1054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio21_pdd3 DRV_PINGROUP_ENTRY_Y(0x105c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio22_pdd4 DRV_PINGROUP_ENTRY_Y(0x1064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio23_pdd5 DRV_PINGROUP_ENTRY_Y(0x106c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio24_pdd6 DRV_PINGROUP_ENTRY_Y(0x1074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio25_pdd7 DRV_PINGROUP_ENTRY_Y(0x107c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio26_pee0 DRV_PINGROUP_ENTRY_Y(0x1084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio27_pee1 DRV_PINGROUP_ENTRY_Y(0x108c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio28_pee2 DRV_PINGROUP_ENTRY_N(no_entry)
+#define drive_soc_gpio29_pee3 DRV_PINGROUP_ENTRY_N(no_entry)
+
+
+#define PINGROUP(pg_name, f0, f1, f2, f3, r, bank, pupd, e_io_hv, e_lpbk, e_input, e_lpdr, e_pbias_buf,	\
+			gpio_sfio_sel, schmitt_b)							\
+	{								\
+		.name = #pg_name,					\
+		.pins = pg_name##_pins,					\
+		.npins = ARRAY_SIZE(pg_name##_pins),			\
+			.funcs = {					\
+				TEGRA_MUX_##f0,				\
+				TEGRA_MUX_##f1,				\
+				TEGRA_MUX_##f2,				\
+				TEGRA_MUX_##f3,				\
+			},						\
+		PIN_PINGROUP_ENTRY_Y(r, bank, pupd, e_io_hv, e_lpbk,	\
+					e_input, e_lpdr, e_pbias_buf,	\
+					gpio_sfio_sel, schmitt_b)	\
+		drive_##pg_name,					\
+	}
+
+static const struct tegra_pingroup tegra264_uphy_groups[] = {
+	PINGROUP(eth1_mdio_pe0, ETH1_MDIO, RSVD1, RSVD2, RSVD3, 0x0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l4_clkreq_n_pd0, PE4_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l4_rst_n_pd1, PE4_RST_L, RSVD1, RSVD2, RSVD3, 0x10, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l5_clkreq_n_pd2, PE5_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x18, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l5_rst_n_pd3, PE5_RST_L, RSVD1, RSVD2, RSVD3, 0x20, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth0_mdio_pd4, ETH0_MDIO, RSVD1, RSVD2, RSVD3, 0x28, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth0_mdc_pd5, ETH0_MDC, RSVD1, RSVD2, RSVD3, 0x30, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth1_mdc_pe1, ETH1_MDC, RSVD1, RSVD2, RSVD3, 0x38, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth2_mdio_pe2, ETH2_MDIO, RSVD1, RSVD2, RSVD3, 0x40, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth2_mdc_pe3, ETH2_MDC, RSVD1, RSVD2, RSVD3, 0x48, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth3_mdio_pd6, ETH3_MDIO, RSVD1, RSVD2, RSVD3, 0x50, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth3_mdc_pd7, ETH3_MDC, RSVD1, RSVD2, RSVD3, 0x58, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l1_clkreq_n_pb0, PE1_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x2000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l1_rst_n_pb1, PE1_RST_L, RSVD1, RSVD2, RSVD3, 0x2008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_wake_n_pc2, RSVD0, RSVD1, RSVD2, RSVD3, 0x2010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l2_rst_n_pb3, PE2_RST_L, RSVD1, RSVD2, RSVD3, 0x2018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l2_clkreq_n_pb2, PE2_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x2020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l3_clkreq_n_pb4, PE3_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x2028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l3_rst_n_pb5, PE3_RST_L, RSVD1, RSVD2, RSVD3, 0x2030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(sgmii0_sma_mdio_pc0, SGMII0_SMA_MDIO, RSVD1, RSVD2, RSVD3, 0x2038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(sgmii0_sma_mdc_pc1, SGMII0_SMA_MDC, RSVD1, RSVD2, RSVD3, 0x2040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio113_pb6, USB_VBUS_EN0, RSVD1, RSVD2, RSVD3, 0x2048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio114_pb7, USB_VBUS_EN1, RSVD1, RSVD2, RSVD3, 0x2050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm1_pa0, GP_PWM1, RSVD1, RSVD2, RSVD3, 0x3000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm6_pa1, GP_PWM6, RSVD1, RSVD2, RSVD3, 0x3008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm7_pa2, GP_PWM7, RSVD1, RSVD2, RSVD3, 0x3010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm8_pa3, GP_PWM8, RSVD1, RSVD2, RSVD3, 0x3018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(ufs0_ref_clk_pa4, UFS0, RSVD1, RSVD2, RSVD3, 0x3020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(ufs0_rst_n_pa5, UFS0, RSVD1, RSVD2, RSVD3, 0x3028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+};
+
+static const struct tegra_pingroup tegra264_main_groups[] = {
+	PINGROUP(cpu_pwr_req_ph0, RSVD0, RSVD1, RSVD2, RSVD3, 0x0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gpu_pwr_req_ph1, RSVD0, RSVD1, RSVD2, RSVD3, 0x8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_cts_n_ph5, UARTK_CTS, RSVD1, RSVD2, RSVD3, 0x10, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_rts_n_ph4, UARTK_RTS, RSVD1, RSVD2, RSVD3, 0x18, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_rx_ph3, UARTK_RXD, RSVD1, RSVD2, RSVD3, 0x20, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_tx_ph2, UARTK_TXD, RSVD1, RSVD2, RSVD3, 0x28, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_cs0_pj1, SPI3_CS0, RSVD1, RSVD2, RSVD3, 0x30, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_cs3_pj2, SPI3_CS3, RSVD1, RSVD2, RSVD3, 0x38, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_miso_ph7, SPI3_DIN, RSVD1, RSVD2, RSVD3, 0x40, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_mosi_pj0, SPI3_DOUT, RSVD1, RSVD2, RSVD3, 0x48, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_sck_ph6, SPI3_SCK, RSVD1, RSVD2, RSVD3, 0x50, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_cts_n_pj6, UARTF_CTS, RSVD1, RSVD2, RSVD3, 0x58, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_rts_n_pj5, UARTF_RTS, RSVD1, RSVD2, RSVD3, 0x60, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_rx_pj4, UARTF_RXD, RSVD1, RSVD2, RSVD3, 0x68, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_tx_pj3, UARTF_TXD, RSVD1, RSVD2, RSVD3, 0x70, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_cs0_pk2, SPI1_CS0, RSVD1, RSVD2, RSVD3, 0x78, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_cs1_pk3, SPI1_CS1, RSVD1, RSVD2, RSVD3, 0x80, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_miso_pk0, SPI1_DIN, RSVD1, RSVD2, RSVD3, 0x88, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_mosi_pk1, SPI1_DOUT, RSVD1, RSVD2, RSVD3, 0x90, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_sck_pj7, SPI1_SCK, RSVD1, RSVD2, RSVD3, 0x98, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(extperiph2_clk_pk5, EXTPERIPH2_CLK, RSVD1, DMIC2_CLK, DSPK1_CLK, 0xa0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(extperiph1_clk_pk4, EXTPERIPH1_CLK, RSVD1, DMIC2_DAT, DSPK1_DAT, 0xa8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen12_i2c_scl_pk6, I2C12_CLK, RSVD1, RSVD2, RSVD3, 0xb0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen12_i2c_sda_pk7, I2C12_DAT, RSVD1, RSVD2, RSVD3, 0xb8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio124_pl0, RSVD0, SOC_THERM_OC3, RSVD2, RSVD3, 0x1000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio125_pl1, RSVD0, I2S5_SCLK, RSVD2, RSVD3, 0x1008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(fan_tach0_pl2, NV_THERM_FAN_TACH0, RSVD1, RSVD2, RSVD3, 0x1010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio127_pl3, RSVD0, RSVD1, NV_THERM_FAN_TACH1, RSVD3, 0x1018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio128_pl4, RSVD0, I2S5_SDATA_IN, RSVD2, RSVD3, 0x1020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio129_pl5, RSVD0, EXTPERIPH3_CLK, I2C15_CLK, RSVD3, 0x1028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio130_pl6, RSVD0, EXTPERIPH4_CLK, I2C15_DAT, RSVD3, 0x1030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio131_pl7, RSVD0, I2S5_SDATA_OUT, RSVD2, RSVD3, 0x1038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gp_pwm9_pm0, GP_PWM9, RSVD1, RSVD2, RSVD3, 0x1040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio133_pm1, RSVD0, I2S5_LRCK, RSVD2, RSVD3, 0x1048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_cts_n_pm5, UARTJ_CTS, RSVD1, RSVD2, RSVD3, 0x1050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_rts_n_pm4, UARTJ_RTS, RSVD1, RSVD2, RSVD3, 0x1058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_rx_pm3, UARTJ_RXD, RSVD1, RSVD2, RSVD3, 0x1060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_tx_pm2, UARTJ_TXD, RSVD1, RSVD2, RSVD3, 0x1068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(sdmmc1_clk_px0, SDMMC1_CLK, RSVD1, RSVD2, RSVD3, 0x2000, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_cmd_px1, SDMMC1_CMD, RSVD1, RSVD2, RSVD3, 0x2008, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_comp, SDMMC1_COMP, RSVD1, RSVD2, RSVD3, 0x2010, 0, N, -1, -1, -1, -1, -1, -1, -1),
+	PINGROUP(sdmmc1_dat3_px5, SDMMC1_DAT3, RSVD1, RSVD2, RSVD3, 0x2018, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_dat2_px4, SDMMC1_DAT2, RSVD1, RSVD2, RSVD3, 0x2020, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_dat1_px3, SDMMC1_DAT1, RSVD1, RSVD2, RSVD3, 0x2028, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_dat0_px2, SDMMC1_DAT0, RSVD1, RSVD2, RSVD3, 0x2030, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(qspi0_cs_n_pt1, QSPI0_CS_N, RSVD1, RSVD2, RSVD3, 0x3000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io0_pt2, QSPI0_IO0, RSVD1, RSVD2, RSVD3, 0x3008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io1_pt3, QSPI0_IO1, RSVD1, RSVD2, RSVD3, 0x3010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io2_pt4, QSPI0_IO2, RSVD1, RSVD2, RSVD3, 0x3018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io3_pt5, QSPI0_IO3, RSVD1, RSVD2, RSVD3, 0x3020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_sck_pt0, QSPI0_SCK, RSVD1, RSVD2, RSVD3, 0x3028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio192_pt6, RSVD0, RSVD1, RSVD2, RSVD3, 0x3030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio138_pp0, RSVD0, I2C14_CLK, DMIC1_DAT, RSVD3, 0x5000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio139_pp1, RSVD0, I2C14_DAT, DMIC1_CLK, RSVD3, 0x5008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_din_pp4, I2S6_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x5010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_dout_pp3, I2S6_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x5018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_fs_pp5, I2S6_LRCK, RSVD1, RSVD2, RSVD3, 0x5020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_sclk_pp2, I2S6_SCLK, RSVD1, RSVD2, RSVD3, 0x5028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_dout_pp7, I2S4_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x5030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_sclk_pp6, I2S4_SCLK, RSVD1, RSVD2, RSVD3, 0x5038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_din_pq0, I2S4_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x5040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_fs_pq1, I2S4_LRCK, RSVD1, RSVD2, RSVD3, 0x5048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_cs0_pq5, SPI5_CS0, RSVD1, RSVD2, RSVD3, 0x5050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_miso_pq3, SPI5_DIN, RSVD1, RSVD2, RSVD3, 0x5058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_mosi_pq4, SPI5_DOUT, RSVD1, RSVD2, RSVD3, 0x5060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_sck_pq2, SPI5_SCK, RSVD1, RSVD2, RSVD3, 0x5068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio152_pq6, RSVD0, I2S8_SCLK, RSVD2, RSVD3, 0x5070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio153_pq7, RSVD0, I2S8_SDATA_OUT, RSVD2, RSVD3, 0x5078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio155_pr1, RSVD0, I2S8_LRCK, RSVD2, RSVD3, 0x5080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(aud_mclk_pr0, AUD_MCLK, RSVD1, RSVD2, RSVD3, 0x5088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_sclk_pr2, I2S1_SCLK, RSVD1, RSVD2, RSVD3, 0x5090, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_in_pr4, I2S1_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x5098, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_out_pr3, I2S1_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x50a0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_fs_pr5, I2S1_LRCK, RSVD1, RSVD2, RSVD3, 0x50a8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen11_i2c_scl_pr6, I2C11_CLK, RSVD1, RSVD2, RSVD3, 0x50b0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen11_i2c_sda_pr7, I2C11_DAT, RSVD1, RSVD2, RSVD3, 0x50b8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio350_ps0, RSVD0, I2S8_SDATA_IN, RSVD2, RSVD3, 0x50c0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio351_ps1, RSVD0, RSVD1, RSVD2, RSVD3, 0x50c8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen0_i2c_scl_pw4, I2C0_CLK, RSVD1, RSVD2, RSVD3, 0x6000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen0_i2c_sda_pw5, I2C0_DAT, RSVD1, RSVD2, RSVD3, 0x6008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen1_i2c_scl_pw2, I2C1_CLK, RSVD1, RSVD2, RSVD3, 0x6010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen1_i2c_sda_pw3, I2C1_DAT, RSVD1, RSVD2, RSVD3, 0x6018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_fs_pw1, I2S2_LRCK, RSVD1, RSVD2, RSVD3, 0x6040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_clk_pv6, I2S2_SCLK, RSVD1, RSVD2, RSVD3, 0x6048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_din_pw0, I2S2_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x6050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_dout_pv7, I2S2_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x6058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm10_pv1, GP_PWM10, SDMMC1_CD, I2S7_LRCK, RSVD3, 0x6060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio170_pu0, RSVD0, I2S7_SDATA_IN, CCLA_LA_TRIGGER_MUX, RSVD3, 0x6068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio171_pu1, RSVD0, SPI4_SCK, RSVD2, RSVD3, 0x6070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio172_pu2, RSVD0, SPI4_DIN, RSVD2, RSVD3, 0x6078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio173_pu3, RSVD0, SPI4_DOUT, RSVD2, RSVD3, 0x6080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio174_pu4, RSVD0, SPI4_CS0, RSVD2, RSVD3, 0x6088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio175_pu5, RSVD0, SPI4_CS1, RSVD2, RSVD3, 0x6090, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio176_pu6, RSVD0, RSVD1, I2S7_SCLK, RSVD3, 0x6098, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio177_pu7, RSVD0, GP_PWM5, RSVD2, RSVD3, 0x60a0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio178_pv0, RSVD0, RSVD1, I2S7_SDATA_OUT, RSVD3, 0x60a8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_cts_n_pv5, UARTE_CTS, RSVD1, RSVD2, RSVD3, 0x60b0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_rts_n_pv4, UARTE_RTS, RSVD1, RSVD2, RSVD3, 0x60b8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_rx_pv3, UARTE_RXD, RSVD1, RSVD2, RSVD3, 0x60c0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_tx_pv2, UARTE_TXD, RSVD1, RSVD2, RSVD3, 0x60c8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwr_i2c_sda_pw7, I2C5_DAT, RSVD1, RSVD2, RSVD3, 0x60d0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwr_i2c_scl_pw6, I2C5_CLK, RSVD1, RSVD2, RSVD3, 0x60d8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio250_pf0, DCA_VSYNC, DCB_VSYNC, DCC_VSYNC, DCD_VSYNC, 0x7000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio251_pf1, DCA_HSYNC, DCB_HSYNC, DCC_HSYNC, DCD_HSYNC, 0x7008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio252_pf2, RSVD0, DSA_LSPII, RSVD2, RSVD3, 0x7010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch0_hpd_pf3, DP_AUX_CH0_HPD, DCE_VSYNC, DCF_VSYNC, DCG_VSYNC, 0x7018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch1_hpd_pf4, DP_AUX_CH1_HPD, DCE_HSYNC, DCF_HSYNC, DCG_HSYNC, 0x7020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch2_hpd_pf5, DP_AUX_CH2_HPD, DCH_VSYNC, RSVD2, RSVD3, 0x7028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch3_hpd_pf6, DP_AUX_CH3_HPD, DCH_HSYNC, RSVD2, RSVD3, 0x7030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm2_pf7, GP_PWM2, BL_EN, RSVD2, RSVD3, 0x7038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm3_pg0, GP_PWM3, BL_PWM_DIM0, RSVD2, RSVD3, 0x7040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen7_i2c_scl_pg1, I2C7_CLK, RSVD1, SOUNDWIRE1_CLK, RSVD3, 0x7048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen7_i2c_sda_pg2, I2C7_DAT, RSVD1, SOUNDWIRE1_DAT0, RSVD3, 0x7050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen9_i2c_scl_pg3, I2C9_CLK, RSVD1, SOUNDWIRE1_DAT1, RSVD3, 0x7058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen9_i2c_sda_pg4, I2C9_DAT, RSVD1, SOUNDWIRE1_DAT2, RSVD3, 0x7060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio270_py0, RSVD0, I2C16_CLK, RSVD2, RSVD3, 0xa000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio271_py1, RSVD0, I2C16_DAT, RSVD2, RSVD3, 0xa008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio272_py2, RSVD0, I2S3_SCLK, RSVD2, RSVD3, 0xa010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio273_py3, RSVD0, I2S3_SDATA_OUT, RSVD2, RSVD3, 0xa018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio274_py4, RSVD0, I2S3_SDATA_IN, RSVD2, RSVD3, 0xa020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio275_py5, RSVD0, I2S3_LRCK, RSVD2, RSVD3, 0xa028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio276_py6, RSVD0, RSVD1, RSVD2, RSVD3, 0xa030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio277_py7, RSVD0, RSVD1, RSVD2, RSVD3, 0xa038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio278_pz0, RSVD0, RSVD1, RSVD2, RSVD3, 0xa040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio279_pz1, RSVD0, RSVD1, RSVD2, RSVD3, 0xa048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio282_pz4, RSVD0, PM_TRIG1, RSVD2, RSVD3, 0xa050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio283_pz5, RSVD0, RSVD1, RSVD2, RSVD3, 0xa058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio284_pz6, RSVD0, RSVD1, RSVD2, RSVD3, 0xa060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio285_pz7, RSVD0, RSVD1, RSVD2, RSVD3, 0xa068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio286_pal0, RSVD0, RSVD1, RSVD2, RSVD3, 0xa070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio287_pal1, RSVD0, RSVD1, RSVD2, RSVD3, 0xa078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio288_pal2, RSVD0, RSVD1, RSVD2, RSVD3, 0xa080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(xhalt_trig_pz2, XHALT_TRIG, RSVD1, RSVD2, RSVD3, 0xa088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio281_pz3, RSVD0, PM_TRIG0, RSVD2, RSVD3, 0xa090, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+};
+
+static const struct tegra_pingroup tegra264_aon_groups[] = {
+	PINGROUP(ao_retention_n_paa2, RSVD0, RSVD1, RSVD2, ISTCTRL_IST_DONE_N, 0x28, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(batt_oc_paa3, SOC_THERM_OC2, RSVD1, RSVD2, RSVD3, 0x30, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(power_on_paa5, RSVD0, RSVD1, RSVD2, RSVD3, 0x38, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(vcomp_alert_paa1, SOC_THERM_OC1, RSVD1, RSVD2, RSVD3, 0x40, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(bootv_ctl_n_paa4, RSVD0, RSVD1, RSVD2, RSVD3, 0x48, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio00_paa0, RSVD0, RSVD1, RSVD2, RSVD3, 0x50, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio07_paa7, RSVD0, RSVD1, RSVD2, RSVD3, 0x58, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio08_pbb0, RSVD0, RSVD1, RSVD2, RSVD3, 0x60, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio09_pbb1, RSVD0, RSVD1, RSVD2, RSVD3, 0x68, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(hdmi_cec_paa6, HDMI_CEC, RSVD1, RSVD2, RSVD3, 0x70, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen2_i2c_scl_pcc0, I2C2_CLK, RSVD1, RSVD2, RSVD3, 0x1000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen2_i2c_sda_pcc1, I2C2_DAT, RSVD1, RSVD2, RSVD3, 0x1008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen3_i2c_scl_pcc2, I2C3_CLK, RSVD1, RSVD2, RSVD3, 0x1010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen3_i2c_sda_pcc3, I2C3_DAT, RSVD1, RSVD2, RSVD3, 0x1018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gp_pwm4_pcc4, GP_PWM4, TOUCH_CLK, RSVD2, RSVD3, 0x1020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart0_tx_pcc5, UARTA_TXD, RSVD1, UARTL_TXD, RSVD3, 0x1028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart0_rx_pcc6, UARTA_RXD, RSVD1, UARTL_RXD, RSVD3, 0x1030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_sck_pcc7, SPI2_SCK, RSVD1, I2S9_SCLK, SOUNDWIRE0_CLK, 0x1038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_miso_pdd0, SPI2_DIN, RSVD1, I2S9_SDATA_OUT, SOUNDWIRE0_DAT0, 0x1040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_mosi_pdd1, SPI2_DOUT, RSVD1, I2S9_SDATA_IN, RSVD3, 0x1048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_cs0_n_pdd2, SPI2_CS0, RSVD1, I2S9_LRCK, RSVD3, 0x1050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio21_pdd3, RSVD0, TSC_SYNC1, DMIC5_DAT, RSVD3, 0x1058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio22_pdd4, RSVD0, RSVD1, DMIC5_CLK, RSVD3, 0x1060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio23_pdd5, RSVD0, RSVD1, TSC_EDGE_OUT2, TSC_EDGE_OUT0C, 0x1068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio24_pdd6, RSVD0, TSC_EDGE_OUT3, RSVD2, TSC_EDGE_OUT0D, 0x1070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio25_pdd7, RSVD0, TSC_EDGE_OUT0, RSVD2, TSC_EDGE_OUT0A, 0x1078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio26_pee0, RSVD0, TSC_EDGE_OUT1, RSVD2, TSC_EDGE_OUT0B, 0x1080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio27_pee1, RSVD0, TSC_SYNC0, RSVD2, RSVD3, 0x1088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio28_pee2, L0L1_RST_OUT_N, RSVD1, RSVD2, RSVD3, 0x1090, 0, N, -1, -1, -1, -1, -1, 10, -1),
+	PINGROUP(soc_gpio29_pee3, L2_RST_OUT_N, RSVD1, RSVD2, RSVD3, 0x1098, 0, N, -1, -1, -1, -1, -1, 10, -1),
+};
+
+static const struct tegra_pinctrl_soc_data tegra264_uphy_pinctrl = {
+	.pins = tegra264_uphy_pins,
+	.npins = ARRAY_SIZE(tegra264_uphy_pins),
+	.functions = tegra264_functions,
+	.nfunctions = ARRAY_SIZE(tegra264_functions),
+	.groups = tegra264_uphy_groups,
+	.ngroups = ARRAY_SIZE(tegra264_uphy_groups),
+	.hsm_in_mux = false,
+	.schmitt_in_mux = true,
+	.drvtype_in_mux = true,
+	.sfsel_in_mux = true,
+};
+
+static const struct tegra_pinctrl_soc_data tegra264_main_pinctrl = {
+	.pins = tegra264_main_pins,
+	.npins = ARRAY_SIZE(tegra264_main_pins),
+	.functions = tegra264_functions,
+	.nfunctions = ARRAY_SIZE(tegra264_functions),
+	.groups = tegra264_main_groups,
+	.ngroups = ARRAY_SIZE(tegra264_main_groups),
+	.hsm_in_mux = false,
+	.schmitt_in_mux = true,
+	.drvtype_in_mux = true,
+	.sfsel_in_mux = true,
+};
+
+static const struct tegra_pinctrl_soc_data tegra264_aon_pinctrl = {
+	.pins = tegra264_aon_pins,
+	.npins = ARRAY_SIZE(tegra264_aon_pins),
+	.functions = tegra264_functions,
+	.nfunctions = ARRAY_SIZE(tegra264_functions),
+	.groups = tegra264_aon_groups,
+	.ngroups = ARRAY_SIZE(tegra264_aon_groups),
+	.hsm_in_mux = false,
+	.schmitt_in_mux = true,
+	.drvtype_in_mux = true,
+	.sfsel_in_mux = true,
+};
+
+static int tegra264_pinctrl_probe(struct platform_device *pdev)
+{
+	const struct tegra_pinctrl_soc_data *soc = device_get_match_data(&pdev->dev);
+
+	return tegra_pinctrl_probe(pdev, soc);
+}
+
+static const struct of_device_id tegra264_pinctrl_of_match[] = {
+	{ .compatible = "nvidia,tegra264-pinmux-uphy", .data = &tegra264_uphy_pinctrl},
+	{ .compatible = "nvidia,tegra264-pinmux-main", .data = &tegra264_main_pinctrl},
+	{ .compatible = "nvidia,tegra264-pinmux-aon", .data = &tegra264_aon_pinctrl},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tegra264_pinctrl_of_match);
+
+static struct platform_driver tegra264_pinctrl_driver = {
+	.driver = {
+		.name = "tegra264-pinctrl",
+		.of_match_table = tegra264_pinctrl_of_match,
+	},
+	.probe = tegra264_pinctrl_probe,
+};
+
+static int __init tegra264_pinctrl_init(void)
+{
+		return platform_driver_register(&tegra264_pinctrl_driver);
+}
+arch_initcall(tegra264_pinctrl_init);
-- 
2.52.0


From 33f9066881324718e8183a07ef45d37e64ee5796 Mon Sep 17 00:00:00 2001
From: Laxman Dewangan <ldewangan@nvidia.com>
Date: Sat, 24 Aug 2024 10:27:30 +0000
Subject: [PATCH 05/26] NVIDIA: SAUCE: pinctrl: Remove duplication of
 PINCTRL_TEGRA264 definition

Remove the duplication of conifg definition in the Kconfigs.

Add the PINCTRL_TEGRA264 in one place and select when
CONFIG_ARCH_TEGRA_264_SOC is enabled in defconfig.

Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/pinctrl/Kconfig   | 7 -------
 drivers/soc/tegra/Kconfig | 1 +
 2 files changed, 1 insertion(+), 7 deletions(-)

diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 8ecc568feb2c..9aae4f5b6562 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -31,13 +31,6 @@ config DEBUG_PINCTRL
 	help
 	  Say Y here to add some extra checks and diagnostics to PINCTRL calls.
 
-config PINCTRL_TEGRA264
-	bool "NVIDIA Tegra264 Pinmux support"
-	select PINCTRL_TEGRA
-	default y
-	help
-	Support for the NVIDIA Tegra264 PINCTRL controller driver.
-
 config PINCTRL_AMD
 	bool "AMD GPIO pin control"
 	depends on HAS_IOMEM
diff --git a/drivers/soc/tegra/Kconfig b/drivers/soc/tegra/Kconfig
index 9392c2c43cc8..b838a8561c5e 100644
--- a/drivers/soc/tegra/Kconfig
+++ b/drivers/soc/tegra/Kconfig
@@ -133,6 +133,7 @@ config ARCH_TEGRA_264_SOC
 	bool "NVIDIA Tegra264 SoC"
 	depends on !CPU_BIG_ENDIAN
 	select MAILBOX
+	select PINCTRL_TEGRA264
 	select SOC_TEGRA_PMC
 	help
 	  Enable support for the NVIDIA Tegra264 SoC.
-- 
2.52.0


From 7dd7a26dc0d23bb702ba71792f94521cbc2ebc5e Mon Sep 17 00:00:00 2001
From: Gautham Srinivasan <gauthams@nvidia.com>
Date: Wed, 17 Jul 2024 10:22:32 +0000
Subject: [PATCH 06/26] NVIDIA: SAUCE: gpio-tegra: enable GTE for T264

Set has_gte flag to enable GTE for T264 AON pins.

Signed-off-by: Gautham Srinivasan <gauthams@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/gpio/gpio-tegra186.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/gpio/gpio-tegra186.c b/drivers/gpio/gpio-tegra186.c
index 76eaf4f44a29..fe63bc9a5be2 100644
--- a/drivers/gpio/gpio-tegra186.c
+++ b/drivers/gpio/gpio-tegra186.c
@@ -1361,6 +1361,7 @@ static const struct tegra_gpio_soc tegra264_aon_soc = {
 	.instance = 1,
 	.num_irqs_per_bank = 8,
 	.has_vm_support = true,
+	.has_gte = true,
 };
 
 static const struct of_device_id tegra186_gpio_of_match[] = {
-- 
2.52.0


From 815e524df13f8e90c7f7b1fa8bba87108d857be8 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Thu, 20 Jun 2024 06:11:39 +0000
Subject: [PATCH 07/26] NVIDIA: SAUCE: phy: xusb: skip USB2 PAD tracking and
 fuse

The USB2 PAD tracking clock is not necessary a dedicated clock.
And fuse settings is not ready for everyone in this stage.

http://nvbugs/4703456

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/phy/tegra/xusb-tegra186.c | 17 +++++++++++++----
 drivers/phy/tegra/xusb.h          |  1 +
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/drivers/phy/tegra/xusb-tegra186.c b/drivers/phy/tegra/xusb-tegra186.c
index b6dee225bc15..1a2fc809ebd5 100644
--- a/drivers/phy/tegra/xusb-tegra186.c
+++ b/drivers/phy/tegra/xusb-tegra186.c
@@ -905,6 +905,11 @@ static int tegra186_utmi_phy_power_on(struct phy *phy)
 	value = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));
 	value &= ~USB2_OTG_PD_ZI;
 	value |= TERM_SEL;
+
+	if (padctl->soc->ignore_fuse) {
+                padctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));
+                goto ignore_fuse;
+	}
 	value &= ~HS_CURR_LEVEL(~0);
 
 	if (usb2->hs_curr_level_offset) {
@@ -932,6 +937,7 @@ static int tegra186_utmi_phy_power_on(struct phy *phy)
 	value |= RPD_CTRL(priv->calib.rpd_ctrl);
 	padctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));
 
+ignore_fuse:
 	tegra186_utmi_pad_power_on(phy);
 
 	return 0;
@@ -1042,7 +1048,7 @@ tegra186_usb2_pad_probe(struct tegra_xusb_padctl *padctl,
 		goto out;
 	}
 
-	priv->usb2_trk_clk = devm_clk_get(&pad->dev, "trk");
+	priv->usb2_trk_clk = devm_clk_get_optional(&pad->dev, "trk");
 	if (IS_ERR(priv->usb2_trk_clk)) {
 		err = PTR_ERR(priv->usb2_trk_clk);
 		dev_dbg(&pad->dev, "failed to get usb2 trk clock: %d\n", err);
@@ -1524,9 +1530,11 @@ tegra186_xusb_padctl_probe(struct device *dev,
 	if (IS_ERR(priv->ao_regs))
 		return ERR_CAST(priv->ao_regs);
 
-	err = tegra186_xusb_read_fuse_calibration(priv);
-	if (err < 0)
-		return ERR_PTR(err);
+	if (!soc->ignore_fuse) {
+		err = tegra186_xusb_read_fuse_calibration(priv);
+		if (err < 0)
+			return ERR_PTR(err);
+	}
 
 	return &priv->base;
 }
@@ -1753,6 +1761,7 @@ const struct tegra_xusb_padctl_soc tegra264_xusb_padctl_soc = {
 	.poll_trk_completed = true,
 	.trk_hw_mode = true,
 	.supports_lp_cfg_en = true,
+	.ignore_fuse = true,
 };
 EXPORT_SYMBOL_GPL(tegra264_xusb_padctl_soc);
 #endif
diff --git a/drivers/phy/tegra/xusb.h b/drivers/phy/tegra/xusb.h
index b3302e9c7896..b6266b3ee1c9 100644
--- a/drivers/phy/tegra/xusb.h
+++ b/drivers/phy/tegra/xusb.h
@@ -436,6 +436,7 @@ struct tegra_xusb_padctl_soc {
 	bool trk_hw_mode;
 	bool trk_update_on_idle;
 	bool supports_lp_cfg_en;
+	bool ignore_fuse;
 };
 
 struct tegra_xusb_padctl {
-- 
2.52.0


From 95a236a779e7e134ff723260c3019e89044ca451 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Tue, 18 Jun 2024 06:59:42 +0000
Subject: [PATCH 08/26] NVIDIA: SAUCE: usb: xhci: skip mbox configuration

This change skips the mbox configuration for the
project that doesn't need this.

http://nvbugs/4703456

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/usb/host/xhci-tegra.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/drivers/usb/host/xhci-tegra.c b/drivers/usb/host/xhci-tegra.c
index 718e2ae6cd21..2839f22c7f01 100644
--- a/drivers/usb/host/xhci-tegra.c
+++ b/drivers/usb/host/xhci-tegra.c
@@ -243,6 +243,7 @@ struct tegra_xusb_soc {
 	bool scale_ss_clock;
 	bool has_ipfs;
 	bool lpm_support;
+	bool skip_mbox_config;
 	bool otg_reset_sspi;
 
 	bool has_bar2;
@@ -1247,6 +1248,9 @@ static int __tegra_xusb_enable_firmware_messages(struct tegra_xusb *tegra)
 	struct tegra_xusb_mbox_msg msg;
 	int err;
 
+	if (tegra->soc->skip_mbox_config)
+		return 0;
+
 	/* Enable firmware messages from controller. */
 	msg.cmd = MBOX_CMD_MSG_ENABLED;
 	msg.data = 0;
@@ -2677,6 +2681,7 @@ static const struct tegra_xusb_soc tegra264_soc = {
 		.owner = XUSB_BAR2_ARU_MBOX_OWNER,
 		.smi_intr = XUSB_BAR2_ARU_SMI_INTR,
 	},
+	.skip_mbox_config = true,
 	.lpm_support = true,
 	.has_bar2 = true,
 };
-- 
2.52.0


From 33b0e2044b3dee86e437adfc2dc3fcbde9e70605 Mon Sep 17 00:00:00 2001
From: Wayne Chang <waynec@nvidia.com>
Date: Tue, 13 Aug 2024 02:40:11 +0000
Subject: [PATCH 09/26] NVIDIA: SAUCE: phy: tegra: Increase timeout for
 USB2_TRK_COMPLETED polling

BugLink: https://bugs.launchpad.net/bugs/2080908

The timeout for polling on USB2_TRK_COMPLETED in the UTMI bias pad
power-on sequence has been increased from 100 to 200 cycles.

This change is necessary due to the increased number of cycles required
to settle all biases in the new circuits. Additionally, the clock speed
of the tracking circuit has been reduced to 1 MHz, further contributing
to the need for a longer timeout.

http://nvbugs/4796326

Signed-off-by: Wayne Chang <waynec@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/phy/tegra/xusb-tegra186.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/phy/tegra/xusb-tegra186.c b/drivers/phy/tegra/xusb-tegra186.c
index 1a2fc809ebd5..a24e3db8d5b5 100644
--- a/drivers/phy/tegra/xusb-tegra186.c
+++ b/drivers/phy/tegra/xusb-tegra186.c
@@ -633,7 +633,7 @@ static void tegra186_utmi_bias_pad_power_on(struct tegra_xusb_padctl *padctl)
 
 	if (padctl->soc->poll_trk_completed) {
 		err = padctl_readl_poll(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1,
-					USB2_TRK_COMPLETED, USB2_TRK_COMPLETED, 100);
+					USB2_TRK_COMPLETED, USB2_TRK_COMPLETED, 200);
 		if (err) {
 			/* The failure with polling on trk complete will not
 			 * cause the failure of powering on the bias pad.
-- 
2.52.0


From 9c8042239d58f39468a94cc5810c03089bff55f9 Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 4 Nov 2022 15:47:29 +0530
Subject: [PATCH 10/26] NVIDIA: SAUCE: dmaengine: tegra: Get slave channel
 based on DT

BugLink: https://bugs.launchpad.net/bugs/2072591

Add option for DMA clients to provide channel number and
stream-id in device tree. dma-cells need to be increased to 3
for accommodating additional details.

This is required in a virtualized environment where all channels
and clients are not allowed use the same stream id.

The channel number read from device tree is modified to match with
the hardware channel number in the driver. This is done to avoid
ABI breakage. Otherwise, it would require updating all the device
trees that provide this information

http://nvbugs/200761027

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Reviewed-by: Bitan Biswas <bbiswas@nvidia.com>
Reviewed-by: Abhilash G <abhilashg@nvidia.com>
Tested-by: Abhilash G <abhilashg@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 78 ++++++++++++++++++++++++++--------
 1 file changed, 61 insertions(+), 17 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index 4d6fe0efa76e..b1e02848d968 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -1288,10 +1288,54 @@ static void tegra_dma_free_chan_resources(struct dma_chan *dc)
 	vchan_free_chan_resources(&tdc->vc);
 }
 
-static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
-					   struct of_dma *ofdma)
+static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
+{
+	unsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+
+	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);
+	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
+
+	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);
+	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);
+
+	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);
+	return 0;
+}
+
+static struct dma_chan *tegra_dma_get_slave_channel(struct tegra_dma *tdma,
+					    struct of_phandle_args *dma_spec)
+{
+	struct tegra_dma_channel *tdc;
+	struct dma_chan *chan;
+	unsigned int chan_id;
+
+
+	chan_id = dma_spec->args[1];
+	if (chan_id > hweight_long(tdma->chan_mask))
+		return NULL;
+
+	/* Adjust the chan_id as channel id from
+	 * DT is starting from an offset
+	 */
+	chan_id += (ffs(tdma->chan_mask) - 1);
+
+	chan = dma_get_slave_channel(&tdma->channels[chan_id].vc.chan);
+	if (!chan)
+		return NULL;
+
+	tdc = to_tegra_dma_chan(chan);
+	tdc->slave_id = dma_spec->args[0];
+	tdc->stream_id = dma_spec->args[2];
+
+	/* Re-program stream-id for this channel */
+	tegra_dma_program_sid(tdc, tdc->stream_id);
+
+	return chan;
+}
+
+static struct dma_chan *tegra_dma_get_any_slave_channel(struct tegra_dma *tdma,
+					    struct of_phandle_args *dma_spec)
 {
-	struct tegra_dma *tdma = ofdma->of_dma_data;
 	struct tegra_dma_channel *tdc;
 	struct dma_chan *chan;
 
@@ -1305,6 +1349,20 @@ static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
 	return chan;
 }
 
+static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
+					   struct of_dma *ofdma)
+{
+	struct tegra_dma *tdma = ofdma->of_dma_data;
+
+	/* Check if channel no and stream-id are specified in devicetree.
+	 * Get any channel and program default stream-id otherwise
+	 */
+	if (dma_spec->args_count == 3)
+		return tegra_dma_get_slave_channel(tdma, dma_spec);
+
+	return tegra_dma_get_any_slave_channel(tdma, dma_spec);
+}
+
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
 	.channel_reg_size = SZ_64K,
@@ -1344,20 +1402,6 @@ static const struct of_device_id tegra_dma_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, tegra_dma_of_match);
 
-static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
-{
-	unsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
-
-	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);
-	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
-
-	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);
-	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);
-
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);
-	return 0;
-}
-
 static int tegra_dma_probe(struct platform_device *pdev)
 {
 	const struct tegra_dma_chip_data *cdata = NULL;
-- 
2.52.0


From a51decb334c7bac27df9b0d7f2bc271691667897 Mon Sep 17 00:00:00 2001
From: Manish Bhardwaj <mbhardwaj@nvidia.com>
Date: Sat, 15 Jun 2024 19:58:46 +0000
Subject: [PATCH 11/26] NVIDIA: SAUCE: gpcdma: fix crash in gpcdma driver

BugLink: https://bugs.launchpad.net/bugs/2080908

since we are using the dedicated channel for IPs
using gpcdma channel, check wether that channel
is enabled or not before assigning it.

https://jirasw.nvidia.com/browse/ESLC-7980

Signed-off-by: Manish Bhardwaj <mbhardwaj@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index b1e02848d968..b63dd0322050 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -1311,13 +1311,9 @@ static struct dma_chan *tegra_dma_get_slave_channel(struct tegra_dma *tdma,
 
 
 	chan_id = dma_spec->args[1];
-	if (chan_id > hweight_long(tdma->chan_mask))
+	if (!(tdma->chan_mask & (1 << (chan_id)))) {
 		return NULL;
-
-	/* Adjust the chan_id as channel id from
-	 * DT is starting from an offset
-	 */
-	chan_id += (ffs(tdma->chan_mask) - 1);
+	}
 
 	chan = dma_get_slave_channel(&tdma->channels[chan_id].vc.chan);
 	if (!chan)
-- 
2.52.0


From 88296402bb91201ea3eafae693e05ff604177d16 Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 28 Jul 2023 21:11:58 +0530
Subject: [PATCH 12/26] NVIDIA: SAUCE: dmaengine: tegra: Use struct for
 register offsets

Move all DMA channel registers to a struct and update all register reads
accordingly. This is done to accomodate Tegra264 GPCDMA where the
register offsets are different from what we have currently in the
driver.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
[nwager: Enum renaming due to new upstream noble commit:
dea982a7df4b ("dmaengine: tegra: Return correct DMA status when paused")]
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 282 +++++++++++++++++----------------
 1 file changed, 148 insertions(+), 134 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index b63dd0322050..9b5bca55b9dc 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -22,7 +22,6 @@
 #include "virt-dma.h"
 
 /* CSR register */
-#define TEGRA_GPCDMA_CHAN_CSR			0x00
 #define TEGRA_GPCDMA_CSR_ENB			BIT(31)
 #define TEGRA_GPCDMA_CSR_IE_EOC			BIT(30)
 #define TEGRA_GPCDMA_CSR_ONCE			BIT(27)
@@ -58,7 +57,6 @@
 #define TEGRA_GPCDMA_CSR_WEIGHT			GENMASK(13, 10)
 
 /* STATUS register */
-#define TEGRA_GPCDMA_CHAN_STATUS		0x004
 #define TEGRA_GPCDMA_STATUS_BUSY		BIT(31)
 #define TEGRA_GPCDMA_STATUS_ISE_EOC		BIT(30)
 #define TEGRA_GPCDMA_STATUS_PING_PONG		BIT(28)
@@ -70,22 +68,13 @@
 #define TEGRA_GPCDMA_STATUS_IRQ_STA		BIT(21)
 #define TEGRA_GPCDMA_STATUS_IRQ_TRIG_STA	BIT(20)
 
-#define TEGRA_GPCDMA_CHAN_CSRE			0x008
 #define TEGRA_GPCDMA_CHAN_CSRE_PAUSE		BIT(31)
 
-/* Source address */
-#define TEGRA_GPCDMA_CHAN_SRC_PTR		0x00C
-
-/* Destination address */
-#define TEGRA_GPCDMA_CHAN_DST_PTR		0x010
-
 /* High address pointer */
-#define TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR		0x014
 #define TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR		GENMASK(7, 0)
 #define TEGRA_GPCDMA_HIGH_ADDR_DST_PTR		GENMASK(23, 16)
 
 /* MC sequence register */
-#define TEGRA_GPCDMA_CHAN_MCSEQ			0x18
 #define TEGRA_GPCDMA_MCSEQ_DATA_SWAP		BIT(31)
 #define TEGRA_GPCDMA_MCSEQ_REQ_COUNT		GENMASK(30, 25)
 #define TEGRA_GPCDMA_MCSEQ_BURST		GENMASK(24, 23)
@@ -101,7 +90,6 @@
 #define TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK	GENMASK(6, 0)
 
 /* MMIO sequence register */
-#define TEGRA_GPCDMA_CHAN_MMIOSEQ			0x01c
 #define TEGRA_GPCDMA_MMIOSEQ_DBL_BUF		BIT(31)
 #define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH		GENMASK(30, 28)
 #define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_8	\
@@ -120,17 +108,7 @@
 #define TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD		GENMASK(18, 16)
 #define TEGRA_GPCDMA_MMIOSEQ_MMIO_PROT		GENMASK(8, 7)
 
-/* Channel WCOUNT */
-#define TEGRA_GPCDMA_CHAN_WCOUNT		0x20
-
-/* Transfer count */
-#define TEGRA_GPCDMA_CHAN_XFER_COUNT		0x24
-
-/* DMA byte count status */
-#define TEGRA_GPCDMA_CHAN_DMA_BYTE_STATUS	0x28
-
 /* Error Status Register */
-#define TEGRA_GPCDMA_CHAN_ERR_STATUS		0x30
 #define TEGRA_GPCDMA_CHAN_ERR_TYPE_SHIFT	8
 #define TEGRA_GPCDMA_CHAN_ERR_TYPE_MASK	0xF
 #define TEGRA_GPCDMA_CHAN_ERR_TYPE(err)	(			\
@@ -143,14 +121,9 @@
 #define TEGRA_DMA_MC_SLAVE_ERR			0xB
 #define TEGRA_DMA_MMIO_SLAVE_ERR		0xA
 
-/* Fixed Pattern */
-#define TEGRA_GPCDMA_CHAN_FIXED_PATTERN		0x34
-
-#define TEGRA_GPCDMA_CHAN_TZ			0x38
 #define TEGRA_GPCDMA_CHAN_TZ_MMIO_PROT_1	BIT(0)
 #define TEGRA_GPCDMA_CHAN_TZ_MC_PROT_1		BIT(1)
 
-#define TEGRA_GPCDMA_CHAN_SPARE			0x3c
 #define TEGRA_GPCDMA_CHAN_SPARE_EN_LEGACY_FC	BIT(16)
 
 /*
@@ -181,19 +154,27 @@ struct tegra_dma_chip_data {
 	unsigned int nr_channels;
 	unsigned int channel_reg_size;
 	unsigned int max_dma_count;
+	const struct tegra_dma_channel_regs *channel_regs;
 	int (*terminate)(struct tegra_dma_channel *tdc);
 };
 
 /* DMA channel registers */
 struct tegra_dma_channel_regs {
 	u32 csr;
-	u32 src_ptr;
-	u32 dst_ptr;
-	u32 high_addr_ptr;
+	u32 status;
+	u32 csre;
+	u32 src;
+	u32 dst;
+	u32 high_addr;
 	u32 mc_seq;
 	u32 mmio_seq;
 	u32 wcount;
+	u32 wxfer;
+	u32 wstatus;
+	u32 err_status;
 	u32 fixed_pattern;
+	u32 tz;
+	u32 spare;
 };
 
 /*
@@ -205,7 +186,14 @@ struct tegra_dma_channel_regs {
  */
 struct tegra_dma_sg_req {
 	unsigned int len;
-	struct tegra_dma_channel_regs ch_regs;
+	u32 csr;
+	u32 src;
+	u32 dst;
+	u32 high_addr;
+	u32 mc_seq;
+	u32 mmio_seq;
+	u32 wcount;
+	u32 fixed_pattern;
 };
 
 /*
@@ -228,33 +216,34 @@ struct tegra_dma_desc {
  * tegra_dma_channel: Channel specific information
  */
 struct tegra_dma_channel {
-	bool config_init;
-	char name[30];
-	enum dma_transfer_direction sid_dir;
-	enum dma_status status;
 	int id;
 	int irq;
 	int slave_id;
+	bool config_init;
+	char name[30];
+	unsigned int stream_id;
+	unsigned long chan_base_offset;
 	struct tegra_dma *tdma;
 	struct virt_dma_chan vc;
 	struct tegra_dma_desc *dma_desc;
 	struct dma_slave_config dma_sconfig;
-	unsigned int stream_id;
-	unsigned long chan_base_offset;
+	const struct tegra_dma_channel_regs *regs;
+	enum dma_status status;
+	enum dma_transfer_direction sid_dir;
 };
 
 /*
  * tegra_dma: Tegra DMA specific information
  */
 struct tegra_dma {
-	const struct tegra_dma_chip_data *chip_data;
+	u32 chan_mask;
 	unsigned long sid_m2d_reserved;
 	unsigned long sid_d2m_reserved;
-	u32 chan_mask;
 	void __iomem *base_addr;
 	struct device *dev;
 	struct dma_device dma_dev;
 	struct reset_control *rst;
+	const struct tegra_dma_chip_data *chip_data;
 	struct tegra_dma_channel channels[];
 };
 
@@ -288,22 +277,25 @@ static void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)
 {
 	dev_dbg(tdc2dev(tdc), "DMA Channel %d name %s register dump:\n",
 		tdc->id, tdc->name);
-	dev_dbg(tdc2dev(tdc), "CSR %x STA %x CSRE %x SRC %x DST %x\n",
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_DST_PTR)
+	dev_dbg(tdc2dev(tdc), "CSR %x STA %x CSRE %x\n",
+		tdc_read(tdc, tdc->regs->csr),
+		tdc_read(tdc, tdc->regs->status),
+		tdc_read(tdc, tdc->regs->csre)
+	);
+	dev_dbg(tdc2dev(tdc), "SRC %x DST %x HI ADDR %x\n",
+		tdc_read(tdc, tdc->regs->src),
+		tdc_read(tdc, tdc->regs->high_addr),
+		tdc_read(tdc, tdc->regs->dst)
 	);
-	dev_dbg(tdc2dev(tdc), "MCSEQ %x IOSEQ %x WCNT %x XFER %x BSTA %x\n",
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_MMIOSEQ),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_WCOUNT),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_XFER_COUNT),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_DMA_BYTE_STATUS)
+	dev_dbg(tdc2dev(tdc), "MCSEQ %x IOSEQ %x WCNT %x XFER %x WSTA %x\n",
+		tdc_read(tdc, tdc->regs->mc_seq),
+		tdc_read(tdc, tdc->regs->mmio_seq),
+		tdc_read(tdc, tdc->regs->wcount),
+		tdc_read(tdc, tdc->regs->wxfer),
+		tdc_read(tdc, tdc->regs->wstatus)
 	);
 	dev_dbg(tdc2dev(tdc), "DMA ERR_STA %x\n",
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS));
+		tdc_read(tdc, tdc->regs->err_status));
 }
 
 static int tegra_dma_sid_reserve(struct tegra_dma_channel *tdc,
@@ -377,13 +369,13 @@ static int tegra_dma_pause(struct tegra_dma_channel *tdc)
 	int ret;
 	u32 val;
 
-	val = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE);
+	val = tdc_read(tdc, tdc->regs->csre);
 	val |= TEGRA_GPCDMA_CHAN_CSRE_PAUSE;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSRE, val);
+	tdc_write(tdc, tdc->regs->csre, val);
 
 	/* Wait until busy bit is de-asserted */
 	ret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +
-			tdc->chan_base_offset + TEGRA_GPCDMA_CHAN_STATUS,
+			tdc->chan_base_offset + tdc->regs->status,
 			val,
 			!(val & TEGRA_GPCDMA_STATUS_BUSY),
 			TEGRA_GPCDMA_BURST_COMPLETE_TIME,
@@ -419,10 +411,10 @@ static void tegra_dma_resume(struct tegra_dma_channel *tdc)
 {
 	u32 val;
 
-	val = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE);
+	val = tdc_read(tdc, tdc->regs->csre);
 	val &= ~TEGRA_GPCDMA_CHAN_CSRE_PAUSE;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSRE, val);
 
+	tdc_write(tdc, tdc->regs->csre, val);
 	tdc->status = DMA_IN_PROGRESS;
 }
 
@@ -456,27 +448,27 @@ static void tegra_dma_disable(struct tegra_dma_channel *tdc)
 {
 	u32 csr, status;
 
-	csr = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR);
+	csr = tdc_read(tdc, tdc->regs->csr);
 
 	/* Disable interrupts */
 	csr &= ~TEGRA_GPCDMA_CSR_IE_EOC;
 
 	/* Disable DMA */
 	csr &= ~TEGRA_GPCDMA_CSR_ENB;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, csr);
+	tdc_write(tdc, tdc->regs->csr, csr);
 
 	/* Clear interrupt status if it is there */
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);
+	status = tdc_read(tdc, tdc->regs->status);
 	if (status & TEGRA_GPCDMA_STATUS_ISE_EOC) {
 		dev_dbg(tdc2dev(tdc), "%s():clearing interrupt\n", __func__);
-		tdc_write(tdc, TEGRA_GPCDMA_CHAN_STATUS, status);
+		tdc_write(tdc, tdc->regs->status, status);
 	}
 }
 
 static void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)
 {
 	struct tegra_dma_desc *dma_desc = tdc->dma_desc;
-	struct tegra_dma_channel_regs *ch_regs;
+	struct tegra_dma_sg_req *sg_req;
 	int ret;
 	u32 val;
 
@@ -488,29 +480,29 @@ static void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)
 
 	/* Configure next transfer immediately after DMA is busy */
 	ret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +
-			tdc->chan_base_offset + TEGRA_GPCDMA_CHAN_STATUS,
+			tdc->chan_base_offset + tdc->regs->status,
 			val,
 			(val & TEGRA_GPCDMA_STATUS_BUSY), 0,
 			TEGRA_GPCDMA_BURST_COMPLETION_TIMEOUT);
 	if (ret)
 		return;
 
-	ch_regs = &dma_desc->sg_req[dma_desc->sg_idx].ch_regs;
+	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_WCOUNT, ch_regs->wcount);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR, ch_regs->src_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_DST_PTR, ch_regs->dst_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR, ch_regs->high_addr_ptr);
+	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
+	tdc_write(tdc, tdc->regs->src, sg_req->src);
+	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
+	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
 
 	/* Start DMA */
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR,
-		  ch_regs->csr | TEGRA_GPCDMA_CSR_ENB);
+	tdc_write(tdc, tdc->regs->csr,
+		  sg_req->csr | TEGRA_GPCDMA_CSR_ENB);
 }
 
 static void tegra_dma_start(struct tegra_dma_channel *tdc)
 {
 	struct tegra_dma_desc *dma_desc = tdc->dma_desc;
-	struct tegra_dma_channel_regs *ch_regs;
+	struct tegra_dma_sg_req *sg_req;
 	struct virt_dma_desc *vdesc;
 
 	if (!dma_desc) {
@@ -526,21 +518,21 @@ static void tegra_dma_start(struct tegra_dma_channel *tdc)
 		tegra_dma_resume(tdc);
 	}
 
-	ch_regs = &dma_desc->sg_req[dma_desc->sg_idx].ch_regs;
+	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_WCOUNT, ch_regs->wcount);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, 0);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR, ch_regs->src_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_DST_PTR, ch_regs->dst_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR, ch_regs->high_addr_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_FIXED_PATTERN, ch_regs->fixed_pattern);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MMIOSEQ, ch_regs->mmio_seq);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, ch_regs->mc_seq);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, ch_regs->csr);
+	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
+	tdc_write(tdc, tdc->regs->csr, 0);
+	tdc_write(tdc, tdc->regs->src, sg_req->src);
+	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
+	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
+	tdc_write(tdc, tdc->regs->fixed_pattern, sg_req->fixed_pattern);
+	tdc_write(tdc, tdc->regs->mmio_seq, sg_req->mmio_seq);
+	tdc_write(tdc, tdc->regs->mc_seq, sg_req->mc_seq);
+	tdc_write(tdc, tdc->regs->csr, sg_req->csr);
 
 	/* Start DMA */
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR,
-		  ch_regs->csr | TEGRA_GPCDMA_CSR_ENB);
+	tdc_write(tdc, tdc->regs->csr,
+		  sg_req->csr | TEGRA_GPCDMA_CSR_ENB);
 }
 
 static void tegra_dma_xfer_complete(struct tegra_dma_channel *tdc)
@@ -601,19 +593,19 @@ static irqreturn_t tegra_dma_isr(int irq, void *dev_id)
 	u32 status;
 
 	/* Check channel error status register */
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS);
+	status = tdc_read(tdc, tdc->regs->err_status);
 	if (status) {
 		tegra_dma_chan_decode_error(tdc, status);
 		tegra_dma_dump_chan_regs(tdc);
-		tdc_write(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS, 0xFFFFFFFF);
+		tdc_write(tdc, tdc->regs->err_status, 0xFFFFFFFF);
 	}
 
 	spin_lock(&tdc->vc.lock);
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);
+	status = tdc_read(tdc, tdc->regs->status);
 	if (!(status & TEGRA_GPCDMA_STATUS_ISE_EOC))
 		goto irq_done;
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_STATUS,
+	tdc_write(tdc, tdc->regs->status,
 		  TEGRA_GPCDMA_STATUS_ISE_EOC);
 
 	if (!dma_desc)
@@ -673,10 +665,10 @@ static int tegra_dma_stop_client(struct tegra_dma_channel *tdc)
 	 * to stop DMA engine from starting any more bursts for
 	 * the given client and wait for in flight bursts to complete
 	 */
-	csr = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR);
+	csr = tdc_read(tdc, tdc->regs->csr);
 	csr &= ~(TEGRA_GPCDMA_CSR_REQ_SEL_MASK);
 	csr |= TEGRA_GPCDMA_CSR_REQ_SEL_UNUSED;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, csr);
+	tdc_write(tdc, tdc->regs->csr, csr);
 
 	/* Wait for in flight data transfer to finish */
 	udelay(TEGRA_GPCDMA_BURST_COMPLETE_TIME);
@@ -687,7 +679,7 @@ static int tegra_dma_stop_client(struct tegra_dma_channel *tdc)
 
 	ret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +
 				tdc->chan_base_offset +
-				TEGRA_GPCDMA_CHAN_STATUS,
+				tdc->regs->status,
 				status,
 				!(status & (TEGRA_GPCDMA_STATUS_CHANNEL_TX |
 				TEGRA_GPCDMA_STATUS_CHANNEL_RX)),
@@ -739,14 +731,14 @@ static int tegra_dma_get_residual(struct tegra_dma_channel *tdc)
 	unsigned int bytes_xfer, residual;
 	u32 wcount = 0, status;
 
-	wcount = tdc_read(tdc, TEGRA_GPCDMA_CHAN_XFER_COUNT);
+	wcount = tdc_read(tdc, tdc->regs->wxfer);
 
 	/*
 	 * Set wcount = 0 if EOC bit is set. The transfer would have
 	 * already completed and the CHAN_XFER_COUNT could have updated
 	 * for the next transfer, specifically in case of cyclic transfers.
 	 */
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);
+	status = tdc_read(tdc, tdc->regs->status);
 	if (status & TEGRA_GPCDMA_STATUS_ISE_EOC)
 		wcount = 0;
 
@@ -893,7 +885,7 @@ tegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,
 	/* Configure default priority weight for the channel */
 	csr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;
 
@@ -916,16 +908,16 @@ tegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].ch_regs.src_ptr = 0;
-	sg_req[0].ch_regs.dst_ptr = dest;
-	sg_req[0].ch_regs.high_addr_ptr =
+	sg_req[0].src = 0;
+	sg_req[0].dst = dest;
+	sg_req[0].high_addr =
 			FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
-	sg_req[0].ch_regs.fixed_pattern = value;
+	sg_req[0].fixed_pattern = value;
 	/* Word count reg takes value as (N +1) words */
-	sg_req[0].ch_regs.wcount = ((len - 4) >> 2);
-	sg_req[0].ch_regs.csr = csr;
-	sg_req[0].ch_regs.mmio_seq = 0;
-	sg_req[0].ch_regs.mc_seq = mc_seq;
+	sg_req[0].wcount = ((len - 4) >> 2);
+	sg_req[0].csr = csr;
+	sg_req[0].mmio_seq = 0;
+	sg_req[0].mc_seq = mc_seq;
 	sg_req[0].len = len;
 
 	dma_desc->cyclic = false;
@@ -961,7 +953,7 @@ tegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,
 	/* Configure default priority weight for the channel */
 	csr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= (TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK) |
 		  (TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
@@ -985,17 +977,17 @@ tegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].ch_regs.src_ptr = src;
-	sg_req[0].ch_regs.dst_ptr = dest;
-	sg_req[0].ch_regs.high_addr_ptr =
+	sg_req[0].src = src;
+	sg_req[0].dst = dest;
+	sg_req[0].high_addr =
 		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (src >> 32));
-	sg_req[0].ch_regs.high_addr_ptr |=
+	sg_req[0].high_addr |=
 		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
 	/* Word count reg takes value as (N +1) words */
-	sg_req[0].ch_regs.wcount = ((len - 4) >> 2);
-	sg_req[0].ch_regs.csr = csr;
-	sg_req[0].ch_regs.mmio_seq = 0;
-	sg_req[0].ch_regs.mc_seq = mc_seq;
+	sg_req[0].wcount = ((len - 4) >> 2);
+	sg_req[0].csr = csr;
+	sg_req[0].mmio_seq = 0;
+	sg_req[0].mc_seq = mc_seq;
 	sg_req[0].len = len;
 
 	dma_desc->cyclic = false;
@@ -1049,7 +1041,7 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 	if (flags & DMA_PREP_INTERRUPT)
 		csr |= TEGRA_GPCDMA_CSR_IE_EOC;
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;
 
@@ -1096,14 +1088,14 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 		dma_desc->bytes_req += len;
 
 		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].ch_regs.src_ptr = mem;
-			sg_req[i].ch_regs.dst_ptr = apb_ptr;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = mem;
+			sg_req[i].dst = apb_ptr;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
 		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].ch_regs.src_ptr = apb_ptr;
-			sg_req[i].ch_regs.dst_ptr = mem;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = apb_ptr;
+			sg_req[i].dst = mem;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
 		}
 
@@ -1111,10 +1103,10 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 		 * Word count register takes input in words. Writing a value
 		 * of N into word count register means a req of (N+1) words.
 		 */
-		sg_req[i].ch_regs.wcount = ((len - 4) >> 2);
-		sg_req[i].ch_regs.csr = csr;
-		sg_req[i].ch_regs.mmio_seq = mmio_seq;
-		sg_req[i].ch_regs.mc_seq = mc_seq;
+		sg_req[i].wcount = ((len - 4) >> 2);
+		sg_req[i].csr = csr;
+		sg_req[i].mmio_seq = mmio_seq;
+		sg_req[i].mc_seq = mc_seq;
 		sg_req[i].len = len;
 	}
 
@@ -1186,7 +1178,7 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 
 	mmio_seq |= FIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD, 1);
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;
 
@@ -1218,24 +1210,24 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 	for (i = 0; i < period_count; i++) {
 		mmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);
 		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].ch_regs.src_ptr = mem;
-			sg_req[i].ch_regs.dst_ptr = apb_ptr;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = mem;
+			sg_req[i].dst = apb_ptr;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
 		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].ch_regs.src_ptr = apb_ptr;
-			sg_req[i].ch_regs.dst_ptr = mem;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = apb_ptr;
+			sg_req[i].dst = mem;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
 		}
 		/*
 		 * Word count register takes input in words. Writing a value
 		 * of N into word count register means a req of (N+1) words.
 		 */
-		sg_req[i].ch_regs.wcount = ((len - 4) >> 2);
-		sg_req[i].ch_regs.csr = csr;
-		sg_req[i].ch_regs.mmio_seq = mmio_seq;
-		sg_req[i].ch_regs.mc_seq = mc_seq;
+		sg_req[i].wcount = ((len - 4) >> 2);
+		sg_req[i].csr = csr;
+		sg_req[i].mmio_seq = mmio_seq;
+		sg_req[i].mc_seq = mc_seq;
 		sg_req[i].len = len;
 
 		mem += len;
@@ -1290,7 +1282,7 @@ static void tegra_dma_free_chan_resources(struct dma_chan *dc)
 
 static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
 {
-	unsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	unsigned int reg_val =  tdc_read(tdc, tdc->regs->mc_seq);
 
 	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);
 	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
@@ -1298,7 +1290,7 @@ static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
 	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);
 	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);
+	tdc_write(tdc, tdc->regs->mc_seq, reg_val);
 	return 0;
 }
 
@@ -1359,11 +1351,30 @@ static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
 	return tegra_dma_get_any_slave_channel(tdma, dma_spec);
 }
 
+static const struct tegra_dma_channel_regs tegra186_reg_offsets = {
+	.csr = 0x0,
+	.status = 0x4,
+	.csre = 0x8,
+	.src = 0xc,
+	.dst = 0x10,
+	.high_addr = 0x14,
+	.mc_seq = 0x18,
+	.mmio_seq = 0x1c,
+	.wcount = 0x20,
+	.wxfer = 0x24,
+	.wstatus = 0x28,
+	.err_status = 0x30,
+	.fixed_pattern = 0x34,
+	.tz = 0x38,
+	.spare = 0x40,
+};
+
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = false,
+	.channel_regs = &tegra186_reg_offsets,
 	.terminate = tegra_dma_stop_client,
 };
 
@@ -1372,6 +1383,7 @@ static const struct tegra_dma_chip_data tegra194_dma_chip_data = {
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
+	.channel_regs = &tegra186_reg_offsets,
 	.terminate = tegra_dma_pause,
 };
 
@@ -1380,6 +1392,7 @@ static const struct tegra_dma_chip_data tegra234_dma_chip_data = {
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
+	.channel_regs = &tegra186_reg_offsets,
 	.terminate = tegra_dma_pause_noerr,
 };
 
@@ -1459,6 +1472,7 @@ static int tegra_dma_probe(struct platform_device *pdev)
 
 		tdc->chan_base_offset = TEGRA_GPCDMA_CHANNEL_BASE_ADDR_OFFSET +
 					i * cdata->channel_reg_size;
+		tdc->regs = cdata->channel_regs;
 		snprintf(tdc->name, sizeof(tdc->name), "gpcdma.%d", i);
 		tdc->tdma = tdma;
 		tdc->id = i;
-- 
2.52.0


From 35458a8fcaf7f992aa48d36cf66e1453b6acf0ba Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 28 Jul 2023 21:59:37 +0530
Subject: [PATCH 13/26] NVIDIA: SAUCE: dmaengine: tegra: Support more than 40
 bits address width

Add support for address width of more than 40 bits. Till Tegra234 in
addition to 32 bit source/destination, only 8 bits each were supported.
In Tegra264, there is a separate register for high source and high
destination addresses. It can now support 48 bits addresses as well.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 107 +++++++++++++++++++--------------
 1 file changed, 63 insertions(+), 44 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index 9b5bca55b9dc..e4634966a633 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -151,6 +151,7 @@ struct tegra_dma_channel;
  */
 struct tegra_dma_chip_data {
 	bool hw_support_pause;
+	unsigned int addr_bits;
 	unsigned int nr_channels;
 	unsigned int channel_reg_size;
 	unsigned int max_dma_count;
@@ -166,6 +167,8 @@ struct tegra_dma_channel_regs {
 	u32 src;
 	u32 dst;
 	u32 high_addr;
+	u32 src_high;
+	u32 dst_high;
 	u32 mc_seq;
 	u32 mmio_seq;
 	u32 wcount;
@@ -190,6 +193,8 @@ struct tegra_dma_sg_req {
 	u32 src;
 	u32 dst;
 	u32 high_addr;
+	u32 src_high;
+	u32 dst_high;
 	u32 mc_seq;
 	u32 mmio_seq;
 	u32 wcount;
@@ -273,6 +278,40 @@ static inline struct device *tdc2dev(struct tegra_dma_channel *tdc)
 	return tdc->vc.chan.device->dev;
 }
 
+static inline void tegra_dma_program_addr(struct tegra_dma_channel *tdc,
+					struct tegra_dma_sg_req *sg_req)
+{
+	tdc_write(tdc, tdc->regs->src, sg_req->src);
+	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
+	if (tdc->tdma->chip_data->addr_bits > 40) {
+		tdc_write(tdc, tdc->regs->src_high,
+						sg_req->src_high);
+		tdc_write(tdc, tdc->regs->dst_high,
+						sg_req->dst_high);
+	} else {
+		tdc_write(tdc, tdc->regs->high_addr,
+				sg_req->src_high | sg_req->dst_high);
+	}
+}
+
+static inline void tegra_dma_configure_addr(struct tegra_dma_channel *tdc,
+				struct tegra_dma_sg_req *sg_req,
+				phys_addr_t src, phys_addr_t dst)
+{
+	sg_req->src = lower_32_bits(src);
+	sg_req->dst = lower_32_bits(dst);
+
+	if (tdc->tdma->chip_data->addr_bits > 40) {
+		sg_req->src_high = upper_32_bits(src);
+		sg_req->dst_high = upper_32_bits(dst);
+	} else {
+		sg_req->src_high = FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR,
+					upper_32_bits(src));
+		sg_req->dst_high = FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR,
+					upper_32_bits(dst));
+	}
+}
+
 static void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)
 {
 	dev_dbg(tdc2dev(tdc), "DMA Channel %d name %s register dump:\n",
@@ -282,10 +321,11 @@ static void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)
 		tdc_read(tdc, tdc->regs->status),
 		tdc_read(tdc, tdc->regs->csre)
 	);
-	dev_dbg(tdc2dev(tdc), "SRC %x DST %x HI ADDR %x\n",
+	dev_dbg(tdc2dev(tdc), "SRC %x SRC HI %x DST %x DST HI %x\n",
 		tdc_read(tdc, tdc->regs->src),
-		tdc_read(tdc, tdc->regs->high_addr),
-		tdc_read(tdc, tdc->regs->dst)
+		tdc_read(tdc, tdc->regs->src_high),
+		tdc_read(tdc, tdc->regs->dst),
+		tdc_read(tdc, tdc->regs->dst_high)
 	);
 	dev_dbg(tdc2dev(tdc), "MCSEQ %x IOSEQ %x WCNT %x XFER %x WSTA %x\n",
 		tdc_read(tdc, tdc->regs->mc_seq),
@@ -490,9 +530,7 @@ static void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)
 	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
 	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
-	tdc_write(tdc, tdc->regs->src, sg_req->src);
-	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
-	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
+	tegra_dma_program_addr(tdc, sg_req);
 
 	/* Start DMA */
 	tdc_write(tdc, tdc->regs->csr,
@@ -520,11 +558,9 @@ static void tegra_dma_start(struct tegra_dma_channel *tdc)
 
 	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
+	tegra_dma_program_addr(tdc, sg_req);
 	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
 	tdc_write(tdc, tdc->regs->csr, 0);
-	tdc_write(tdc, tdc->regs->src, sg_req->src);
-	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
-	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
 	tdc_write(tdc, tdc->regs->fixed_pattern, sg_req->fixed_pattern);
 	tdc_write(tdc, tdc->regs->mmio_seq, sg_req->mmio_seq);
 	tdc_write(tdc, tdc->regs->mc_seq, sg_req->mc_seq);
@@ -829,7 +865,7 @@ static unsigned int get_burst_size(struct tegra_dma_channel *tdc,
 
 static int get_transfer_param(struct tegra_dma_channel *tdc,
 			      enum dma_transfer_direction direction,
-			      u32 *apb_addr,
+			      dma_addr_t *apb_addr,
 			      u32 *mmio_seq,
 			      u32 *csr,
 			      unsigned int *burst_size,
@@ -908,10 +944,7 @@ tegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].src = 0;
-	sg_req[0].dst = dest;
-	sg_req[0].high_addr =
-			FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
+	tegra_dma_configure_addr(tdc, &sg_req[0], 0, dest);
 	sg_req[0].fixed_pattern = value;
 	/* Word count reg takes value as (N +1) words */
 	sg_req[0].wcount = ((len - 4) >> 2);
@@ -977,12 +1010,7 @@ tegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].src = src;
-	sg_req[0].dst = dest;
-	sg_req[0].high_addr =
-		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (src >> 32));
-	sg_req[0].high_addr |=
-		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
+	tegra_dma_configure_addr(tdc, &sg_req[0], src, dest);
 	/* Word count reg takes value as (N +1) words */
 	sg_req[0].wcount = ((len - 4) >> 2);
 	sg_req[0].csr = csr;
@@ -1002,7 +1030,8 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 	struct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);
 	unsigned int max_dma_count = tdc->tdma->chip_data->max_dma_count;
 	enum dma_slave_buswidth slave_bw = DMA_SLAVE_BUSWIDTH_UNDEFINED;
-	u32 csr, mc_seq, apb_ptr = 0, mmio_seq = 0;
+	u32 csr, mc_seq, mmio_seq = 0;
+	dma_addr_t apb_ptr = 0;
 	struct tegra_dma_sg_req *sg_req;
 	struct tegra_dma_desc *dma_desc;
 	struct scatterlist *sg;
@@ -1087,17 +1116,10 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 		mmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);
 		dma_desc->bytes_req += len;
 
-		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].src = mem;
-			sg_req[i].dst = apb_ptr;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
-		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].src = apb_ptr;
-			sg_req[i].dst = mem;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
-		}
+		if (direction == DMA_MEM_TO_DEV)
+			tegra_dma_configure_addr(tdc, &sg_req[i], mem, apb_ptr);
+		 else if (direction == DMA_DEV_TO_MEM)
+			tegra_dma_configure_addr(tdc, &sg_req[i], apb_ptr, mem);
 
 		/*
 		 * Word count register takes input in words. Writing a value
@@ -1120,7 +1142,8 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 			  unsigned long flags)
 {
 	enum dma_slave_buswidth slave_bw = DMA_SLAVE_BUSWIDTH_UNDEFINED;
-	u32 csr, mc_seq, apb_ptr = 0, mmio_seq = 0, burst_size;
+	u32 csr, mc_seq, mmio_seq = 0, burst_size;
+	dma_addr_t apb_ptr = 0;
 	unsigned int max_dma_count, len, period_count, i;
 	struct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);
 	struct tegra_dma_desc *dma_desc;
@@ -1209,17 +1232,10 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 	/* Split transfer equal to period size */
 	for (i = 0; i < period_count; i++) {
 		mmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);
-		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].src = mem;
-			sg_req[i].dst = apb_ptr;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
-		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].src = apb_ptr;
-			sg_req[i].dst = mem;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
-		}
+		if (direction == DMA_MEM_TO_DEV)
+			tegra_dma_configure_addr(tdc, &sg_req[i], mem, apb_ptr);
+		else if (direction == DMA_DEV_TO_MEM)
+			tegra_dma_configure_addr(tdc, &sg_req[i], apb_ptr, mem);
 		/*
 		 * Word count register takes input in words. Writing a value
 		 * of N into word count register means a req of (N+1) words.
@@ -1371,6 +1387,7 @@ static const struct tegra_dma_channel_regs tegra186_reg_offsets = {
 
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
+	.addr_bits = 40,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = false,
@@ -1380,6 +1397,7 @@ static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 
 static const struct tegra_dma_chip_data tegra194_dma_chip_data = {
 	.nr_channels = 32,
+	.addr_bits = 40,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
@@ -1389,6 +1407,7 @@ static const struct tegra_dma_chip_data tegra194_dma_chip_data = {
 
 static const struct tegra_dma_chip_data tegra234_dma_chip_data = {
 	.nr_channels = 32,
+	.addr_bits = 40,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
-- 
2.52.0


From d61639e36d9ad6e879da7d757314d65c24d3ebf8 Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 28 Jul 2023 22:18:39 +0530
Subject: [PATCH 14/26] NVIDIA: SAUCE: dmaengine: tegra: Add Tegra264 support

Update compatible and chip data to support GPCDMA in Tegra264.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index e4634966a633..2edce19f8e59 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -1385,6 +1385,25 @@ static const struct tegra_dma_channel_regs tegra186_reg_offsets = {
 	.spare = 0x40,
 };
 
+static const struct tegra_dma_channel_regs tegra264_reg_offsets = {
+	.csr = 0x0,
+	.status = 0x4,
+	.csre = 0x8,
+	.src = 0xc,
+	.dst = 0x10,
+	.src_high = 0x14,
+	.dst_high = 0x18,
+	.mc_seq = 0x1c,
+	.mmio_seq = 0x20,
+	.wcount = 0x24,
+	.wxfer = 0x28,
+	.wstatus = 0x2c,
+	.err_status = 0x34,
+	.fixed_pattern = 0x38,
+	.tz = 0x3c,
+	.spare = 0x44,
+};
+
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
 	.addr_bits = 40,
@@ -1415,6 +1434,17 @@ static const struct tegra_dma_chip_data tegra234_dma_chip_data = {
 	.terminate = tegra_dma_pause_noerr,
 };
 
+
+static const struct tegra_dma_chip_data tegra264_dma_chip_data = {
+	.nr_channels = 32,
+	.addr_bits = 48,
+	.channel_reg_size = SZ_64K,
+	.max_dma_count = SZ_1G,
+	.hw_support_pause = true,
+	.channel_regs = &tegra264_reg_offsets,
+	.terminate = tegra_dma_pause_noerr,
+};
+
 static const struct of_device_id tegra_dma_of_match[] = {
 	{
 		.compatible = "nvidia,tegra186-gpcdma",
@@ -1425,6 +1455,9 @@ static const struct of_device_id tegra_dma_of_match[] = {
 	}, {
 		.compatible = "nvidia,tegra234-gpcdma",
 		.data = &tegra234_dma_chip_data,
+	}, {
+		.compatible = "nvidia,tegra264-gpcdma",
+		.data = &tegra264_dma_chip_data,
 	}, {
 	},
 };
-- 
2.52.0


From 3153b97bfd932e4be379ec2657cba53f6519b76e Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Wed, 16 Aug 2023 09:44:52 +0530
Subject: [PATCH 15/26] NVIDIA: SAUCE: dmaengine: tegra: Remove reset control

The reset is expected to be controlled from the bootloader and should
be done by the time it reaches kernel. Therefore a reset in the
driver is redundant.

Also, Linux does not have access to this reset in the upcoming chips.
To keep the drive agnostic, removing all the reset functionality from
the driver.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 13 +------------
 1 file changed, 1 insertion(+), 12 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index 2edce19f8e59..f98e19b3fe36 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -2,7 +2,7 @@
 /*
  * DMA driver for NVIDIA Tegra GPC DMA controller.
  *
- * Copyright (c) 2014-2022, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2014-2023, NVIDIA CORPORATION.  All rights reserved.
  */
 
 #include <linux/bitfield.h>
@@ -16,7 +16,6 @@
 #include <linux/of.h>
 #include <linux/of_dma.h>
 #include <linux/platform_device.h>
-#include <linux/reset.h>
 #include <linux/slab.h>
 #include <dt-bindings/memory/tegra186-mc.h>
 #include "virt-dma.h"
@@ -247,7 +246,6 @@ struct tegra_dma {
 	void __iomem *base_addr;
 	struct device *dev;
 	struct dma_device dma_dev;
-	struct reset_control *rst;
 	const struct tegra_dma_chip_data *chip_data;
 	struct tegra_dma_channel channels[];
 };
@@ -1487,13 +1485,6 @@ static int tegra_dma_probe(struct platform_device *pdev)
 	if (IS_ERR(tdma->base_addr))
 		return PTR_ERR(tdma->base_addr);
 
-	tdma->rst = devm_reset_control_get_exclusive(&pdev->dev, "gpcdma");
-	if (IS_ERR(tdma->rst)) {
-		return dev_err_probe(&pdev->dev, PTR_ERR(tdma->rst),
-			      "Missing controller reset\n");
-	}
-	reset_control_reset(tdma->rst);
-
 	tdma->dma_dev.dev = &pdev->dev;
 
 	if (!tegra_dev_iommu_get_stream_id(&pdev->dev, &stream_id)) {
@@ -1623,8 +1614,6 @@ static int __maybe_unused tegra_dma_pm_resume(struct device *dev)
 	struct tegra_dma *tdma = dev_get_drvdata(dev);
 	unsigned int i;
 
-	reset_control_reset(tdma->rst);
-
 	for (i = 0; i < tdma->chip_data->nr_channels; i++) {
 		struct tegra_dma_channel *tdc = &tdma->channels[i];
 
-- 
2.52.0


From 362698f75ac5956dd4506eced1c658600585f999 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Tue, 4 Apr 2023 12:04:31 +0000
Subject: [PATCH 16/26] NVIDIA: SAUCE: spi: add "tegra-spidev" compatible
 string.

BugLink: https://bugs.launchpad.net/bugs/2072591

Add "tegra-spidev" compatible string.

http://nvbugs/3754288

Signed-off-by: Vishwaroop A <va@nvidia.com>
Reviewed-by: Laxman Dewangan <ldewangan@nvidia.com>
Tested-by: Abhilash G <abhilashg@nvidia.com>
Reviewed-by: Abhilash G <abhilashg@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spidev.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 5300c942a2a4..8fef8c6ffeff 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -751,6 +751,8 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "semtech,sx1301", .data = &spidev_of_check },
 	{ .compatible = "silabs,em3581", .data = &spidev_of_check },
 	{ .compatible = "silabs,si3210", .data = &spidev_of_check },
+	{ .compatible = "nvidia,tegra-spidev", .data = &spidev_of_check },
+	{ .compatible = "tegra-spidev", .data = &spidev_of_check },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
-- 
2.52.0


From 995bb6db135e98c3e32010efb6d540574f3e346a Mon Sep 17 00:00:00 2001
From: Gautham Srinivasan <gauthams@nvidia.com>
Date: Wed, 24 May 2023 17:22:20 +0000
Subject: [PATCH 17/26] NVIDIA: SAUCE: spi: add "tegra-spidev" name string.

BugLink: https://bugs.launchpad.net/bugs/2072591

Add "tegra-spidev" name string to load spidev.ko driver
which allows user-space programs to access and communicate
with SPI devices connected to the system.

http://nvbugs/4130525

Signed-off-by: Gautham Srinivasan <gauthams@nvidia.com>
Reviewed-by: Prathamesh Shete <pshete@nvidia.com>
Tested-by: Prathamesh Shete <pshete@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spidev.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 8fef8c6ffeff..fe5033c24a68 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -718,6 +718,7 @@ static const struct spi_device_id spidev_spi_ids[] = {
 	{ .name = /* semtech */ "sx1301" },
 	{ .name = /* silabs */ "em3581" },
 	{ .name = /* silabs */ "si3210" },
+	{ .name = "tegra-spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
-- 
2.52.0


From 88bc55d80159c7559a29c81d3214eeb371d1a2c6 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Tue, 12 Dec 2023 11:00:52 +0000
Subject: [PATCH 18/26] NVIDIA: SAUCE: drivers: spi: fix warnings in spi
 controller.

BugLink: https://bugs.launchpad.net/bugs/2072591

Fix the below listed warnings in SPI
controller driver.

>> spi spi0.0: Invalid delay unit 2, should be
SPI_DELAY_UNIT_SCK.

http://nvbugs/4346767

Signed-off-by: Vishwaroop A <va@nvidia.com>
Tested-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spi-tegra114.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/drivers/spi/spi-tegra114.c b/drivers/spi/spi-tegra114.c
index 795a8482c2c7..3ac19d4bb216 100644
--- a/drivers/spi/spi-tegra114.c
+++ b/drivers/spi/spi-tegra114.c
@@ -728,6 +728,10 @@ static int tegra_spi_set_hw_cs_timing(struct spi_device *spi)
 	u32 inactive_cycles;
 	u8 cs_state;
 
+	setup->unit = SPI_DELAY_UNIT_SCK;
+	hold->unit = SPI_DELAY_UNIT_SCK;
+	inactive->unit = SPI_DELAY_UNIT_SCK;
+
 	if ((setup->value && setup->unit != SPI_DELAY_UNIT_SCK) ||
 	    (hold->value && hold->unit != SPI_DELAY_UNIT_SCK) ||
 	    (inactive->value && inactive->unit != SPI_DELAY_UNIT_SCK)) {
-- 
2.52.0


From 99247710b59667b1a0b08c700d94289ca8ccf838 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Wed, 13 Dec 2023 09:13:37 +0000
Subject: [PATCH 19/26] NVIDIA: SAUCE: drivers: spi: fix warnings in spi core.

BugLink: https://bugs.launchpad.net/bugs/2072591

Fix the below listed warnings in SPI core framework
by adding check for prod.

>>spi_master spi0: cannot find modalias for
/bus@0/spi@3210000/prod-settings

http://nvbugs/4346767

Signed-off-by: Vishwaroop A <va@nvidia.com>
Tested-by: Laxman Dewangan <ldewangan@nvidia.com>
Reviewed-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spi.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index eb4076c0d040..c8ff9f5f9f41 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2531,6 +2531,8 @@ static void of_register_spi_devices(struct spi_controller *ctlr)
 	for_each_available_child_of_node(ctlr->dev.of_node, nc) {
 		if (of_node_test_and_set_flag(nc, OF_POPULATED))
 			continue;
+		if (!strcmp(nc->name, "prod-settings"))
+			continue;
 		spi = of_register_spi_device(ctlr, nc);
 		if (IS_ERR(spi)) {
 			dev_warn(&ctlr->dev,
-- 
2.52.0


From d1a5dd8f2892d1b5a2ea011aa6a3a4a2a0dacdc3 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Mon, 14 Aug 2023 20:33:31 +0000
Subject: [PATCH 20/26] NVIDIA: SAUCE: spi: spi-tegra114: retain the spi mode

BugLink: https://bugs.launchpad.net/bugs/2080908

Retain the spi mode in def_command1 register
after transfer completion.

http://nvbugs/4204673

Signed-off-by: Vishwaroop A <va@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spi-tegra114.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/drivers/spi/spi-tegra114.c b/drivers/spi/spi-tegra114.c
index 3ac19d4bb216..5c4f2e832023 100644
--- a/drivers/spi/spi-tegra114.c
+++ b/drivers/spi/spi-tegra114.c
@@ -57,6 +57,7 @@
 #define SPI_CONTROL_MODE_3			(3 << 28)
 #define SPI_CONTROL_MODE_MASK			(3 << 28)
 #define SPI_MODE_SEL(x)				(((x) & 0x3) << 28)
+#define SPI_MODE_VAL(x)				(((x) >> 28) & 0x3)
 #define SPI_M_S					(1 << 30)
 #define SPI_PIO					(1 << 31)
 
@@ -205,6 +206,7 @@ struct tegra_spi_data {
 	u32					spi_cs_timing1;
 	u32					spi_cs_timing2;
 	u8					last_used_cs;
+	u8					def_chip_select;
 
 	struct completion			xfer_completion;
 	struct spi_transfer			*curr_xfer;
@@ -827,7 +829,9 @@ static u32 tegra_spi_setup_transfer_one(struct spi_device *spi,
 				tegra_spi_writel(tspi, command1, SPI_COMMAND1);
 			tspi->cs_control = NULL;
 		} else
-			tegra_spi_writel(tspi, command1, SPI_COMMAND1);
+			if (SPI_MODE_VAL(command1) !=
+				SPI_MODE_VAL(tspi->def_command1_reg))
+				tegra_spi_writel(tspi, command1, SPI_COMMAND1);
 
 		/* GPIO based chip select control */
 		if (spi_get_csgpiod(spi, 0))
@@ -987,6 +991,8 @@ static int tegra_spi_setup(struct spi_device *spi)
 		val &= ~SPI_CS_POL_INACTIVE(spi_get_chipselect(spi, 0));
 	else
 		val |= SPI_CS_POL_INACTIVE(spi_get_chipselect(spi, 0));
+	if (tspi->def_chip_select == spi_get_chipselect(spi, 0))
+		val |= SPI_MODE_SEL(spi->mode & 0x3);
 	tspi->def_command1_reg = val;
 	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
 	spin_unlock_irqrestore(&tspi->lock, flags);
@@ -1341,6 +1347,8 @@ static int tegra_spi_probe(struct platform_device *pdev)
 		goto exit_free_host;
 	}
 
+	tspi->def_chip_select = 0;
+
 	tspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);
 	if (IS_ERR(tspi->base)) {
 		ret = PTR_ERR(tspi->base);
@@ -1400,6 +1408,8 @@ static int tegra_spi_probe(struct platform_device *pdev)
 	reset_control_assert(tspi->rst);
 	udelay(2);
 	reset_control_deassert(tspi->rst);
+	tspi->def_command1_reg  = tegra_spi_readl(tspi, SPI_COMMAND1);
+	tspi->def_command1_reg |= SPI_CS_SEL(tspi->def_chip_select);
 	tspi->def_command1_reg  = SPI_M_S;
 	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
 	tspi->spi_cs_timing1 = tegra_spi_readl(tspi, SPI_CS_TIMING1);
-- 
2.52.0


From c3beb6dd9526e0289ed9bd8a4f63a75555596d6e Mon Sep 17 00:00:00 2001
From: Martin Radev <mradev@nvidia.com>
Date: Sun, 28 Jul 2024 13:19:36 +0300
Subject: [PATCH 21/26] NVIDIA: SAUCE: PCI: Disable HDA enablement on Tegra
 iGPU

This patch disables HDA enablement for Tegra iGPUs
because HDA is not part of GPU on Tegra. Rather,
HDA is another platform device and does not require
the same WAR as on Desktop GPUs.

http://nvbugs/4765839
http://nvbugs/4781662

Signed-off-by: Martin Radev <mradev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/pci/quirks.c    | 7 +++++++
 include/linux/pci_ids.h | 1 +
 2 files changed, 8 insertions(+)

diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 5a1a41d5e8d1..479f8ae73b56 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -5781,6 +5781,13 @@ static void quirk_nvidia_hda(struct pci_dev *gpu)
 	if (gpu->device < PCI_DEVICE_ID_NVIDIA_GEFORCE_320M)
 		return;
 
+	/*
+	 * Skip HDA enablement on Tegra PCI iGPU because HDA is
+	 * a platform device on Tegra SoCs.
+	 */
+	if (gpu->device == PCI_DEVICE_ID_NVIDIA_TEGRA_T264)
+		return;
+
 	/* Bit 25 at offset 0x488 enables the HDA controller */
 	pci_read_config_dword(gpu, 0x488, &val);
 	if (val & BIT(25))
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 3be85e28b81f..67503ba66093 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -1383,6 +1383,7 @@
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE_320M           0x08A0
 #define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP79_SMBUS     0x0AA2
 #define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA	    0x0D85
+#define PCI_DEVICE_ID_NVIDIA_TEGRA_T264             0x2B00
 
 #define PCI_VENDOR_ID_IMS		0x10e0
 #define PCI_DEVICE_ID_IMS_TT128		0x9128
-- 
2.52.0


From 7f4fef500746daaf87e1124df08f242f104fc067 Mon Sep 17 00:00:00 2001
From: Xingang Wang <wangxingang5@huawei.com>
Date: Thu, 7 Nov 2024 13:29:15 +0530
Subject: [PATCH 22/26] iommu/of: Fix pci_request_acs() before enumerating PCI
 devices

When booting with devicetree, the pci_request_acs() is called after the
enumeration and initialization of PCI devices, thus the ACS is not
enabled. And ACS should be enabled when IOMMU is detected for the
PCI host bridge, so add check for IOMMU before probe of PCI host and call
pci_request_acs() to make sure ACS will be enabled when enumerating PCI
devices.

Change-Id: I4b9742de67850d51cdefd5217be0a82fb386a530
Fixes: 6bf6c24720d33 ("iommu/of: Request ACS from the PCI core when configuring IOMMU linkage")
Signed-off-by: Xingang Wang <wangxingang5@huawei.com>
Signed-off-by: Pavankumar Kondeti <quic_pkondeti@quicinc.com>
Reviewed-on: https://git-master.nvidia.com/r/c/3rdparty/canonical/linux-noble/+/3388469
GVS: buildbot_gerritrpt <buildbot_gerritrpt@nvidia.com>
Tested-by: Jordan Niethe <jniethe@nvidia.com>
Reviewed-by: Pritesh Raithatha <praithatha@nvidia.com>
---
 drivers/iommu/of_iommu.c | 1 -
 drivers/pci/of.c         | 8 +++++++-
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/iommu/of_iommu.c b/drivers/iommu/of_iommu.c
index 6b989a62def2..c31369924944 100644
--- a/drivers/iommu/of_iommu.c
+++ b/drivers/iommu/of_iommu.c
@@ -141,7 +141,6 @@ int of_iommu_configure(struct device *dev, struct device_node *master_np,
 			.np = master_np,
 		};
 
-		pci_request_acs();
 		err = pci_for_each_dma_alias(to_pci_dev(dev),
 					     of_pci_iommu_init, &info);
 		of_pci_check_device_ats(dev, master_np);
diff --git a/drivers/pci/of.c b/drivers/pci/of.c
index 3579265f1198..0a6a35936387 100644
--- a/drivers/pci/of.c
+++ b/drivers/pci/of.c
@@ -638,9 +638,15 @@ static int pci_parse_request_of_pci_ranges(struct device *dev,
 
 int devm_of_pci_bridge_init(struct device *dev, struct pci_host_bridge *bridge)
 {
-	if (!dev->of_node)
+	struct device_node *node = dev->of_node;
+
+	if (!node)
 		return 0;
 
+	/* Detect IOMMU and make sure ACS will be enabled */
+	if (of_property_read_bool(node, "iommu-map"))
+		pci_request_acs();
+
 	bridge->swizzle_irq = pci_common_swizzle;
 	bridge->map_irq = of_irq_parse_and_map_pci;
 
-- 
2.52.0


From ac99ae543074532e1df3d5f09b1aab23ed6ea4c8 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 8 Feb 2023 16:46:42 +0530
Subject: [PATCH 23/26] NVIDIA: SAUCE: of/irq: Adjust of_pci_irq parsing for
 multiple interrupts

BugLink: https://bugs.launchpad.net/bugs/2080908

Currently we are considering the first irq as the PCI interrupt pin,
but a PCI device may have multiple interrupts(e.g. PCIe WAKE# pin).

Only parse the PCI interrupt pin when the irq is unnamed or named as
"pci".

http://nvbugs/4478230

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
Signed-off-by: Manikanta Maddireddy <mmaddireddy@nvidia.com>
Reviewed-by: Thierry Reding <treding@nvidia.com>
(cherry-picked from https://patchwork.ozlabs.org/project/linux-pci/
patch/20230208111645.3863534-3-mmaddireddy@nvidia.com)
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/pci/of.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/drivers/pci/of.c b/drivers/pci/of.c
index 0a6a35936387..8ecd72fa318c 100644
--- a/drivers/pci/of.c
+++ b/drivers/pci/of.c
@@ -474,9 +474,17 @@ static int of_irq_parse_pci(const struct pci_dev *pdev, struct of_phandle_args *
 	 */
 	dn = pci_device_to_OF_node(pdev);
 	if (dn) {
-		rc = of_irq_parse_one(dn, 0, out_irq);
-		if (!rc)
-			return rc;
+		int index;
+
+		index = of_property_match_string(dn, "interrupt-names", "pci");
+		if (index == -EINVAL)	/* Property doesn't exist */
+			index = 0;
+
+		if (index >= 0) {
+			rc = of_irq_parse_one(dn, index, out_irq);
+			if (!rc)
+				return rc;
+		}
 	}
 
 	/*
-- 
2.52.0


From 83f661b6d8550c522e40979ad7b2b5a2b7041281 Mon Sep 17 00:00:00 2001
From: Sheetal <sheetal@nvidia.com>
Date: Fri, 31 Oct 2025 11:38:24 +0000
Subject: [PATCH 24/26] dmaengine: tegra-adma: Fix use-after-free

A use-after-free bug exists in the Tegra ADMA driver when audio streams
are terminated, particularly during XRUN conditions. The issue occurs
when the DMA buffer is freed by tegra_adma_terminate_all() before the
vchan completion tasklet finishes accessing it.

The race condition follows this sequence:

  1. DMA transfer completes, triggering an interrupt that schedules the
     completion tasklet (tasklet has not executed yet)
  2. Audio playback stops, calling tegra_adma_terminate_all() which
     frees the DMA buffer memory via kfree()
  3. The scheduled tasklet finally executes, calling vchan_complete()
     which attempts to access the already-freed memory

Since tasklets can execute at any time after being scheduled, there is
no guarantee that the buffer will remain valid when vchan_complete()
runs.

Fix this by properly synchronizing the virtual channel completion:
 - Calling vchan_terminate_vdesc() in tegra_adma_stop() to mark the
   descriptors as terminated instead of freeing the descriptor.
 - Add the callback tegra_adma_synchronize() that calls
   vchan_synchronize() which kills any pending tasklets and frees any
   terminated descriptors.

Crash logs:
[  337.427523] BUG: KASAN: use-after-free in vchan_complete+0x124/0x3b0
[  337.427544] Read of size 8 at addr ffff000132055428 by task swapper/0/0

[  337.427562] Call trace:
[  337.427564]  dump_backtrace+0x0/0x320
[  337.427571]  show_stack+0x20/0x30
[  337.427575]  dump_stack_lvl+0x68/0x84
[  337.427584]  print_address_description.constprop.0+0x74/0x2b8
[  337.427590]  kasan_report+0x1f4/0x210
[  337.427598]  __asan_load8+0xa0/0xd0
[  337.427603]  vchan_complete+0x124/0x3b0
[  337.427609]  tasklet_action_common.constprop.0+0x190/0x1d0
[  337.427617]  tasklet_action+0x30/0x40
[  337.427623]  __do_softirq+0x1a0/0x5c4
[  337.427628]  irq_exit+0x110/0x140
[  337.427633]  handle_domain_irq+0xa4/0xe0
[  337.427640]  gic_handle_irq+0x64/0x160
[  337.427644]  call_on_irq_stack+0x20/0x4c
[  337.427649]  do_interrupt_handler+0x7c/0x90
[  337.427654]  el1_interrupt+0x30/0x80
[  337.427659]  el1h_64_irq_handler+0x18/0x30
[  337.427663]  el1h_64_irq+0x7c/0x80
[  337.427667]  cpuidle_enter_state+0xe4/0x540
[  337.427674]  cpuidle_enter+0x54/0x80
[  337.427679]  do_idle+0x2e0/0x380
[  337.427685]  cpu_startup_entry+0x2c/0x70
[  337.427690]  rest_init+0x114/0x130
[  337.427695]  arch_call_rest_init+0x18/0x24
[  337.427702]  start_kernel+0x380/0x3b4
[  337.427706]  __primary_switched+0xc0/0xc8

Fixes: f46b195799b5 ("dmaengine: tegra-adma: Add support for Tegra210 ADMA")

Bug 5638368
Bug 4879633

Change-Id: I2ea7f38ef7041db2fac63d1e62ecdef04fb929de
Signed-off-by: sheetal <sheetal@nvidia.com>
Reviewed-on: https://git-master.nvidia.com/r/c/3rdparty/canonical/linux-noble/+/3482483
Reviewed-by: svcacv <svcacv@nvidia.com>
Reviewed-by: Sameer Pujar <spujar@nvidia.com>
GVS: buildbot_gerritrpt <buildbot_gerritrpt@nvidia.com>
Reviewed-by: Mohan kumar <mkumard@nvidia.com>
---
 drivers/dma/tegra210-adma.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/drivers/dma/tegra210-adma.c b/drivers/dma/tegra210-adma.c
index 864a8c55f33b..c82b38f6659f 100644
--- a/drivers/dma/tegra210-adma.c
+++ b/drivers/dma/tegra210-adma.c
@@ -429,10 +429,17 @@ static void tegra_adma_stop(struct tegra_adma_chan *tdc)
 		return;
 	}
 
-	kfree(tdc->desc);
+	vchan_terminate_vdesc(&tdc->desc->vd);
 	tdc->desc = NULL;
 }
 
+static void tegra_adma_synchronize(struct dma_chan *dc)
+{
+	struct tegra_adma_chan *tdc = to_tegra_adma_chan(dc);
+
+	vchan_synchronize(&tdc->vc);
+}
+
 static void tegra_adma_start(struct tegra_adma_chan *tdc)
 {
 	struct virt_dma_desc *vd = vchan_next_desc(&tdc->vc);
@@ -1151,6 +1158,7 @@ static int tegra_adma_probe(struct platform_device *pdev)
 	tdma->dma_dev.device_config = tegra_adma_slave_config;
 	tdma->dma_dev.device_tx_status = tegra_adma_tx_status;
 	tdma->dma_dev.device_terminate_all = tegra_adma_terminate_all;
+	tdma->dma_dev.device_synchronize = tegra_adma_synchronize;
 	tdma->dma_dev.src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);
 	tdma->dma_dev.dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);
 	tdma->dma_dev.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
-- 
2.52.0


From 3cd245d00e6bdcf1f1401d4dc8e111a092d257c7 Mon Sep 17 00:00:00 2001
From: Pritesh Raithatha <praithatha@nvidia.com>
Date: Thu, 17 Apr 2025 03:04:36 -0700
Subject: [PATCH 25/26] iommu/arm-smmu-v3: use reserved memory for allocations

CMA allocations are reusable. When not allocated, it can be used
for temporary allocations. When there is allocation request,
temporary allocations will be reclaimed and that takes time.

SMMU uses CMA allocations and causing boot time increase. To avoid
this, add reserved memory pool and use for SMMU allocations instead
of CMA.

With reserved memory 1MB allocation time is reduced from 17999343ns
to 166037ns.

Bug 5115195

Change-Id: I34febac4235da68027908969b9348cbfd2feffc4
Signed-off-by: Pritesh Raithatha <praithatha@nvidia.com>
Reviewed-on: https://git-master.nvidia.com/r/c/3rdparty/canonical/linux-noble/+/3446227
Reviewed-by: svcacv <svcacv@nvidia.com>
GVS: buildbot_gerritrpt <buildbot_gerritrpt@nvidia.com>
Reviewed-by: Bharat Nihalani <bnihalani@nvidia.com>
Tested-by: Bharat Nihalani <bnihalani@nvidia.com>
---
 drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
index c9776cf74717..57d2aa677051 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
@@ -2,7 +2,8 @@
 /*
  * IOMMU API for ARM architected SMMUv3 implementations.
  *
- * Copyright (C) 2015 ARM Limited
+ * SPDX-FileCopyrightText: Copyright (C) 2015 ARM Limited
+ * SPDX-FileCopyrightText: Copyright (c) 2023-2025, NVIDIA CORPORATION. All rights reserved.
  *
  * Author: Will Deacon <will.deacon@arm.com>
  *
@@ -23,6 +24,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/pci.h>
 #include <linux/pci-ats.h>
 #include <linux/platform_device.h>
@@ -4621,6 +4623,9 @@ static int arm_smmu_device_dt_probe(struct platform_device *pdev,
 	u32 cells;
 	int ret = -EINVAL;
 
+	if (!of_reserved_mem_device_init(dev))
+		dev_info(dev, "using device-specific reserved memory\n");
+
 	if (of_property_read_u32(dev->of_node, "#iommu-cells", &cells))
 		dev_err(dev, "missing #iommu-cells property\n");
 	else if (cells != 1)
-- 
2.52.0


From 2c7863395ff356d90925f94bf41e37da9e2a997d Mon Sep 17 00:00:00 2001
From: Ashish Mhetre <amhetre@nvidia.com>
Date: Tue, 12 Aug 2025 06:32:27 +0000
Subject: [PATCH 26/26] iommu/arm-smmu-v3: Implement WAR for Tegra264 Errata
 T264-SMMU-3

If there is active traffic on a page while it is being invalidated, it
is possible that the intended invalidated entry is not properly evicted
from the SMMU TLB caches. Subsequent requests to the same virtual
address could get the older mapping and access the wrong location, which
can be a functional and a security problem.
Repeat the entire invalidation->sync sequence once for every
invalidation queued. The second set of invalidation + sync commands is
guaranteed to evict the entry out of all TLBs.

Bug 5448714
Bug 5150304

Change-Id: I40e891a1459f4c65e4e2e7f0224867d6c1be277a
(cherry-picked from commit 27c7fb19c438457aabe7d7b4812bf88778750017)
Signed-off-by: Ashish Mhetre <amhetre@nvidia.com>
Reviewed-on: https://git-master.nvidia.com/r/c/3rdparty/canonical/linux-noble/+/3496080
GVS: buildbot_gerritrpt <buildbot_gerritrpt@nvidia.com>
Reviewed-by: Pritesh Raithatha <praithatha@nvidia.com>
---
 drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c | 13 +++++++++++++
 drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h |  1 +
 2 files changed, 14 insertions(+)

diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
index 57d2aa677051..f8fbae287396 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
@@ -83,6 +83,7 @@ DEFINE_MUTEX(arm_smmu_asid_lock);
 static struct arm_smmu_option_prop arm_smmu_options[] = {
 	{ ARM_SMMU_OPT_SKIP_PREFETCH, "hisilicon,broken-prefetch-cmd" },
 	{ ARM_SMMU_OPT_PAGE0_REGS_ONLY, "cavium,cn9900-broken-page1-regspace"},
+	{ ARM_SMMU_OPT_TLBI_TWICE, "nvidia,tegra264-tlbi-race-fix"},
 	{ 0, NULL},
 };
 
@@ -1240,6 +1241,8 @@ static void arm_smmu_sync_cd(struct arm_smmu_master *master,
 	}
 
 	arm_smmu_cmdq_batch_submit(smmu, &cmds);
+	if (smmu->options & ARM_SMMU_OPT_TLBI_TWICE)
+		arm_smmu_cmdq_batch_submit(smmu, &cmds);
 }
 
 static void arm_smmu_write_cd_l1_desc(struct arm_smmu_cdtab_l1 *dst,
@@ -2358,6 +2361,8 @@ static void arm_smmu_tlb_inv_range_domain(unsigned long iova, size_t size,
 		cmd.tlbi.vmid	= smmu_domain->s2_cfg.vmid;
 	}
 	__arm_smmu_tlb_inv_range(&cmd, iova, size, granule, smmu_domain);
+	if (smmu_domain->smmu->options & ARM_SMMU_OPT_TLBI_TWICE)
+		__arm_smmu_tlb_inv_range(&cmd, iova, size, granule, smmu_domain);
 
 	if (smmu_domain->nest_parent) {
 		/*
@@ -2389,6 +2394,8 @@ void arm_smmu_tlb_inv_range_asid(unsigned long iova, size_t size, int asid,
 	};
 
 	__arm_smmu_tlb_inv_range(&cmd, iova, size, granule, smmu_domain);
+	if (smmu_domain->smmu->options & ARM_SMMU_OPT_TLBI_TWICE)
+		__arm_smmu_tlb_inv_range(&cmd, iova, size, granule, smmu_domain);
 }
 
 static void arm_smmu_tlb_inv_page_nosync(struct iommu_iotlb_gather *gather,
@@ -4166,15 +4173,21 @@ static int arm_smmu_device_reset(struct arm_smmu_device *smmu)
 	/* Invalidate any cached configuration */
 	cmd.opcode = CMDQ_OP_CFGI_ALL;
 	arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
+	if (smmu->options & ARM_SMMU_OPT_TLBI_TWICE)
+		arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
 
 	/* Invalidate any stale TLB entries */
 	if (smmu->features & ARM_SMMU_FEAT_HYP) {
 		cmd.opcode = CMDQ_OP_TLBI_EL2_ALL;
 		arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
+		if (smmu->options & ARM_SMMU_OPT_TLBI_TWICE)
+			arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
 	}
 
 	cmd.opcode = CMDQ_OP_TLBI_NSNH_ALL;
 	arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
+	if (smmu->options & ARM_SMMU_OPT_TLBI_TWICE)
+		arm_smmu_cmdq_issue_cmd_with_sync(smmu, &cmd);
 
 	/* Event queue */
 	writeq_relaxed(smmu->evtq.q.q_base, smmu->base + ARM_SMMU_EVTQ_BASE);
diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
index ae23aacc3840..0cda36d20f06 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
@@ -775,6 +775,7 @@ struct arm_smmu_device {
 #define ARM_SMMU_OPT_MSIPOLL		(1 << 2)
 #define ARM_SMMU_OPT_CMDQ_FORCE_SYNC	(1 << 3)
 #define ARM_SMMU_OPT_TEGRA241_CMDQV	(1 << 4)
+#define ARM_SMMU_OPT_TLBI_TWICE		(1 << 5)
 	u32				options;
 
 	struct arm_smmu_cmdq		cmdq;
-- 
2.52.0

