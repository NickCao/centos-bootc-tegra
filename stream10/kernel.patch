From 8f7cf887da8ddde498874eeed9e7a089d01ff5d9 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Mon, 27 May 2024 10:08:04 +0000
Subject: [PATCH 01/21] NVIDIA: SAUCE: phy: tegra: xusb: Add Tegra264 support

Add support for the XUSB pad controller for Tegra264. Most of
the Tegra264 XUSB PADCTL registers definition and programming sequence
are the same as Tegra234, Tegra264 XUSB PADCTL can share the same
driver with Tegra186, Tegra194, and Tegra234 XUSB PADCTL.

http://nvbugs/4295138

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/phy/tegra/Makefile        |  1 +
 drivers/phy/tegra/xusb-tegra186.c | 26 +++++++++++++++++++++++++-
 drivers/phy/tegra/xusb.c          |  6 ++++++
 drivers/phy/tegra/xusb.h          |  3 +++
 4 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/drivers/phy/tegra/Makefile b/drivers/phy/tegra/Makefile
index eeeea72de117..33a695d4ed59 100644
--- a/drivers/phy/tegra/Makefile
+++ b/drivers/phy/tegra/Makefile
@@ -8,4 +8,5 @@ phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_210_SOC) += xusb-tegra210.o
 phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_186_SOC) += xusb-tegra186.o
 phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_194_SOC) += xusb-tegra186.o
 phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_234_SOC) += xusb-tegra186.o
+phy-tegra-xusb-$(CONFIG_ARCH_TEGRA_264_SOC) += xusb-tegra186.o
 obj-$(CONFIG_PHY_TEGRA194_P2U) += phy-tegra194-p2u.o
diff --git a/drivers/phy/tegra/xusb-tegra186.c b/drivers/phy/tegra/xusb-tegra186.c
index e818f6c3980e..b6dee225bc15 100644
--- a/drivers/phy/tegra/xusb-tegra186.c
+++ b/drivers/phy/tegra/xusb-tegra186.c
@@ -1648,7 +1648,8 @@ EXPORT_SYMBOL_GPL(tegra186_xusb_padctl_soc);
 #endif
 
 #if IS_ENABLED(CONFIG_ARCH_TEGRA_194_SOC) || \
-	IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC)
+	IS_ENABLED(CONFIG_ARCH_TEGRA_234_SOC) || \
+	IS_ENABLED(CONFIG_ARCH_TEGRA_264_SOC)
 static const char * const tegra194_xusb_padctl_supply_names[] = {
 	"avdd-usb",
 	"vclamp-usb",
@@ -1731,6 +1732,29 @@ const struct tegra_xusb_padctl_soc tegra234_xusb_padctl_soc = {
 	.supports_lp_cfg_en = true,
 };
 EXPORT_SYMBOL_GPL(tegra234_xusb_padctl_soc);
+
+const struct tegra_xusb_padctl_soc tegra264_xusb_padctl_soc = {
+	.num_pads = ARRAY_SIZE(tegra194_pads),
+	.pads = tegra194_pads,
+	.ports = {
+		.usb2 = {
+			.ops = &tegra186_usb2_port_ops,
+			.count = 4,
+		},
+		.usb3 = {
+			.ops = &tegra186_usb3_port_ops,
+			.count = 4,
+		},
+	},
+	.ops = &tegra186_xusb_padctl_ops,
+	.supply_names = tegra194_xusb_padctl_supply_names,
+	.num_supplies = ARRAY_SIZE(tegra194_xusb_padctl_supply_names),
+	.supports_gen2 = true,
+	.poll_trk_completed = true,
+	.trk_hw_mode = true,
+	.supports_lp_cfg_en = true,
+};
+EXPORT_SYMBOL_GPL(tegra264_xusb_padctl_soc);
 #endif
 
 MODULE_AUTHOR("JC Kuo <jckuo@nvidia.com>");
diff --git a/drivers/phy/tegra/xusb.c b/drivers/phy/tegra/xusb.c
index c89df95aa6ca..12bcc9754b37 100644
--- a/drivers/phy/tegra/xusb.c
+++ b/drivers/phy/tegra/xusb.c
@@ -77,6 +77,12 @@ static const struct of_device_id tegra_xusb_padctl_of_match[] = {
 		.compatible = "nvidia,tegra234-xusb-padctl",
 		.data = &tegra234_xusb_padctl_soc,
 	},
+#endif
+#if defined(CONFIG_ARCH_TEGRA_264_SOC)
+	{
+		.compatible = "nvidia,tegra264-xusb-padctl",
+		.data = &tegra264_xusb_padctl_soc,
+	},
 #endif
 	{ }
 };
diff --git a/drivers/phy/tegra/xusb.h b/drivers/phy/tegra/xusb.h
index d2b5f9565132..b3302e9c7896 100644
--- a/drivers/phy/tegra/xusb.h
+++ b/drivers/phy/tegra/xusb.h
@@ -514,5 +514,8 @@ extern const struct tegra_xusb_padctl_soc tegra194_xusb_padctl_soc;
 #if defined(CONFIG_ARCH_TEGRA_234_SOC)
 extern const struct tegra_xusb_padctl_soc tegra234_xusb_padctl_soc;
 #endif
+#if defined(CONFIG_ARCH_TEGRA_264_SOC)
+extern const struct tegra_xusb_padctl_soc tegra264_xusb_padctl_soc;
+#endif
 
 #endif /* __PHY_TEGRA_XUSB_H */
-- 
2.51.0


From 0896bc29ed7d29362611fc9857c0c3d32dfe8675 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Mon, 27 May 2024 10:48:46 +0000
Subject: [PATCH 02/21] NVIDIA: SAUCE: usb: host: xhci-tegra: Add Tegra264 XHCI
 support

This commit adds Tegra264 XUSB host mode controller support.

http://nvbugs/4295138

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/usb/host/xhci-tegra.c | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/drivers/usb/host/xhci-tegra.c b/drivers/usb/host/xhci-tegra.c
index 0c7af44d4dae..718e2ae6cd21 100644
--- a/drivers/usb/host/xhci-tegra.c
+++ b/drivers/usb/host/xhci-tegra.c
@@ -2656,12 +2656,38 @@ static const struct tegra_xusb_soc tegra234_soc = {
 	.has_bar2 = true,
 };
 
+static const struct tegra_xusb_soc tegra264_soc = {
+	.supply_names = tegra194_supply_names,
+	.num_supplies = ARRAY_SIZE(tegra194_supply_names),
+	.phy_types = tegra194_phy_types,
+	.num_types = ARRAY_SIZE(tegra194_phy_types),
+	.context = &tegra186_xusb_context,
+	.ports = {
+		.usb3 = { .offset = 0, .count = 4, },
+		.usb2 = { .offset = 4, .count = 4, },
+	},
+	.scale_ss_clock = false,
+	.has_ipfs = false,
+	.otg_reset_sspi = false,
+	.ops = &tegra234_ops,
+	.mbox = {
+		.cmd = XUSB_BAR2_ARU_MBOX_CMD,
+		.data_in = XUSB_BAR2_ARU_MBOX_DATA_IN,
+		.data_out = XUSB_BAR2_ARU_MBOX_DATA_OUT,
+		.owner = XUSB_BAR2_ARU_MBOX_OWNER,
+		.smi_intr = XUSB_BAR2_ARU_SMI_INTR,
+	},
+	.lpm_support = true,
+	.has_bar2 = true,
+};
+
 static const struct of_device_id tegra_xusb_of_match[] = {
 	{ .compatible = "nvidia,tegra124-xusb", .data = &tegra124_soc },
 	{ .compatible = "nvidia,tegra210-xusb", .data = &tegra210_soc },
 	{ .compatible = "nvidia,tegra186-xusb", .data = &tegra186_soc },
 	{ .compatible = "nvidia,tegra194-xusb", .data = &tegra194_soc },
 	{ .compatible = "nvidia,tegra234-xusb", .data = &tegra234_soc },
+	{ .compatible = "nvidia,tegra264-xusb", .data = &tegra264_soc },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, tegra_xusb_of_match);
-- 
2.51.0


From 37867132b22391a5481a221fbf7415679ef17fc5 Mon Sep 17 00:00:00 2001
From: Prathamesh Shete <pshete@nvidia.com>
Date: Wed, 19 Jun 2024 09:58:54 +0000
Subject: [PATCH 03/21] NVIDIA: SAUCE: gpio: t264: add GPIO support for T264

Add required support for T264 GPIO

Signed-off-by: Prathamesh Shete <pshete@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/gpio/gpio-tegra186.c             | 99 ++++++++++++++++++++++++
 include/dt-bindings/gpio/tegra264-gpio.h | 61 +++++++++++++++
 2 files changed, 160 insertions(+)
 create mode 100644 include/dt-bindings/gpio/tegra264-gpio.h

diff --git a/drivers/gpio/gpio-tegra186.c b/drivers/gpio/gpio-tegra186.c
index 1ecb733a5e88..76eaf4f44a29 100644
--- a/drivers/gpio/gpio-tegra186.c
+++ b/drivers/gpio/gpio-tegra186.c
@@ -20,6 +20,7 @@
 #include <dt-bindings/gpio/tegra194-gpio.h>
 #include <dt-bindings/gpio/tegra234-gpio.h>
 #include <dt-bindings/gpio/tegra241-gpio.h>
+#include <dt-bindings/gpio/tegra264-gpio.h>
 
 /* security registers */
 #define TEGRA186_GPIO_CTL_SCR 0x0c
@@ -743,6 +744,7 @@ static const struct of_device_id tegra186_pmc_of_match[] = {
 	{ .compatible = "nvidia,tegra186-pmc" },
 	{ .compatible = "nvidia,tegra194-pmc" },
 	{ .compatible = "nvidia,tegra234-pmc" },
+	{ .compatible = "nvidia,tegra264-pmc" },
 	{ /* sentinel */ }
 };
 
@@ -1272,6 +1274,94 @@ static const struct tegra_gpio_soc tegra241_aon_soc = {
 	.num_irqs_per_bank = 8,
 	.has_vm_support = false,
 };
+#define TEGRA264_MAIN_GPIO_PORT(_name, _bank, _port, _pins)	\
+	[TEGRA264_MAIN_GPIO_PORT_##_name] = {		\
+		.name = #_name,					\
+		.bank = _bank,					\
+		.port = _port,					\
+		.pins = _pins,					\
+	}
+
+static const struct tegra_gpio_port tegra264_main_ports[] = {
+	TEGRA264_MAIN_GPIO_PORT(T, 0, 0, 7),
+	TEGRA264_MAIN_GPIO_PORT(U, 0, 1, 8),
+	TEGRA264_MAIN_GPIO_PORT(V, 0, 2, 8),
+	TEGRA264_MAIN_GPIO_PORT(W, 0, 3, 8),
+	TEGRA264_MAIN_GPIO_PORT(AL, 0, 4, 3),
+	TEGRA264_MAIN_GPIO_PORT(Y, 0, 5, 8),
+	TEGRA264_MAIN_GPIO_PORT(Z, 0, 6, 8),
+	TEGRA264_MAIN_GPIO_PORT(X, 0, 7, 6),
+	TEGRA264_MAIN_GPIO_PORT(H, 1, 0, 8),
+	TEGRA264_MAIN_GPIO_PORT(J, 1, 1, 8),
+	TEGRA264_MAIN_GPIO_PORT(K, 1, 2, 8),
+	TEGRA264_MAIN_GPIO_PORT(L, 1, 3, 8),
+	TEGRA264_MAIN_GPIO_PORT(M, 1, 4, 6),
+	TEGRA264_MAIN_GPIO_PORT(P, 2, 0, 8),
+	TEGRA264_MAIN_GPIO_PORT(Q, 2, 1, 8),
+	TEGRA264_MAIN_GPIO_PORT(R, 2, 2, 8),
+	TEGRA264_MAIN_GPIO_PORT(S, 2, 3, 2),
+	TEGRA264_MAIN_GPIO_PORT(F, 3, 0, 8),
+	TEGRA264_MAIN_GPIO_PORT(G, 3, 1, 5),
+};
+
+static const struct tegra_gpio_soc tegra264_main_soc = {
+	.num_ports = ARRAY_SIZE(tegra264_main_ports),
+	.ports = tegra264_main_ports,
+	.name = "tegra264-gpio-main",
+	.instance = 0,
+	.num_irqs_per_bank = 8,
+	.has_vm_support = true,
+};
+
+#define TEGRA264_UPHY_GPIO_PORT(_name, _bank, _port, _pins)	\
+	[TEGRA264_UPHY_GPIO_PORT_##_name] = {			\
+		.name = #_name,					\
+		.bank = _bank,					\
+		.port = _port,					\
+		.pins = _pins,					\
+	}
+
+static const struct tegra_gpio_port tegra264_uphy_ports[] = {
+	TEGRA264_UPHY_GPIO_PORT(A, 0, 0, 6),
+	TEGRA264_UPHY_GPIO_PORT(B, 0, 1, 8),
+	TEGRA264_UPHY_GPIO_PORT(C, 0, 2, 3),
+	TEGRA264_UPHY_GPIO_PORT(D, 1, 0, 8),
+	TEGRA264_UPHY_GPIO_PORT(E, 1, 1, 4),
+};
+
+static const struct tegra_gpio_soc tegra264_uphy_soc = {
+	.num_ports = ARRAY_SIZE(tegra264_uphy_ports),
+	.ports = tegra264_uphy_ports,
+	.name = "tegra264-gpio-uphy",
+	.instance = 0,
+	.num_irqs_per_bank = 8,
+	.has_vm_support = true,
+};
+
+#define TEGRA264_AON_GPIO_PORT(_name, _bank, _port, _pins)	\
+	[TEGRA264_AON_GPIO_PORT_##_name] = {			\
+		.name = #_name,					\
+		.bank = _bank,					\
+		.port = _port,					\
+		.pins = _pins,					\
+	}
+
+static const struct tegra_gpio_port tegra264_aon_ports[] = {
+	TEGRA264_AON_GPIO_PORT(AA, 0, 0, 8),
+	TEGRA264_AON_GPIO_PORT(BB, 0, 1, 2),
+	TEGRA264_AON_GPIO_PORT(CC, 0, 2, 8),
+	TEGRA264_AON_GPIO_PORT(DD, 0, 3, 8),
+	TEGRA264_AON_GPIO_PORT(EE, 0, 4, 4)
+};
+
+static const struct tegra_gpio_soc tegra264_aon_soc = {
+	.num_ports = ARRAY_SIZE(tegra264_aon_ports),
+	.ports = tegra264_aon_ports,
+	.name = "tegra264-gpio-aon",
+	.instance = 1,
+	.num_irqs_per_bank = 8,
+	.has_vm_support = true,
+};
 
 static const struct of_device_id tegra186_gpio_of_match[] = {
 	{
@@ -1292,6 +1382,15 @@ static const struct of_device_id tegra186_gpio_of_match[] = {
 	}, {
 		.compatible = "nvidia,tegra234-gpio-aon",
 		.data = &tegra234_aon_soc
+	}, {
+		.compatible = "nvidia,tegra264-gpio-main",
+		.data = &tegra264_main_soc
+	}, {
+		.compatible = "nvidia,tegra264-gpio-uphy",
+		.data = &tegra264_uphy_soc
+	}, {
+		.compatible = "nvidia,tegra264-gpio-aon",
+		.data = &tegra264_aon_soc
 	}, {
 		/* sentinel */
 	}
diff --git a/include/dt-bindings/gpio/tegra264-gpio.h b/include/dt-bindings/gpio/tegra264-gpio.h
new file mode 100644
index 000000000000..c5749e489e03
--- /dev/null
+++ b/include/dt-bindings/gpio/tegra264-gpio.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2023, NVIDIA CORPORATION. All rights reserved. */
+
+/*
+ * This header provides constants for binding nvidia,tegra234-gpio*.
+ *
+ * The first cell in Tegra's GPIO specifier is the GPIO ID. The macros below
+ * provide names for this.
+ *
+ * The second cell contains standard flag values specified in gpio.h.
+ */
+
+#ifndef _DT_BINDINGS_GPIO_TEGRA264_GPIO_H
+#define _DT_BINDINGS_GPIO_TEGRA264_GPIO_H
+
+#include <dt-bindings/gpio/gpio.h>
+
+/* GPIOs implemented by main GPIO controller */
+#define TEGRA264_MAIN_GPIO_PORT_T  0
+#define TEGRA264_MAIN_GPIO_PORT_U  1
+#define TEGRA264_MAIN_GPIO_PORT_V  2
+#define TEGRA264_MAIN_GPIO_PORT_W  3
+#define TEGRA264_MAIN_GPIO_PORT_AL 4
+#define TEGRA264_MAIN_GPIO_PORT_Y  5
+#define TEGRA264_MAIN_GPIO_PORT_Z  6
+#define TEGRA264_MAIN_GPIO_PORT_X  7
+#define TEGRA264_MAIN_GPIO_PORT_H  8
+#define TEGRA264_MAIN_GPIO_PORT_J  9
+#define TEGRA264_MAIN_GPIO_PORT_K  10
+#define TEGRA264_MAIN_GPIO_PORT_L  11
+#define TEGRA264_MAIN_GPIO_PORT_M  12
+#define TEGRA264_MAIN_GPIO_PORT_P  13
+#define TEGRA264_MAIN_GPIO_PORT_Q  14
+#define TEGRA264_MAIN_GPIO_PORT_R  15
+#define TEGRA264_MAIN_GPIO_PORT_S  16
+#define TEGRA264_MAIN_GPIO_PORT_F  17
+#define TEGRA264_MAIN_GPIO_PORT_G  18
+
+#define TEGRA264_MAIN_GPIO(port, offset) \
+	((TEGRA264_MAIN_GPIO_PORT_##port * 8) + offset)
+
+/* GPIOs implemented by AON GPIO controller */
+#define TEGRA264_AON_GPIO_PORT_AA  0
+#define TEGRA264_AON_GPIO_PORT_BB  1
+#define TEGRA264_AON_GPIO_PORT_CC  2
+#define TEGRA264_AON_GPIO_PORT_DD  3
+#define TEGRA264_AON_GPIO_PORT_EE  4
+
+#define TEGRA264_AON_GPIO(port, offset) \
+	((TEGRA264_AON_GPIO_PORT_##port * 8) + offset)
+
+#define TEGRA264_UPHY_GPIO_PORT_A  0
+#define TEGRA264_UPHY_GPIO_PORT_B  1
+#define TEGRA264_UPHY_GPIO_PORT_C  2
+#define TEGRA264_UPHY_GPIO_PORT_D  3
+#define TEGRA264_UPHY_GPIO_PORT_E  4
+
+#define TEGRA264_UPHY_GPIO(port, offset) \
+	((TEGRA264_UPHY_GPIO_PORT_##port * 8) + offset)
+
+#endif
-- 
2.51.0


From c0f4b61ffecf2f2b2cd27970bd31687012cbf892 Mon Sep 17 00:00:00 2001
From: Prathamesh Shete <pshete@nvidia.com>
Date: Wed, 19 Jun 2024 10:46:38 +0000
Subject: [PATCH 04/21] NVIDIA: SAUCE: pinctrl: t264: Add pinctrl support for
 T264

Add pinctrl support for T264

Signed-off-by: Prathamesh Shete <pshete@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/pinctrl/Kconfig                  |    7 +
 drivers/pinctrl/tegra/Kconfig            |    4 +
 drivers/pinctrl/tegra/Makefile           |    1 +
 drivers/pinctrl/tegra/pinctrl-tegra264.c | 2223 ++++++++++++++++++++++
 4 files changed, 2235 insertions(+)
 create mode 100644 drivers/pinctrl/tegra/pinctrl-tegra264.c

diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 354536de564b..d255c6fb137d 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -31,6 +31,13 @@ config DEBUG_PINCTRL
 	help
 	  Say Y here to add some extra checks and diagnostics to PINCTRL calls.
 
+config PINCTRL_TEGRA264
+	bool "NVIDIA Tegra264 Pinmux support"
+	select PINCTRL_TEGRA
+	default y
+	help
+	Support for the NVIDIA Tegra264 PINCTRL controller driver.
+
 config PINCTRL_AMD
 	bool "AMD GPIO pin control"
 	depends on HAS_IOMEM
diff --git a/drivers/pinctrl/tegra/Kconfig b/drivers/pinctrl/tegra/Kconfig
index 4e87d19323ba..68bd01ba6830 100644
--- a/drivers/pinctrl/tegra/Kconfig
+++ b/drivers/pinctrl/tegra/Kconfig
@@ -32,6 +32,10 @@ config PINCTRL_TEGRA234
 	bool
 	select PINCTRL_TEGRA
 
+config PINCTRL_TEGRA264
+	bool
+	select PINCTRL_TEGRA
+
 config PINCTRL_TEGRA_XUSB
 	def_bool y if ARCH_TEGRA
 	select GENERIC_PHY
diff --git a/drivers/pinctrl/tegra/Makefile b/drivers/pinctrl/tegra/Makefile
index a93973701d4c..8aef7d4cf71a 100644
--- a/drivers/pinctrl/tegra/Makefile
+++ b/drivers/pinctrl/tegra/Makefile
@@ -7,4 +7,5 @@ obj-$(CONFIG_PINCTRL_TEGRA124)		+= pinctrl-tegra124.o
 obj-$(CONFIG_PINCTRL_TEGRA210)		+= pinctrl-tegra210.o
 obj-$(CONFIG_PINCTRL_TEGRA194)		+= pinctrl-tegra194.o
 obj-$(CONFIG_PINCTRL_TEGRA234)		+= pinctrl-tegra234.o
+obj-$(CONFIG_PINCTRL_TEGRA264)		+= pinctrl-tegra264.o
 obj-$(CONFIG_PINCTRL_TEGRA_XUSB)	+= pinctrl-tegra-xusb.o
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra264.c b/drivers/pinctrl/tegra/pinctrl-tegra264.c
new file mode 100644
index 000000000000..8b953b8bf1e6
--- /dev/null
+++ b/drivers/pinctrl/tegra/pinctrl-tegra264.c
@@ -0,0 +1,2223 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Pinctrl data for the NVIDIA Tegra264 pinmux
+ *
+ * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
+ */
+
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+
+#include "pinctrl-tegra.h"
+
+/* Define unique ID for each pins */
+enum {
+	TEGRA_PIN_PEX_L4_CLKREQ_N_PD0,
+	TEGRA_PIN_PEX_L4_RST_N_PD1,
+	TEGRA_PIN_PEX_L5_CLKREQ_N_PD2,
+	TEGRA_PIN_PEX_L5_RST_N_PD3,
+	TEGRA_PIN_ETH0_MDIO_PD4,
+	TEGRA_PIN_ETH0_MDC_PD5,
+	TEGRA_PIN_ETH3_MDIO_PD6,
+	TEGRA_PIN_ETH3_MDC_PD7,
+	TEGRA_PIN_ETH1_MDIO_PE0,
+	TEGRA_PIN_ETH1_MDC_PE1,
+	TEGRA_PIN_ETH2_MDIO_PE2,
+	TEGRA_PIN_ETH2_MDC_PE3,
+	TEGRA_PIN_PEX_L1_CLKREQ_N_PB0,
+	TEGRA_PIN_PEX_L1_RST_N_PB1,
+	TEGRA_PIN_PEX_L2_CLKREQ_N_PB2,
+	TEGRA_PIN_PEX_L2_RST_N_PB3,
+	TEGRA_PIN_PEX_L3_CLKREQ_N_PB4,
+	TEGRA_PIN_PEX_L3_RST_N_PB5,
+	TEGRA_PIN_SOC_GPIO113_PB6,
+	TEGRA_PIN_SOC_GPIO114_PB7,
+	TEGRA_PIN_SGMII0_SMA_MDIO_PC0,
+	TEGRA_PIN_SGMII0_SMA_MDC_PC1,
+	TEGRA_PIN_PEX_WAKE_N_PC2,
+	TEGRA_PIN_PWM1_PA0,
+	TEGRA_PIN_PWM6_PA1,
+	TEGRA_PIN_PWM7_PA2,
+	TEGRA_PIN_PWM8_PA3,
+	TEGRA_PIN_UFS0_REF_CLK_PA4,
+	TEGRA_PIN_UFS0_RST_N_PA5,
+};
+
+enum {
+	TEGRA_PIN_SOC_GPIO250_PF0,
+	TEGRA_PIN_SOC_GPIO251_PF1,
+	TEGRA_PIN_SOC_GPIO252_PF2,
+	TEGRA_PIN_DP_AUX_CH0_HPD_PF3,
+	TEGRA_PIN_DP_AUX_CH1_HPD_PF4,
+	TEGRA_PIN_DP_AUX_CH2_HPD_PF5,
+	TEGRA_PIN_DP_AUX_CH3_HPD_PF6,
+	TEGRA_PIN_PWM2_PF7,
+	TEGRA_PIN_PWM3_PG0,
+	TEGRA_PIN_GEN7_I2C_SCL_PG1,
+	TEGRA_PIN_GEN7_I2C_SDA_PG2,
+	TEGRA_PIN_GEN9_I2C_SCL_PG3,
+	TEGRA_PIN_GEN9_I2C_SDA_PG4,
+	TEGRA_PIN_SDMMC1_CLK_PX0,
+	TEGRA_PIN_SDMMC1_CMD_PX1,
+	TEGRA_PIN_SDMMC1_DAT0_PX2,
+	TEGRA_PIN_SDMMC1_DAT1_PX3,
+	TEGRA_PIN_SDMMC1_DAT2_PX4,
+	TEGRA_PIN_SDMMC1_DAT3_PX5,
+	TEGRA_PIN_SDMMC1_COMP,
+	TEGRA_PIN_SOC_GPIO124_PL0,
+	TEGRA_PIN_SOC_GPIO125_PL1,
+	TEGRA_PIN_FAN_TACH0_PL2,
+	TEGRA_PIN_SOC_GPIO127_PL3,
+	TEGRA_PIN_SOC_GPIO128_PL4,
+	TEGRA_PIN_SOC_GPIO129_PL5,
+	TEGRA_PIN_SOC_GPIO130_PL6,
+	TEGRA_PIN_SOC_GPIO131_PL7,
+	TEGRA_PIN_GP_PWM9_PM0,
+	TEGRA_PIN_SOC_GPIO133_PM1,
+	TEGRA_PIN_UART9_TX_PM2,
+	TEGRA_PIN_UART9_RX_PM3,
+	TEGRA_PIN_UART9_RTS_N_PM4,
+	TEGRA_PIN_UART9_CTS_N_PM5,
+	TEGRA_PIN_SOC_GPIO170_PU0,
+	TEGRA_PIN_SOC_GPIO171_PU1,
+	TEGRA_PIN_SOC_GPIO172_PU2,
+	TEGRA_PIN_SOC_GPIO173_PU3,
+	TEGRA_PIN_SOC_GPIO174_PU4,
+	TEGRA_PIN_SOC_GPIO175_PU5,
+	TEGRA_PIN_SOC_GPIO176_PU6,
+	TEGRA_PIN_SOC_GPIO177_PU7,
+	TEGRA_PIN_SOC_GPIO178_PV0,
+	TEGRA_PIN_PWM10_PV1,
+	TEGRA_PIN_UART4_TX_PV2,
+	TEGRA_PIN_UART4_RX_PV3,
+	TEGRA_PIN_UART4_RTS_N_PV4,
+	TEGRA_PIN_UART4_CTS_N_PV5,
+	TEGRA_PIN_DAP2_CLK_PV6,
+	TEGRA_PIN_DAP2_DIN_PW0,
+	TEGRA_PIN_DAP2_DOUT_PV7,
+	TEGRA_PIN_DAP2_FS_PW1,
+	TEGRA_PIN_GEN1_I2C_SCL_PW2,
+	TEGRA_PIN_GEN1_I2C_SDA_PW3,
+	TEGRA_PIN_GEN0_I2C_SCL_PW4,
+	TEGRA_PIN_GEN0_I2C_SDA_PW5,
+	TEGRA_PIN_PWR_I2C_SCL_PW6,
+	TEGRA_PIN_PWR_I2C_SDA_PW7,
+	TEGRA_PIN_SOC_GPIO138_PP0,
+	TEGRA_PIN_SOC_GPIO139_PP1,
+	TEGRA_PIN_DAP6_SCLK_PP2,
+	TEGRA_PIN_DAP6_DOUT_PP3,
+	TEGRA_PIN_DAP6_DIN_PP4,
+	TEGRA_PIN_DAP6_FS_PP5,
+	TEGRA_PIN_DAP4_SCLK_PP6,
+	TEGRA_PIN_DAP4_DOUT_PP7,
+	TEGRA_PIN_DAP4_DIN_PQ0,
+	TEGRA_PIN_DAP4_FS_PQ1,
+	TEGRA_PIN_SPI5_SCK_PQ2,
+	TEGRA_PIN_SPI5_MISO_PQ3,
+	TEGRA_PIN_SPI5_MOSI_PQ4,
+	TEGRA_PIN_SPI5_CS0_PQ5,
+	TEGRA_PIN_SOC_GPIO152_PQ6,
+	TEGRA_PIN_SOC_GPIO153_PQ7,
+	TEGRA_PIN_AUD_MCLK_PR0,
+	TEGRA_PIN_SOC_GPIO155_PR1,
+	TEGRA_PIN_DAP1_SCLK_PR2,
+	TEGRA_PIN_DAP1_OUT_PR3,
+	TEGRA_PIN_DAP1_IN_PR4,
+	TEGRA_PIN_DAP1_FS_PR5,
+	TEGRA_PIN_GEN11_I2C_SCL_PR6,
+	TEGRA_PIN_GEN11_I2C_SDA_PR7,
+	TEGRA_PIN_SOC_GPIO350_PS0,
+	TEGRA_PIN_SOC_GPIO351_PS1,
+	TEGRA_PIN_QSPI0_SCK_PT0,
+	TEGRA_PIN_QSPI0_CS_N_PT1,
+	TEGRA_PIN_QSPI0_IO0_PT2,
+	TEGRA_PIN_QSPI0_IO1_PT3,
+	TEGRA_PIN_QSPI0_IO2_PT4,
+	TEGRA_PIN_QSPI0_IO3_PT5,
+	TEGRA_PIN_SOC_GPIO192_PT6,
+	TEGRA_PIN_SOC_GPIO270_PY0,
+	TEGRA_PIN_SOC_GPIO271_PY1,
+	TEGRA_PIN_SOC_GPIO272_PY2,
+	TEGRA_PIN_SOC_GPIO273_PY3,
+	TEGRA_PIN_SOC_GPIO274_PY4,
+	TEGRA_PIN_SOC_GPIO275_PY5,
+	TEGRA_PIN_SOC_GPIO276_PY6,
+	TEGRA_PIN_SOC_GPIO277_PY7,
+	TEGRA_PIN_SOC_GPIO278_PZ0,
+	TEGRA_PIN_SOC_GPIO279_PZ1,
+	TEGRA_PIN_XHALT_TRIG_PZ2,
+	TEGRA_PIN_SOC_GPIO281_PZ3,
+	TEGRA_PIN_SOC_GPIO282_PZ4,
+	TEGRA_PIN_SOC_GPIO283_PZ5,
+	TEGRA_PIN_SOC_GPIO284_PZ6,
+	TEGRA_PIN_SOC_GPIO285_PZ7,
+	TEGRA_PIN_SOC_GPIO286_PAL0,
+	TEGRA_PIN_SOC_GPIO287_PAL1,
+	TEGRA_PIN_SOC_GPIO288_PAL2,
+	TEGRA_PIN_CPU_PWR_REQ_PH0,
+	TEGRA_PIN_GPU_PWR_REQ_PH1,
+	TEGRA_PIN_UART10_TX_PH2,
+	TEGRA_PIN_UART10_RX_PH3,
+	TEGRA_PIN_UART10_RTS_N_PH4,
+	TEGRA_PIN_UART10_CTS_N_PH5,
+	TEGRA_PIN_SPI3_SCK_PH6,
+	TEGRA_PIN_SPI3_MISO_PH7,
+	TEGRA_PIN_SPI3_MOSI_PJ0,
+	TEGRA_PIN_SPI3_CS0_PJ1,
+	TEGRA_PIN_SPI3_CS3_PJ2,
+	TEGRA_PIN_UART5_TX_PJ3,
+	TEGRA_PIN_UART5_RX_PJ4,
+	TEGRA_PIN_UART5_RTS_N_PJ5,
+	TEGRA_PIN_UART5_CTS_N_PJ6,
+	TEGRA_PIN_SPI1_SCK_PJ7,
+	TEGRA_PIN_SPI1_MISO_PK0,
+	TEGRA_PIN_SPI1_MOSI_PK1,
+	TEGRA_PIN_SPI1_CS0_PK2,
+	TEGRA_PIN_SPI1_CS1_PK3,
+	TEGRA_PIN_EXTPERIPH1_CLK_PK4,
+	TEGRA_PIN_EXTPERIPH2_CLK_PK5,
+	TEGRA_PIN_GEN12_I2C_SCL_PK6,
+	TEGRA_PIN_GEN12_I2C_SDA_PK7,
+};
+
+enum {
+	TEGRA_PIN_SOC_GPIO00_PAA0,
+	TEGRA_PIN_VCOMP_ALERT_PAA1,
+	TEGRA_PIN_AO_RETENTION_N_PAA2,
+	TEGRA_PIN_BATT_OC_PAA3,
+	TEGRA_PIN_BOOTV_CTL_N_PAA4,
+	TEGRA_PIN_POWER_ON_PAA5,
+	TEGRA_PIN_HDMI_CEC_PAA6,
+	TEGRA_PIN_SOC_GPIO07_PAA7,
+	TEGRA_PIN_SOC_GPIO08_PBB0,
+	TEGRA_PIN_SOC_GPIO09_PBB1,
+	TEGRA_PIN_GEN2_I2C_SCL_PCC0,
+	TEGRA_PIN_GEN2_I2C_SDA_PCC1,
+	TEGRA_PIN_GEN3_I2C_SCL_PCC2,
+	TEGRA_PIN_GEN3_I2C_SDA_PCC3,
+	TEGRA_PIN_GP_PWM4_PCC4,
+	TEGRA_PIN_UART0_TX_PCC5,
+	TEGRA_PIN_UART0_RX_PCC6,
+	TEGRA_PIN_SPI2_SCK_PCC7,
+	TEGRA_PIN_SPI2_MISO_PDD0,
+	TEGRA_PIN_SPI2_MOSI_PDD1,
+	TEGRA_PIN_SPI2_CS0_N_PDD2,
+	TEGRA_PIN_SOC_GPIO21_PDD3,
+	TEGRA_PIN_SOC_GPIO22_PDD4,
+	TEGRA_PIN_SOC_GPIO23_PDD5,
+	TEGRA_PIN_SOC_GPIO24_PDD6,
+	TEGRA_PIN_SOC_GPIO25_PDD7,
+	TEGRA_PIN_SOC_GPIO26_PEE0,
+	TEGRA_PIN_SOC_GPIO27_PEE1,
+	TEGRA_PIN_SOC_GPIO28_PEE2,
+	TEGRA_PIN_SOC_GPIO29_PEE3,
+};
+
+static const struct pinctrl_pin_desc tegra264_uphy_pins[] = {
+	PINCTRL_PIN(TEGRA_PIN_PEX_L4_CLKREQ_N_PD0, "PEX_L4_CLKREQ_N_PD0"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L4_RST_N_PD1, "PEX_L4_RST_N_PD1"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L5_CLKREQ_N_PD2, "PEX_L5_CLKREQ_N_PD2"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L5_RST_N_PD3, "PEX_L5_RST_N_PD3"),
+	PINCTRL_PIN(TEGRA_PIN_ETH0_MDIO_PD4, "ETH0_MDIO_PD4"),
+	PINCTRL_PIN(TEGRA_PIN_ETH0_MDC_PD5, "ETH0_MDC_PD5"),
+	PINCTRL_PIN(TEGRA_PIN_ETH3_MDIO_PD6, "ETH3_MDIO_PD6"),
+	PINCTRL_PIN(TEGRA_PIN_ETH3_MDC_PD7, "ETH3_MDC_PD7"),
+	PINCTRL_PIN(TEGRA_PIN_ETH1_MDIO_PE0, "ETH1_MDIO_PE0"),
+	PINCTRL_PIN(TEGRA_PIN_ETH1_MDC_PE1, "ETH1_MDC_PE1"),
+	PINCTRL_PIN(TEGRA_PIN_ETH2_MDIO_PE2, "ETH2_MDIO_PE2"),
+	PINCTRL_PIN(TEGRA_PIN_ETH2_MDC_PE3, "ETH2_MDC_PE3"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L1_CLKREQ_N_PB0, "PEX_L1_CLKREQ_N_PB0"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L1_RST_N_PB1, "PEX_L1_RST_N_PB1"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L2_CLKREQ_N_PB2, "PEX_L2_CLKREQ_N_PB2"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L2_RST_N_PB3, "PEX_L2_RST_N_PB3"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L3_CLKREQ_N_PB4, "PEX_L3_CLKREQ_N_PB4"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_L3_RST_N_PB5, "PEX_L3_RST_N_PB5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO113_PB6, "SOC_GPIO113_PB6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO114_PB7, "SOC_GPIO114_PB7"),
+	PINCTRL_PIN(TEGRA_PIN_SGMII0_SMA_MDIO_PC0, "SGMII0_SMA_MDIO_PC0"),
+	PINCTRL_PIN(TEGRA_PIN_SGMII0_SMA_MDC_PC1, "SGMII0_SMA_MDC_PC1"),
+	PINCTRL_PIN(TEGRA_PIN_PEX_WAKE_N_PC2, "PEX_WAKE_N_PC2"),
+	PINCTRL_PIN(TEGRA_PIN_PWM1_PA0, "PWM1_PA0"),
+	PINCTRL_PIN(TEGRA_PIN_PWM6_PA1, "PWM6_PA1"),
+	PINCTRL_PIN(TEGRA_PIN_PWM7_PA2, "PWM7_PA2"),
+	PINCTRL_PIN(TEGRA_PIN_PWM8_PA3, "PWM8_PA3"),
+	PINCTRL_PIN(TEGRA_PIN_UFS0_REF_CLK_PA4, "UFS0_REF_CLK_PA4"),
+	PINCTRL_PIN(TEGRA_PIN_UFS0_RST_N_PA5, "UFS0_RST_N_PA5"),
+};
+
+static const struct pinctrl_pin_desc tegra264_main_pins[] = {
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO250_PF0, "SOC_GPIO250_PF0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO251_PF1, "SOC_GPIO251_PF1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO252_PF2, "SOC_GPIO252_PF2"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH0_HPD_PF3, "DP_AUX_CH0_HPD_PF3"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH1_HPD_PF4, "DP_AUX_CH1_HPD_PF4"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH2_HPD_PF5, "DP_AUX_CH2_HPD_PF5"),
+	PINCTRL_PIN(TEGRA_PIN_DP_AUX_CH3_HPD_PF6, "DP_AUX_CH3_HPD_PF6"),
+	PINCTRL_PIN(TEGRA_PIN_PWM2_PF7, "PWM2_PF7"),
+	PINCTRL_PIN(TEGRA_PIN_PWM3_PG0, "PWM3_PG0"),
+	PINCTRL_PIN(TEGRA_PIN_GEN7_I2C_SCL_PG1, "GEN7_I2C_SCL_PG1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN7_I2C_SDA_PG2, "GEN7_I2C_SDA_PG2"),
+	PINCTRL_PIN(TEGRA_PIN_GEN9_I2C_SCL_PG3, "GEN9_I2C_SCL_PG3"),
+	PINCTRL_PIN(TEGRA_PIN_GEN9_I2C_SDA_PG4, "GEN9_I2C_SDA_PG4"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_CLK_PX0, "SDMMC1_CLK_PX0"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_CMD_PX1, "SDMMC1_CMD_PX1"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT0_PX2, "SDMMC1_DAT0_PX2"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT1_PX3, "SDMMC1_DAT1_PX3"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT2_PX4, "SDMMC1_DAT2_PX4"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_DAT3_PX5, "SDMMC1_DAT3_PX5"),
+	PINCTRL_PIN(TEGRA_PIN_SDMMC1_COMP, "SDMMC1_COMP"),
+	PINCTRL_PIN(TEGRA_PIN_CPU_PWR_REQ_PH0, "CPU_PWR_REQ_PH0"),
+	PINCTRL_PIN(TEGRA_PIN_GPU_PWR_REQ_PH1, "GPU_PWR_REQ_PH1"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_TX_PH2, "UART10_TX_PH2"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_RX_PH3, "UART10_RX_PH3"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_RTS_N_PH4, "UART10_RTS_N_PH4"),
+	PINCTRL_PIN(TEGRA_PIN_UART10_CTS_N_PH5, "UART10_CTS_N_PH5"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_SCK_PH6, "SPI3_SCK_PH6"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_MISO_PH7, "SPI3_MISO_PH7"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_MOSI_PJ0, "SPI3_MOSI_PJ0"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_CS0_PJ1, "SPI3_CS0_PJ1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI3_CS3_PJ2, "SPI3_CS3_PJ2"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_TX_PJ3, "UART5_TX_PJ3"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_RX_PJ4, "UART5_RX_PJ4"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_RTS_N_PJ5, "UART5_RTS_N_PJ5"),
+	PINCTRL_PIN(TEGRA_PIN_UART5_CTS_N_PJ6, "UART5_CTS_N_PJ6"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_SCK_PJ7, "SPI1_SCK_PJ7"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_MISO_PK0, "SPI1_MISO_PK0"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_MOSI_PK1, "SPI1_MOSI_PK1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_CS0_PK2, "SPI1_CS0_PK2"),
+	PINCTRL_PIN(TEGRA_PIN_SPI1_CS1_PK3, "SPI1_CS1_PK3"),
+	PINCTRL_PIN(TEGRA_PIN_EXTPERIPH1_CLK_PK4, "EXTPERIPH1_CLK_PK4"),
+	PINCTRL_PIN(TEGRA_PIN_EXTPERIPH2_CLK_PK5, "EXTPERIPH2_CLK_PK5"),
+	PINCTRL_PIN(TEGRA_PIN_GEN12_I2C_SCL_PK6, "GEN12_I2C_SCL_PK6"),
+	PINCTRL_PIN(TEGRA_PIN_GEN12_I2C_SDA_PK7, "GEN12_I2C_SDA_PK7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO124_PL0, "SOC_GPIO124_PL0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO125_PL1, "SOC_GPIO125_PL1"),
+	PINCTRL_PIN(TEGRA_PIN_FAN_TACH0_PL2, "FAN_TACH0_PL2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO127_PL3, "SOC_GPIO127_PL3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO128_PL4, "SOC_GPIO128_PL4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO129_PL5, "SOC_GPIO129_PL5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO130_PL6, "SOC_GPIO130_PL6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO131_PL7, "SOC_GPIO131_PL7"),
+	PINCTRL_PIN(TEGRA_PIN_GP_PWM9_PM0, "GP_PWM9_PM0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO133_PM1, "SOC_GPIO133_PM1"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_TX_PM2, "UART9_TX_PM2"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_RX_PM3, "UART9_RX_PM3"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_RTS_N_PM4, "UART9_RTS_N_PM4"),
+	PINCTRL_PIN(TEGRA_PIN_UART9_CTS_N_PM5, "UART9_CTS_N_PM5"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_SCK_PT0, "QSPI0_SCK_PT0"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_CS_N_PT1, "QSPI0_CS_N_PT1"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO0_PT2, "QSPI0_IO0_PT2"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO1_PT3, "QSPI0_IO1_PT3"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO2_PT4, "QSPI0_IO2_PT4"),
+	PINCTRL_PIN(TEGRA_PIN_QSPI0_IO3_PT5, "QSPI0_IO3_PT5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO192_PT6, "SOC_GPIO192_PT6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO170_PU0, "SOC_GPIO170_PU0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO171_PU1, "SOC_GPIO171_PU1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO172_PU2, "SOC_GPIO172_PU2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO173_PU3, "SOC_GPIO173_PU3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO174_PU4, "SOC_GPIO174_PU4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO175_PU5, "SOC_GPIO175_PU5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO176_PU6, "SOC_GPIO176_PU6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO177_PU7, "SOC_GPIO177_PU7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO178_PV0, "SOC_GPIO178_PV0"),
+	PINCTRL_PIN(TEGRA_PIN_PWM10_PV1, "PWM10_PV1"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_TX_PV2, "UART4_TX_PV2"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_RX_PV3, "UART4_RX_PV3"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_RTS_N_PV4, "UART4_RTS_N_PV4"),
+	PINCTRL_PIN(TEGRA_PIN_UART4_CTS_N_PV5, "UART4_CTS_N_PV5"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_CLK_PV6, "DAP2_CLK_PV6"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_DIN_PW0, "DAP2_DIN_PW0"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_DOUT_PV7, "DAP2_DOUT_PV7"),
+	PINCTRL_PIN(TEGRA_PIN_DAP2_FS_PW1, "DAP2_FS_PW1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN1_I2C_SCL_PW2, "GEN1_I2C_SCL_PW2"),
+	PINCTRL_PIN(TEGRA_PIN_GEN1_I2C_SDA_PW3, "GEN1_I2C_SDA_PW3"),
+	PINCTRL_PIN(TEGRA_PIN_GEN0_I2C_SCL_PW4, "GEN0_I2C_SCL_PW4"),
+	PINCTRL_PIN(TEGRA_PIN_GEN0_I2C_SDA_PW5, "GEN0_I2C_SDA_PW5"),
+	PINCTRL_PIN(TEGRA_PIN_PWR_I2C_SCL_PW6, "PWR_I2C_SCL_PW6"),
+	PINCTRL_PIN(TEGRA_PIN_PWR_I2C_SDA_PW7, "PWR_I2C_SDA_PW7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO270_PY0, "SOC_GPIO270_PY0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO271_PY1, "SOC_GPIO271_PY1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO272_PY2, "SOC_GPIO272_PY2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO273_PY3, "SOC_GPIO273_PY3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO274_PY4, "SOC_GPIO274_PY4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO275_PY5, "SOC_GPIO275_PY5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO276_PY6, "SOC_GPIO276_PY6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO277_PY7, "SOC_GPIO277_PY7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO278_PZ0, "SOC_GPIO278_PZ0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO279_PZ1, "SOC_GPIO279_PZ1"),
+	PINCTRL_PIN(TEGRA_PIN_XHALT_TRIG_PZ2, "XHALT_TRIG_PZ2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO281_PZ3, "SOC_GPIO281_PZ3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO282_PZ4, "SOC_GPIO282_PZ4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO283_PZ5, "SOC_GPIO283_PZ5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO284_PZ6, "SOC_GPIO284_PZ6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO285_PZ7, "SOC_GPIO285_PZ7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO286_PAL0, "SOC_GPIO286_PAL0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO287_PAL1, "SOC_GPIO287_PAL1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO288_PAL2, "SOC_GPIO288_PAL2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO138_PP0, "SOC_GPIO138_PP0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO139_PP1, "SOC_GPIO139_PP1"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_SCLK_PP2, "DAP6_SCLK_PP2"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_DOUT_PP3, "DAP6_DOUT_PP3"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_DIN_PP4, "DAP6_DIN_PP4"),
+	PINCTRL_PIN(TEGRA_PIN_DAP6_FS_PP5, "DAP6_FS_PP5"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_SCLK_PP6, "DAP4_SCLK_PP6"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_DOUT_PP7, "DAP4_DOUT_PP7"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_DIN_PQ0, "DAP4_DIN_PQ0"),
+	PINCTRL_PIN(TEGRA_PIN_DAP4_FS_PQ1, "DAP4_FS_PQ1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_SCK_PQ2, "SPI5_SCK_PQ2"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_MISO_PQ3, "SPI5_MISO_PQ3"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_MOSI_PQ4, "SPI5_MOSI_PQ4"),
+	PINCTRL_PIN(TEGRA_PIN_SPI5_CS0_PQ5, "SPI5_CS0_PQ5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO152_PQ6, "SOC_GPIO152_PQ6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO153_PQ7, "SOC_GPIO153_PQ7"),
+	PINCTRL_PIN(TEGRA_PIN_AUD_MCLK_PR0, "AUD_MCLK_PR0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO155_PR1, "SOC_GPIO155_PR1"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_SCLK_PR2, "DAP1_SCLK_PR2"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_OUT_PR3, "DAP1_OUT_PR3"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_IN_PR4, "DAP1_IN_PR4"),
+	PINCTRL_PIN(TEGRA_PIN_DAP1_FS_PR5, "DAP1_FS_PR5"),
+	PINCTRL_PIN(TEGRA_PIN_GEN11_I2C_SCL_PR6, "GEN11_I2C_SCL_PR6"),
+	PINCTRL_PIN(TEGRA_PIN_GEN11_I2C_SDA_PR7, "GEN11_I2C_SDA_PR7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO350_PS0, "SOC_GPIO350_PS0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO351_PS1, "SOC_GPIO351_PS1"),
+
+};
+
+static const struct pinctrl_pin_desc tegra264_aon_pins[] = {
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO00_PAA0, "SOC_GPIO00_PAA0"),
+	PINCTRL_PIN(TEGRA_PIN_VCOMP_ALERT_PAA1, "VCOMP_ALERT_PAA1"),
+	PINCTRL_PIN(TEGRA_PIN_AO_RETENTION_N_PAA2, "AO_RETENTION_N_PAA2"),
+	PINCTRL_PIN(TEGRA_PIN_BATT_OC_PAA3, "BATT_OC_PAA3"),
+	PINCTRL_PIN(TEGRA_PIN_BOOTV_CTL_N_PAA4, "BOOTV_CTL_N_PAA4"),
+	PINCTRL_PIN(TEGRA_PIN_POWER_ON_PAA5, "POWER_ON_PAA5"),
+	PINCTRL_PIN(TEGRA_PIN_HDMI_CEC_PAA6, "HDMI_CEC_PAA6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO07_PAA7, "SOC_GPIO07_PAA7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO08_PBB0, "SOC_GPIO08_PBB0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO09_PBB1, "SOC_GPIO09_PBB1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN2_I2C_SCL_PCC0, "GEN2_I2C_SCL_PCC0"),
+	PINCTRL_PIN(TEGRA_PIN_GEN2_I2C_SDA_PCC1, "GEN2_I2C_SDA_PCC1"),
+	PINCTRL_PIN(TEGRA_PIN_GEN3_I2C_SCL_PCC2, "GEN3_I2C_SCL_PCC2"),
+	PINCTRL_PIN(TEGRA_PIN_GEN3_I2C_SDA_PCC3, "GEN3_I2C_SDA_PCC3"),
+	PINCTRL_PIN(TEGRA_PIN_GP_PWM4_PCC4, "GP_PWM4_PCC4"),
+	PINCTRL_PIN(TEGRA_PIN_UART0_TX_PCC5, "UART0_TX_PCC5"),
+	PINCTRL_PIN(TEGRA_PIN_UART0_RX_PCC6, "UART0_RX_PCC6"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_SCK_PCC7, "SPI2_SCK_PCC7"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_MISO_PDD0, "SPI2_MISO_PDD0"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_MOSI_PDD1, "SPI2_MOSI_PDD1"),
+	PINCTRL_PIN(TEGRA_PIN_SPI2_CS0_N_PDD2, "SPI2_CS0_N_PDD2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO21_PDD3, "SOC_GPIO21_PDD3"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO22_PDD4, "SOC_GPIO22_PDD4"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO23_PDD5, "SOC_GPIO23_PDD5"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO24_PDD6, "SOC_GPIO24_PDD6"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO25_PDD7, "SOC_GPIO25_PDD7"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO26_PEE0, "SOC_GPIO26_PEE0"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO27_PEE1, "SOC_GPIO27_PEE1"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO28_PEE2, "SOC_GPIO28_PEE2"),
+	PINCTRL_PIN(TEGRA_PIN_SOC_GPIO29_PEE3, "SOC_GPIO29_PEE3"),
+};
+
+
+static const unsigned int soc_gpio250_pf0_pins[] = {
+		TEGRA_PIN_SOC_GPIO250_PF0,
+};
+
+static const unsigned int soc_gpio251_pf1_pins[] = {
+	TEGRA_PIN_SOC_GPIO251_PF1,
+};
+
+static const unsigned int soc_gpio252_pf2_pins[] = {
+	TEGRA_PIN_SOC_GPIO252_PF2,
+};
+
+static const unsigned int dp_aux_ch0_hpd_pf3_pins[] = {
+	TEGRA_PIN_DP_AUX_CH0_HPD_PF3,
+};
+
+static const unsigned int dp_aux_ch1_hpd_pf4_pins[] = {
+	TEGRA_PIN_DP_AUX_CH1_HPD_PF4,
+};
+
+static const unsigned int dp_aux_ch2_hpd_pf5_pins[] = {
+	TEGRA_PIN_DP_AUX_CH2_HPD_PF5,
+};
+
+static const unsigned int dp_aux_ch3_hpd_pf6_pins[] = {
+	TEGRA_PIN_DP_AUX_CH3_HPD_PF6,
+};
+
+static const unsigned int pwm2_pf7_pins[] = {
+	TEGRA_PIN_PWM2_PF7,
+};
+
+static const unsigned int pwm3_pg0_pins[] = {
+	TEGRA_PIN_PWM3_PG0,
+};
+
+static const unsigned int gen7_i2c_scl_pg1_pins[] = {
+	TEGRA_PIN_GEN7_I2C_SCL_PG1,
+};
+
+static const unsigned int gen7_i2c_sda_pg2_pins[] = {
+	TEGRA_PIN_GEN7_I2C_SDA_PG2,
+};
+
+static const unsigned int gen9_i2c_scl_pg3_pins[] = {
+	TEGRA_PIN_GEN9_I2C_SCL_PG3,
+};
+
+static const unsigned int gen9_i2c_sda_pg4_pins[] = {
+	TEGRA_PIN_GEN9_I2C_SDA_PG4,
+};
+
+static const unsigned int pwm1_pa0_pins[] = {
+	TEGRA_PIN_PWM1_PA0,
+};
+
+static const unsigned int pwm6_pa1_pins[] = {
+	TEGRA_PIN_PWM6_PA1,
+};
+
+static const unsigned int pwm7_pa2_pins[] = {
+	TEGRA_PIN_PWM7_PA2,
+};
+
+static const unsigned int pwm8_pa3_pins[] = {
+	TEGRA_PIN_PWM8_PA3,
+};
+
+static const unsigned int ufs0_ref_clk_pa4_pins[] = {
+	TEGRA_PIN_UFS0_REF_CLK_PA4,
+};
+
+static const unsigned int ufs0_rst_n_pa5_pins[] = {
+	TEGRA_PIN_UFS0_RST_N_PA5,
+};
+
+
+static const unsigned int pex_l1_clkreq_n_pb0_pins[] = {
+	TEGRA_PIN_PEX_L1_CLKREQ_N_PB0,
+};
+
+static const unsigned int pex_l1_rst_n_pb1_pins[] = {
+	TEGRA_PIN_PEX_L1_RST_N_PB1,
+};
+
+static const unsigned int pex_l2_clkreq_n_pb2_pins[] = {
+	TEGRA_PIN_PEX_L2_CLKREQ_N_PB2,
+};
+
+static const unsigned int pex_l2_rst_n_pb3_pins[] = {
+	TEGRA_PIN_PEX_L2_RST_N_PB3,
+};
+
+static const unsigned int pex_l3_clkreq_n_pb4_pins[] = {
+	TEGRA_PIN_PEX_L3_CLKREQ_N_PB4,
+};
+
+static const unsigned int pex_l3_rst_n_pb5_pins[] = {
+	TEGRA_PIN_PEX_L3_RST_N_PB5,
+};
+
+static const unsigned int soc_gpio113_pb6_pins[] = {
+	TEGRA_PIN_SOC_GPIO113_PB6,
+};
+
+static const unsigned int soc_gpio114_pb7_pins[] = {
+	TEGRA_PIN_SOC_GPIO114_PB7,
+};
+
+static const unsigned int sgmii0_sma_mdio_pc0_pins[] = {
+	TEGRA_PIN_SGMII0_SMA_MDIO_PC0,
+};
+
+static const unsigned int sgmii0_sma_mdc_pc1_pins[] = {
+	TEGRA_PIN_SGMII0_SMA_MDC_PC1,
+};
+
+static const unsigned int pex_wake_n_pc2_pins[] = {
+	TEGRA_PIN_PEX_WAKE_N_PC2,
+};
+
+
+static const unsigned int pex_l4_clkreq_n_pd0_pins[] = {
+	TEGRA_PIN_PEX_L4_CLKREQ_N_PD0,
+};
+
+static const unsigned int pex_l4_rst_n_pd1_pins[] = {
+	TEGRA_PIN_PEX_L4_RST_N_PD1,
+};
+
+static const unsigned int pex_l5_clkreq_n_pd2_pins[] = {
+	TEGRA_PIN_PEX_L5_CLKREQ_N_PD2,
+};
+
+static const unsigned int pex_l5_rst_n_pd3_pins[] = {
+	TEGRA_PIN_PEX_L5_RST_N_PD3,
+};
+
+static const unsigned int eth0_mdio_pd4_pins[] = {
+	TEGRA_PIN_ETH0_MDIO_PD4,
+};
+
+static const unsigned int eth0_mdc_pd5_pins[] = {
+	TEGRA_PIN_ETH0_MDC_PD5,
+};
+
+static const unsigned int eth3_mdio_pd6_pins[] = {
+	TEGRA_PIN_ETH3_MDIO_PD6,
+};
+
+static const unsigned int eth3_mdc_pd7_pins[] = {
+	TEGRA_PIN_ETH3_MDC_PD7,
+};
+
+static const unsigned int eth1_mdio_pe0_pins[] = {
+	TEGRA_PIN_ETH1_MDIO_PE0,
+};
+
+static const unsigned int eth1_mdc_pe1_pins[] = {
+	TEGRA_PIN_ETH1_MDC_PE1,
+};
+
+static const unsigned int eth2_mdio_pe2_pins[] = {
+	TEGRA_PIN_ETH2_MDIO_PE2,
+};
+
+static const unsigned int eth2_mdc_pe3_pins[] = {
+	TEGRA_PIN_ETH2_MDC_PE3,
+};
+
+
+static const unsigned int sdmmc1_clk_px0_pins[] = {
+	TEGRA_PIN_SDMMC1_CLK_PX0,
+};
+
+static const unsigned int sdmmc1_cmd_px1_pins[] = {
+	TEGRA_PIN_SDMMC1_CMD_PX1,
+};
+
+static const unsigned int sdmmc1_dat0_px2_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT0_PX2,
+};
+
+static const unsigned int sdmmc1_dat1_px3_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT1_PX3,
+};
+
+static const unsigned int sdmmc1_dat2_px4_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT2_PX4,
+};
+
+static const unsigned int sdmmc1_dat3_px5_pins[] = {
+	TEGRA_PIN_SDMMC1_DAT3_PX5,
+};
+
+static const unsigned int sdmmc1_comp_pins[] = {
+	TEGRA_PIN_SDMMC1_COMP,
+};
+
+static const unsigned int cpu_pwr_req_ph0_pins[] = {
+	TEGRA_PIN_CPU_PWR_REQ_PH0,
+};
+
+static const unsigned int gpu_pwr_req_ph1_pins[] = {
+	TEGRA_PIN_GPU_PWR_REQ_PH1,
+};
+
+static const unsigned int uart10_tx_ph2_pins[] = {
+	TEGRA_PIN_UART10_TX_PH2,
+};
+
+static const unsigned int uart10_rx_ph3_pins[] = {
+	TEGRA_PIN_UART10_RX_PH3,
+};
+
+static const unsigned int uart10_rts_n_ph4_pins[] = {
+	TEGRA_PIN_UART10_RTS_N_PH4,
+};
+
+static const unsigned int uart10_cts_n_ph5_pins[] = {
+	TEGRA_PIN_UART10_CTS_N_PH5,
+};
+
+static const unsigned int spi3_sck_ph6_pins[] = {
+	TEGRA_PIN_SPI3_SCK_PH6,
+};
+
+static const unsigned int spi3_miso_ph7_pins[] = {
+	TEGRA_PIN_SPI3_MISO_PH7,
+};
+
+static const unsigned int spi3_mosi_pj0_pins[] = {
+	TEGRA_PIN_SPI3_MOSI_PJ0,
+};
+
+static const unsigned int spi3_cs0_pj1_pins[] = {
+	TEGRA_PIN_SPI3_CS0_PJ1,
+};
+
+static const unsigned int spi3_cs3_pj2_pins[] = {
+	TEGRA_PIN_SPI3_CS3_PJ2,
+};
+
+static const unsigned int uart5_tx_pj3_pins[] = {
+	TEGRA_PIN_UART5_TX_PJ3,
+};
+
+static const unsigned int uart5_rx_pj4_pins[] = {
+	TEGRA_PIN_UART5_RX_PJ4,
+};
+
+static const unsigned int uart5_rts_n_pj5_pins[] = {
+	TEGRA_PIN_UART5_RTS_N_PJ5,
+};
+
+static const unsigned int uart5_cts_n_pj6_pins[] = {
+	TEGRA_PIN_UART5_CTS_N_PJ6,
+};
+
+static const unsigned int spi1_sck_pj7_pins[] = {
+	TEGRA_PIN_SPI1_SCK_PJ7,
+};
+
+static const unsigned int spi1_miso_pk0_pins[] = {
+	TEGRA_PIN_SPI1_MISO_PK0,
+};
+
+static const unsigned int spi1_mosi_pk1_pins[] = {
+	TEGRA_PIN_SPI1_MOSI_PK1,
+};
+
+static const unsigned int spi1_cs0_pk2_pins[] = {
+	TEGRA_PIN_SPI1_CS0_PK2,
+};
+
+static const unsigned int spi1_cs1_pk3_pins[] = {
+	TEGRA_PIN_SPI1_CS1_PK3,
+};
+
+static const unsigned int extperiph1_clk_pk4_pins[] = {
+	TEGRA_PIN_EXTPERIPH1_CLK_PK4,
+};
+
+static const unsigned int extperiph2_clk_pk5_pins[] = {
+	TEGRA_PIN_EXTPERIPH2_CLK_PK5,
+};
+
+static const unsigned int gen12_i2c_scl_pk6_pins[] = {
+	TEGRA_PIN_GEN12_I2C_SCL_PK6,
+};
+
+static const unsigned int gen12_i2c_sda_pk7_pins[] = {
+	TEGRA_PIN_GEN12_I2C_SDA_PK7,
+};
+
+
+static const unsigned int soc_gpio124_pl0_pins[] = {
+	TEGRA_PIN_SOC_GPIO124_PL0,
+};
+
+static const unsigned int soc_gpio125_pl1_pins[] = {
+	TEGRA_PIN_SOC_GPIO125_PL1,
+};
+
+static const unsigned int fan_tach0_pl2_pins[] = {
+	TEGRA_PIN_FAN_TACH0_PL2,
+};
+
+static const unsigned int soc_gpio127_pl3_pins[] = {
+	TEGRA_PIN_SOC_GPIO127_PL3,
+};
+
+static const unsigned int soc_gpio128_pl4_pins[] = {
+	TEGRA_PIN_SOC_GPIO128_PL4,
+};
+
+static const unsigned int soc_gpio129_pl5_pins[] = {
+	TEGRA_PIN_SOC_GPIO129_PL5,
+};
+
+static const unsigned int soc_gpio130_pl6_pins[] = {
+	TEGRA_PIN_SOC_GPIO130_PL6,
+};
+
+static const unsigned int soc_gpio131_pl7_pins[] = {
+	TEGRA_PIN_SOC_GPIO131_PL7,
+};
+
+static const unsigned int gp_pwm9_pm0_pins[] = {
+	TEGRA_PIN_GP_PWM9_PM0,
+};
+
+static const unsigned int soc_gpio133_pm1_pins[] = {
+	TEGRA_PIN_SOC_GPIO133_PM1,
+};
+
+static const unsigned int uart9_tx_pm2_pins[] = {
+	TEGRA_PIN_UART9_TX_PM2,
+};
+
+static const unsigned int uart9_rx_pm3_pins[] = {
+	TEGRA_PIN_UART9_RX_PM3,
+};
+
+static const unsigned int uart9_rts_n_pm4_pins[] = {
+	TEGRA_PIN_UART9_RTS_N_PM4,
+};
+
+static const unsigned int uart9_cts_n_pm5_pins[] = {
+	TEGRA_PIN_UART9_CTS_N_PM5,
+};
+
+
+static const unsigned int soc_gpio170_pu0_pins[] = {
+	TEGRA_PIN_SOC_GPIO170_PU0,
+};
+
+static const unsigned int soc_gpio171_pu1_pins[] = {
+	TEGRA_PIN_SOC_GPIO171_PU1,
+};
+
+static const unsigned int soc_gpio172_pu2_pins[] = {
+	TEGRA_PIN_SOC_GPIO172_PU2,
+};
+
+static const unsigned int soc_gpio173_pu3_pins[] = {
+	TEGRA_PIN_SOC_GPIO173_PU3,
+};
+
+static const unsigned int soc_gpio174_pu4_pins[] = {
+	TEGRA_PIN_SOC_GPIO174_PU4,
+};
+
+static const unsigned int soc_gpio175_pu5_pins[] = {
+	TEGRA_PIN_SOC_GPIO175_PU5,
+};
+
+static const unsigned int soc_gpio176_pu6_pins[] = {
+	TEGRA_PIN_SOC_GPIO176_PU6,
+};
+
+static const unsigned int soc_gpio177_pu7_pins[] = {
+	TEGRA_PIN_SOC_GPIO177_PU7,
+};
+
+static const unsigned int soc_gpio178_pv0_pins[] = {
+	TEGRA_PIN_SOC_GPIO178_PV0,
+};
+
+static const unsigned int pwm10_pv1_pins[] = {
+	TEGRA_PIN_PWM10_PV1,
+};
+
+static const unsigned int uart4_tx_pv2_pins[] = {
+	TEGRA_PIN_UART4_TX_PV2,
+};
+
+static const unsigned int uart4_rx_pv3_pins[] = {
+	TEGRA_PIN_UART4_RX_PV3,
+};
+
+static const unsigned int uart4_rts_n_pv4_pins[] = {
+	TEGRA_PIN_UART4_RTS_N_PV4,
+};
+
+static const unsigned int uart4_cts_n_pv5_pins[] = {
+	TEGRA_PIN_UART4_CTS_N_PV5,
+};
+
+static const unsigned int dap2_clk_pv6_pins[] = {
+	TEGRA_PIN_DAP2_CLK_PV6,
+};
+
+static const unsigned int dap2_dout_pv7_pins[] = {
+	TEGRA_PIN_DAP2_DOUT_PV7,
+};
+
+static const unsigned int dap2_din_pw0_pins[] = {
+	TEGRA_PIN_DAP2_DIN_PW0,
+};
+
+static const unsigned int dap2_fs_pw1_pins[] = {
+	TEGRA_PIN_DAP2_FS_PW1,
+};
+
+static const unsigned int gen1_i2c_scl_pw2_pins[] = {
+	TEGRA_PIN_GEN1_I2C_SCL_PW2,
+};
+
+static const unsigned int gen1_i2c_sda_pw3_pins[] = {
+	TEGRA_PIN_GEN1_I2C_SDA_PW3,
+};
+
+static const unsigned int gen0_i2c_scl_pw4_pins[] = {
+	TEGRA_PIN_GEN0_I2C_SCL_PW4,
+};
+
+static const unsigned int gen0_i2c_sda_pw5_pins[] = {
+	TEGRA_PIN_GEN0_I2C_SDA_PW5,
+};
+
+static const unsigned int pwr_i2c_scl_pw6_pins[] = {
+	TEGRA_PIN_PWR_I2C_SCL_PW6,
+};
+
+static const unsigned int pwr_i2c_sda_pw7_pins[] = {
+	TEGRA_PIN_PWR_I2C_SDA_PW7,
+};
+
+
+static const unsigned int qspi0_sck_pt0_pins[] = {
+	TEGRA_PIN_QSPI0_SCK_PT0,
+};
+
+static const unsigned int qspi0_cs_n_pt1_pins[] = {
+	TEGRA_PIN_QSPI0_CS_N_PT1,
+};
+
+static const unsigned int qspi0_io0_pt2_pins[] = {
+	TEGRA_PIN_QSPI0_IO0_PT2,
+};
+
+static const unsigned int qspi0_io1_pt3_pins[] = {
+	TEGRA_PIN_QSPI0_IO1_PT3,
+};
+
+static const unsigned int qspi0_io2_pt4_pins[] = {
+	TEGRA_PIN_QSPI0_IO2_PT4,
+};
+
+static const unsigned int qspi0_io3_pt5_pins[] = {
+	TEGRA_PIN_QSPI0_IO3_PT5,
+};
+
+static const unsigned int soc_gpio192_pt6_pins[] = {
+	TEGRA_PIN_SOC_GPIO192_PT6,
+};
+
+
+static const unsigned int soc_gpio138_pp0_pins[] = {
+	TEGRA_PIN_SOC_GPIO138_PP0,
+};
+
+static const unsigned int soc_gpio139_pp1_pins[] = {
+	TEGRA_PIN_SOC_GPIO139_PP1,
+};
+
+static const unsigned int dap6_sclk_pp2_pins[] = {
+	TEGRA_PIN_DAP6_SCLK_PP2,
+};
+
+static const unsigned int dap6_dout_pp3_pins[] = {
+	TEGRA_PIN_DAP6_DOUT_PP3,
+};
+
+static const unsigned int dap6_din_pp4_pins[] = {
+	TEGRA_PIN_DAP6_DIN_PP4,
+};
+
+static const unsigned int dap6_fs_pp5_pins[] = {
+	TEGRA_PIN_DAP6_FS_PP5,
+};
+
+static const unsigned int dap4_sclk_pp6_pins[] = {
+	TEGRA_PIN_DAP4_SCLK_PP6,
+};
+
+static const unsigned int dap4_dout_pp7_pins[] = {
+	TEGRA_PIN_DAP4_DOUT_PP7,
+};
+
+static const unsigned int dap4_din_pq0_pins[] = {
+	TEGRA_PIN_DAP4_DIN_PQ0,
+};
+
+static const unsigned int dap4_fs_pq1_pins[] = {
+	TEGRA_PIN_DAP4_FS_PQ1,
+};
+
+static const unsigned int spi5_sck_pq2_pins[] = {
+	TEGRA_PIN_SPI5_SCK_PQ2,
+};
+
+static const unsigned int spi5_miso_pq3_pins[] = {
+	TEGRA_PIN_SPI5_MISO_PQ3,
+};
+
+static const unsigned int spi5_mosi_pq4_pins[] = {
+	TEGRA_PIN_SPI5_MOSI_PQ4,
+};
+
+static const unsigned int spi5_cs0_pq5_pins[] = {
+	TEGRA_PIN_SPI5_CS0_PQ5,
+};
+
+static const unsigned int soc_gpio152_pq6_pins[] = {
+	TEGRA_PIN_SOC_GPIO152_PQ6,
+};
+
+static const unsigned int soc_gpio153_pq7_pins[] = {
+	TEGRA_PIN_SOC_GPIO153_PQ7,
+};
+
+static const unsigned int aud_mclk_pr0_pins[] = {
+	TEGRA_PIN_AUD_MCLK_PR0,
+};
+
+static const unsigned int soc_gpio155_pr1_pins[] = {
+	TEGRA_PIN_SOC_GPIO155_PR1,
+};
+
+static const unsigned int dap1_sclk_pr2_pins[] = {
+	TEGRA_PIN_DAP1_SCLK_PR2,
+};
+
+static const unsigned int dap1_out_pr3_pins[] = {
+	TEGRA_PIN_DAP1_OUT_PR3,
+};
+
+static const unsigned int dap1_in_pr4_pins[] = {
+	TEGRA_PIN_DAP1_IN_PR4,
+};
+
+static const unsigned int dap1_fs_pr5_pins[] = {
+	TEGRA_PIN_DAP1_FS_PR5,
+};
+
+static const unsigned int gen11_i2c_scl_pr6_pins[] = {
+	TEGRA_PIN_GEN11_I2C_SCL_PR6,
+};
+
+static const unsigned int gen11_i2c_sda_pr7_pins[] = {
+	TEGRA_PIN_GEN11_I2C_SDA_PR7,
+};
+
+static const unsigned int soc_gpio350_ps0_pins[] = {
+	TEGRA_PIN_SOC_GPIO350_PS0,
+};
+
+static const unsigned int soc_gpio351_ps1_pins[] = {
+	TEGRA_PIN_SOC_GPIO351_PS1,
+};
+
+
+static const unsigned int soc_gpio270_py0_pins[] = {
+	TEGRA_PIN_SOC_GPIO270_PY0,
+};
+
+static const unsigned int soc_gpio271_py1_pins[] = {
+	TEGRA_PIN_SOC_GPIO271_PY1,
+};
+
+static const unsigned int soc_gpio272_py2_pins[] = {
+	TEGRA_PIN_SOC_GPIO272_PY2,
+};
+
+static const unsigned int soc_gpio273_py3_pins[] = {
+	TEGRA_PIN_SOC_GPIO273_PY3,
+};
+
+static const unsigned int soc_gpio274_py4_pins[] = {
+	TEGRA_PIN_SOC_GPIO274_PY4,
+};
+
+static const unsigned int soc_gpio275_py5_pins[] = {
+	TEGRA_PIN_SOC_GPIO275_PY5,
+};
+
+static const unsigned int soc_gpio276_py6_pins[] = {
+	TEGRA_PIN_SOC_GPIO276_PY6,
+};
+
+static const unsigned int soc_gpio277_py7_pins[] = {
+	TEGRA_PIN_SOC_GPIO277_PY7,
+};
+
+static const unsigned int soc_gpio278_pz0_pins[] = {
+	TEGRA_PIN_SOC_GPIO278_PZ0,
+};
+
+static const unsigned int soc_gpio279_pz1_pins[] = {
+	TEGRA_PIN_SOC_GPIO279_PZ1,
+};
+
+static const unsigned int xhalt_trig_pz2_pins[] = {
+	TEGRA_PIN_XHALT_TRIG_PZ2,
+};
+
+static const unsigned int soc_gpio281_pz3_pins[] = {
+	TEGRA_PIN_SOC_GPIO281_PZ3,
+};
+
+static const unsigned int soc_gpio282_pz4_pins[] = {
+	TEGRA_PIN_SOC_GPIO282_PZ4,
+};
+
+static const unsigned int soc_gpio283_pz5_pins[] = {
+	TEGRA_PIN_SOC_GPIO283_PZ5,
+};
+
+static const unsigned int soc_gpio284_pz6_pins[] = {
+	TEGRA_PIN_SOC_GPIO284_PZ6,
+};
+
+static const unsigned int soc_gpio285_pz7_pins[] = {
+	TEGRA_PIN_SOC_GPIO285_PZ7,
+};
+
+static const unsigned int soc_gpio286_pal0_pins[] = {
+	TEGRA_PIN_SOC_GPIO286_PAL0,
+};
+
+static const unsigned int soc_gpio287_pal1_pins[] = {
+	TEGRA_PIN_SOC_GPIO287_PAL1,
+};
+
+static const unsigned int soc_gpio288_pal2_pins[] = {
+	TEGRA_PIN_SOC_GPIO288_PAL2,
+};
+
+
+static const unsigned int soc_gpio00_paa0_pins[] = {
+	TEGRA_PIN_SOC_GPIO00_PAA0,
+};
+
+static const unsigned int vcomp_alert_paa1_pins[] = {
+	TEGRA_PIN_VCOMP_ALERT_PAA1,
+};
+
+static const unsigned int ao_retention_n_paa2_pins[] = {
+	TEGRA_PIN_AO_RETENTION_N_PAA2,
+};
+
+static const unsigned int batt_oc_paa3_pins[] = {
+	TEGRA_PIN_BATT_OC_PAA3,
+};
+
+static const unsigned int bootv_ctl_n_paa4_pins[] = {
+	TEGRA_PIN_BOOTV_CTL_N_PAA4,
+};
+
+static const unsigned int power_on_paa5_pins[] = {
+	TEGRA_PIN_POWER_ON_PAA5,
+};
+
+static const unsigned int hdmi_cec_paa6_pins[] = {
+	TEGRA_PIN_HDMI_CEC_PAA6,
+};
+
+static const unsigned int soc_gpio07_paa7_pins[] = {
+	TEGRA_PIN_SOC_GPIO07_PAA7,
+};
+
+static const unsigned int soc_gpio08_pbb0_pins[] = {
+	TEGRA_PIN_SOC_GPIO08_PBB0,
+};
+
+static const unsigned int soc_gpio09_pbb1_pins[] = {
+	TEGRA_PIN_SOC_GPIO09_PBB1,
+};
+
+
+static const unsigned int gen2_i2c_scl_pcc0_pins[] = {
+	TEGRA_PIN_GEN2_I2C_SCL_PCC0,
+};
+
+static const unsigned int gen2_i2c_sda_pcc1_pins[] = {
+	TEGRA_PIN_GEN2_I2C_SDA_PCC1,
+};
+
+static const unsigned int gen3_i2c_scl_pcc2_pins[] = {
+	TEGRA_PIN_GEN3_I2C_SCL_PCC2,
+};
+
+static const unsigned int gen3_i2c_sda_pcc3_pins[] = {
+	TEGRA_PIN_GEN3_I2C_SDA_PCC3,
+};
+
+static const unsigned int gp_pwm4_pcc4_pins[] = {
+	TEGRA_PIN_GP_PWM4_PCC4,
+};
+
+static const unsigned int uart0_tx_pcc5_pins[] = {
+	TEGRA_PIN_UART0_TX_PCC5,
+};
+
+static const unsigned int uart0_rx_pcc6_pins[] = {
+	TEGRA_PIN_UART0_RX_PCC6,
+};
+
+static const unsigned int spi2_sck_pcc7_pins[] = {
+	TEGRA_PIN_SPI2_SCK_PCC7,
+};
+
+static const unsigned int spi2_miso_pdd0_pins[] = {
+	TEGRA_PIN_SPI2_MISO_PDD0,
+};
+
+static const unsigned int spi2_mosi_pdd1_pins[] = {
+	TEGRA_PIN_SPI2_MOSI_PDD1,
+};
+
+static const unsigned int spi2_cs0_n_pdd2_pins[] = {
+	TEGRA_PIN_SPI2_CS0_N_PDD2,
+};
+
+static const unsigned int soc_gpio21_pdd3_pins[] = {
+	TEGRA_PIN_SOC_GPIO21_PDD3,
+};
+
+static const unsigned int soc_gpio22_pdd4_pins[] = {
+	TEGRA_PIN_SOC_GPIO22_PDD4,
+};
+
+static const unsigned int soc_gpio23_pdd5_pins[] = {
+	TEGRA_PIN_SOC_GPIO23_PDD5,
+};
+
+static const unsigned int soc_gpio24_pdd6_pins[] = {
+	TEGRA_PIN_SOC_GPIO24_PDD6,
+};
+
+static const unsigned int soc_gpio25_pdd7_pins[] = {
+	TEGRA_PIN_SOC_GPIO25_PDD7,
+};
+
+static const unsigned int soc_gpio26_pee0_pins[] = {
+	TEGRA_PIN_SOC_GPIO26_PEE0,
+};
+
+static const unsigned int soc_gpio27_pee1_pins[] = {
+	TEGRA_PIN_SOC_GPIO27_PEE1,
+};
+
+static const unsigned int soc_gpio28_pee2_pins[] = {
+	TEGRA_PIN_SOC_GPIO28_PEE2,
+};
+
+static const unsigned int soc_gpio29_pee3_pins[] = {
+	TEGRA_PIN_SOC_GPIO29_PEE3,
+};
+
+enum tegra_mux_dt {
+	TEGRA_MUX_DCA_VSYNC,
+	TEGRA_MUX_DCA_HSYNC,
+	TEGRA_MUX_RSVD0,
+	TEGRA_MUX_DP_AUX_CH0_HPD,
+	TEGRA_MUX_DP_AUX_CH1_HPD,
+	TEGRA_MUX_DP_AUX_CH2_HPD,
+	TEGRA_MUX_DP_AUX_CH3_HPD,
+	TEGRA_MUX_GP_PWM2,
+	TEGRA_MUX_GP_PWM3,
+	TEGRA_MUX_I2C7_CLK,
+	TEGRA_MUX_I2C7_DAT,
+	TEGRA_MUX_I2C9_CLK,
+	TEGRA_MUX_I2C9_DAT,
+	TEGRA_MUX_UARTK_CTS,
+	TEGRA_MUX_UARTK_RTS,
+	TEGRA_MUX_UARTK_RXD,
+	TEGRA_MUX_UARTK_TXD,
+	TEGRA_MUX_SPI3_CS0,
+	TEGRA_MUX_SPI3_CS3,
+	TEGRA_MUX_SPI3_DIN,
+	TEGRA_MUX_SPI3_DOUT,
+	TEGRA_MUX_SPI3_SCK,
+	TEGRA_MUX_UARTF_CTS,
+	TEGRA_MUX_UARTF_RTS,
+	TEGRA_MUX_UARTF_RXD,
+	TEGRA_MUX_UARTF_TXD,
+	TEGRA_MUX_SPI1_CS0,
+	TEGRA_MUX_SPI1_CS1,
+	TEGRA_MUX_SPI1_DIN,
+	TEGRA_MUX_SPI1_DOUT,
+	TEGRA_MUX_SPI1_SCK,
+	TEGRA_MUX_EXTPERIPH2_CLK,
+	TEGRA_MUX_EXTPERIPH1_CLK,
+	TEGRA_MUX_I2C12_CLK,
+	TEGRA_MUX_I2C12_DAT,
+	TEGRA_MUX_NV_THERM_FAN_TACH0,
+	TEGRA_MUX_GP_PWM9,
+	TEGRA_MUX_UARTJ_CTS,
+	TEGRA_MUX_UARTJ_RTS,
+	TEGRA_MUX_UARTJ_RXD,
+	TEGRA_MUX_UARTJ_TXD,
+	TEGRA_MUX_I2C0_CLK,
+	TEGRA_MUX_I2C0_DAT,
+	TEGRA_MUX_I2C1_CLK,
+	TEGRA_MUX_I2C1_DAT,
+	TEGRA_MUX_I2S2_LRCK,
+	TEGRA_MUX_I2S2_SCLK,
+	TEGRA_MUX_I2S2_SDATA_OUT,
+	TEGRA_MUX_I2S2_SDATA_IN,
+	TEGRA_MUX_GP_PWM10,
+	TEGRA_MUX_UARTE_CTS,
+	TEGRA_MUX_UARTE_RTS,
+	TEGRA_MUX_UARTE_RXD,
+	TEGRA_MUX_UARTE_TXD,
+	TEGRA_MUX_I2C5_DAT,
+	TEGRA_MUX_I2C5_CLK,
+	TEGRA_MUX_I2S6_SDATA_IN,
+	TEGRA_MUX_I2S6_SDATA_OUT,
+	TEGRA_MUX_I2S6_LRCK,
+	TEGRA_MUX_I2S6_SCLK,
+	TEGRA_MUX_I2S4_SDATA_OUT,
+	TEGRA_MUX_I2S4_SCLK,
+	TEGRA_MUX_I2S4_SDATA_IN,
+	TEGRA_MUX_I2S4_LRCK,
+	TEGRA_MUX_SPI5_CS0,
+	TEGRA_MUX_SPI5_DIN,
+	TEGRA_MUX_SPI5_DOUT,
+	TEGRA_MUX_SPI5_SCK,
+	TEGRA_MUX_AUD_MCLK,
+	TEGRA_MUX_I2S1_SCLK,
+	TEGRA_MUX_I2S1_SDATA_IN,
+	TEGRA_MUX_I2S1_SDATA_OUT,
+	TEGRA_MUX_I2S1_LRCK,
+	TEGRA_MUX_I2C11_CLK,
+	TEGRA_MUX_I2C11_DAT,
+	TEGRA_MUX_XHALT_TRIG,
+	TEGRA_MUX_GP_PWM1,
+	TEGRA_MUX_GP_PWM6,
+	TEGRA_MUX_GP_PWM7,
+	TEGRA_MUX_GP_PWM8,
+	TEGRA_MUX_UFS0,
+	TEGRA_MUX_PE1_CLKREQ_L,
+	TEGRA_MUX_PE1_RST_L,
+	TEGRA_MUX_PE2_RST_L,
+	TEGRA_MUX_PE2_CLKREQ_L,
+	TEGRA_MUX_PE3_CLKREQ_L,
+	TEGRA_MUX_PE3_RST_L,
+	TEGRA_MUX_SGMII0_SMA_MDIO,
+	TEGRA_MUX_SGMII0_SMA_MDC,
+	TEGRA_MUX_USB_VBUS_EN0,
+	TEGRA_MUX_USB_VBUS_EN1,
+	TEGRA_MUX_ETH1_MDIO,
+	TEGRA_MUX_PE4_CLKREQ_L,
+	TEGRA_MUX_PE4_RST_L,
+	TEGRA_MUX_PE5_CLKREQ_L,
+	TEGRA_MUX_PE5_RST_L,
+	TEGRA_MUX_ETH0_MDIO,
+	TEGRA_MUX_ETH0_MDC,
+	TEGRA_MUX_ETH1_MDC,
+	TEGRA_MUX_ETH2_MDIO,
+	TEGRA_MUX_ETH2_MDC,
+	TEGRA_MUX_ETH3_MDIO,
+	TEGRA_MUX_ETH3_MDC,
+	TEGRA_MUX_QSPI0_CS_N,
+	TEGRA_MUX_QSPI0_IO0,
+	TEGRA_MUX_QSPI0_IO1,
+	TEGRA_MUX_QSPI0_IO2,
+	TEGRA_MUX_QSPI0_IO3,
+	TEGRA_MUX_QSPI0_SCK,
+	TEGRA_MUX_SDMMC1_CLK,
+	TEGRA_MUX_SDMMC1_CMD,
+	TEGRA_MUX_SDMMC1_COMP,
+	TEGRA_MUX_SDMMC1_DAT3,
+	TEGRA_MUX_SDMMC1_DAT2,
+	TEGRA_MUX_SDMMC1_DAT1,
+	TEGRA_MUX_SDMMC1_DAT0,
+	TEGRA_MUX_QSPI3_SCK,
+	TEGRA_MUX_QSPI3_CS0,
+	TEGRA_MUX_QSPI3_IO0,
+	TEGRA_MUX_QSPI3_IO1,
+	TEGRA_MUX_DCB_VSYNC,
+	TEGRA_MUX_DCB_HSYNC,
+	TEGRA_MUX_DSA_LSPII,
+	TEGRA_MUX_DCE_VSYNC,
+	TEGRA_MUX_DCE_HSYNC,
+	TEGRA_MUX_DCH_VSYNC,
+	TEGRA_MUX_DCH_HSYNC,
+	TEGRA_MUX_BL_EN,
+	TEGRA_MUX_BL_PWM_DIM0,
+	TEGRA_MUX_RSVD1,
+	TEGRA_MUX_SOC_THERM_OC3,
+	TEGRA_MUX_I2S5_SCLK,
+	TEGRA_MUX_I2S5_SDATA_IN,
+	TEGRA_MUX_EXTPERIPH3_CLK,
+	TEGRA_MUX_EXTPERIPH4_CLK,
+	TEGRA_MUX_I2S5_SDATA_OUT,
+	TEGRA_MUX_I2S5_LRCK,
+	TEGRA_MUX_SDMMC1_CD,
+	TEGRA_MUX_I2S7_SDATA_IN,
+	TEGRA_MUX_SPI4_SCK,
+	TEGRA_MUX_SPI4_DIN,
+	TEGRA_MUX_SPI4_DOUT,
+	TEGRA_MUX_SPI4_CS0,
+	TEGRA_MUX_SPI4_CS1,
+	TEGRA_MUX_GP_PWM5,
+	TEGRA_MUX_I2C14_CLK,
+	TEGRA_MUX_I2C14_DAT,
+	TEGRA_MUX_I2S8_SCLK,
+	TEGRA_MUX_I2S8_SDATA_OUT,
+	TEGRA_MUX_I2S8_LRCK,
+	TEGRA_MUX_I2S8_SDATA_IN,
+	TEGRA_MUX_I2C16_CLK,
+	TEGRA_MUX_I2C16_DAT,
+	TEGRA_MUX_I2S3_SCLK,
+	TEGRA_MUX_I2S3_SDATA_OUT,
+	TEGRA_MUX_I2S3_SDATA_IN,
+	TEGRA_MUX_I2S3_LRCK,
+	TEGRA_MUX_PM_TRIG1,
+	TEGRA_MUX_PM_TRIG0,
+	TEGRA_MUX_QSPI2_SCK,
+	TEGRA_MUX_QSPI2_CS0,
+	TEGRA_MUX_QSPI2_IO0,
+	TEGRA_MUX_QSPI2_IO1,
+	TEGRA_MUX_DCC_VSYNC,
+	TEGRA_MUX_DCC_HSYNC,
+	TEGRA_MUX_RSVD2,
+	TEGRA_MUX_DCF_VSYNC,
+	TEGRA_MUX_DCF_HSYNC,
+	TEGRA_MUX_SOUNDWIRE1_CLK,
+	TEGRA_MUX_SOUNDWIRE1_DAT0,
+	TEGRA_MUX_SOUNDWIRE1_DAT1,
+	TEGRA_MUX_SOUNDWIRE1_DAT2,
+	TEGRA_MUX_DMIC2_CLK,
+	TEGRA_MUX_DMIC2_DAT,
+	TEGRA_MUX_NV_THERM_FAN_TACH1,
+	TEGRA_MUX_I2C15_CLK,
+	TEGRA_MUX_I2C15_DAT,
+	TEGRA_MUX_I2S7_LRCK,
+	TEGRA_MUX_CCLA_LA_TRIGGER_MUX,
+	TEGRA_MUX_I2S7_SCLK,
+	TEGRA_MUX_I2S7_SDATA_OUT,
+	TEGRA_MUX_DMIC1_DAT,
+	TEGRA_MUX_DMIC1_CLK,
+	TEGRA_MUX_DCD_VSYNC,
+	TEGRA_MUX_DCD_HSYNC,
+	TEGRA_MUX_RSVD3,
+	TEGRA_MUX_DCG_VSYNC,
+	TEGRA_MUX_DCG_HSYNC,
+	TEGRA_MUX_DSPK1_CLK,
+	TEGRA_MUX_DSPK1_DAT,
+	TEGRA_MUX_SOC_THERM_OC2,
+	TEGRA_MUX_ISTCTRL_IST_DONE_N,
+	TEGRA_MUX_SOC_THERM_OC1,
+	TEGRA_MUX_TSC_EDGE_OUT0C,
+	TEGRA_MUX_TSC_EDGE_OUT0D,
+	TEGRA_MUX_TSC_EDGE_OUT0A,
+	TEGRA_MUX_TSC_EDGE_OUT0B,
+	TEGRA_MUX_TOUCH_CLK,
+	TEGRA_MUX_HDMI_CEC,
+	TEGRA_MUX_I2C2_CLK,
+	TEGRA_MUX_I2C2_DAT,
+	TEGRA_MUX_I2C3_CLK,
+	TEGRA_MUX_I2C3_DAT,
+	TEGRA_MUX_GP_PWM4,
+	TEGRA_MUX_UARTA_TXD,
+	TEGRA_MUX_UARTA_RXD,
+	TEGRA_MUX_SPI2_SCK,
+	TEGRA_MUX_SPI2_DIN,
+	TEGRA_MUX_SPI2_DOUT,
+	TEGRA_MUX_SPI2_CS0,
+	TEGRA_MUX_TSC_SYNC1,
+	TEGRA_MUX_TSC_EDGE_OUT3,
+	TEGRA_MUX_TSC_EDGE_OUT0,
+	TEGRA_MUX_TSC_EDGE_OUT1,
+	TEGRA_MUX_TSC_SYNC0,
+	TEGRA_MUX_SOUNDWIRE0_CLK,
+	TEGRA_MUX_SOUNDWIRE0_DAT0,
+	TEGRA_MUX_L0L1_RST_OUT_N,
+	TEGRA_MUX_L2_RST_OUT_N,
+	TEGRA_MUX_UARTL_TXD,
+	TEGRA_MUX_UARTL_RXD,
+	TEGRA_MUX_I2S9_SCLK,
+	TEGRA_MUX_I2S9_SDATA_OUT,
+	TEGRA_MUX_I2S9_SDATA_IN,
+	TEGRA_MUX_I2S9_LRCK,
+	TEGRA_MUX_DMIC5_DAT,
+	TEGRA_MUX_DMIC5_CLK,
+	TEGRA_MUX_TSC_EDGE_OUT2,
+};
+
+/* Make list of each function name */
+#define TEGRA_PIN_FUNCTION(lid) #lid
+
+static const char * const tegra264_functions[] = {
+	TEGRA_PIN_FUNCTION(dca_vsync),
+	TEGRA_PIN_FUNCTION(dca_hsync),
+	TEGRA_PIN_FUNCTION(rsvd0),
+	TEGRA_PIN_FUNCTION(dp_aux_ch0_hpd),
+	TEGRA_PIN_FUNCTION(dp_aux_ch1_hpd),
+	TEGRA_PIN_FUNCTION(dp_aux_ch2_hpd),
+	TEGRA_PIN_FUNCTION(dp_aux_ch3_hpd),
+	TEGRA_PIN_FUNCTION(gp_pwm2),
+	TEGRA_PIN_FUNCTION(gp_pwm3),
+	TEGRA_PIN_FUNCTION(i2c7_clk),
+	TEGRA_PIN_FUNCTION(i2c7_dat),
+	TEGRA_PIN_FUNCTION(i2c9_clk),
+	TEGRA_PIN_FUNCTION(i2c9_dat),
+	TEGRA_PIN_FUNCTION(uartk_cts),
+	TEGRA_PIN_FUNCTION(uartk_rts),
+	TEGRA_PIN_FUNCTION(uartk_rxd),
+	TEGRA_PIN_FUNCTION(uartk_txd),
+	TEGRA_PIN_FUNCTION(spi3_cs0),
+	TEGRA_PIN_FUNCTION(spi3_cs3),
+	TEGRA_PIN_FUNCTION(spi3_din),
+	TEGRA_PIN_FUNCTION(spi3_dout),
+	TEGRA_PIN_FUNCTION(spi3_sck),
+	TEGRA_PIN_FUNCTION(uartf_cts),
+	TEGRA_PIN_FUNCTION(uartf_rts),
+	TEGRA_PIN_FUNCTION(uartf_rxd),
+	TEGRA_PIN_FUNCTION(uartf_txd),
+	TEGRA_PIN_FUNCTION(spi1_cs0),
+	TEGRA_PIN_FUNCTION(spi1_cs1),
+	TEGRA_PIN_FUNCTION(spi1_din),
+	TEGRA_PIN_FUNCTION(spi1_dout),
+	TEGRA_PIN_FUNCTION(spi1_sck),
+	TEGRA_PIN_FUNCTION(extperiph2_clk),
+	TEGRA_PIN_FUNCTION(extperiph1_clk),
+	TEGRA_PIN_FUNCTION(i2c12_clk),
+	TEGRA_PIN_FUNCTION(i2c12_dat),
+	TEGRA_PIN_FUNCTION(nv_therm_fan_tach0),
+	TEGRA_PIN_FUNCTION(gp_pwm9),
+	TEGRA_PIN_FUNCTION(uartj_cts),
+	TEGRA_PIN_FUNCTION(uartj_rts),
+	TEGRA_PIN_FUNCTION(uartj_rxd),
+	TEGRA_PIN_FUNCTION(uartj_txd),
+	TEGRA_PIN_FUNCTION(i2c0_clk),
+	TEGRA_PIN_FUNCTION(i2c0_dat),
+	TEGRA_PIN_FUNCTION(i2c1_clk),
+	TEGRA_PIN_FUNCTION(i2c1_dat),
+	TEGRA_PIN_FUNCTION(i2s2_lrck),
+	TEGRA_PIN_FUNCTION(i2s2_sclk),
+	TEGRA_PIN_FUNCTION(i2s2_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s2_sdata_in),
+	TEGRA_PIN_FUNCTION(gp_pwm10),
+	TEGRA_PIN_FUNCTION(uarte_cts),
+	TEGRA_PIN_FUNCTION(uarte_rts),
+	TEGRA_PIN_FUNCTION(uarte_rxd),
+	TEGRA_PIN_FUNCTION(uarte_txd),
+	TEGRA_PIN_FUNCTION(i2c5_dat),
+	TEGRA_PIN_FUNCTION(i2c5_clk),
+	TEGRA_PIN_FUNCTION(i2s6_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s6_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s6_lrck),
+	TEGRA_PIN_FUNCTION(i2s6_sclk),
+	TEGRA_PIN_FUNCTION(i2s4_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s4_sclk),
+	TEGRA_PIN_FUNCTION(i2s4_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s4_lrck),
+	TEGRA_PIN_FUNCTION(spi5_cs0),
+	TEGRA_PIN_FUNCTION(spi5_din),
+	TEGRA_PIN_FUNCTION(spi5_dout),
+	TEGRA_PIN_FUNCTION(spi5_sck),
+	TEGRA_PIN_FUNCTION(aud_mclk),
+	TEGRA_PIN_FUNCTION(i2s1_sclk),
+	TEGRA_PIN_FUNCTION(i2s1_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s1_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s1_lrck),
+	TEGRA_PIN_FUNCTION(i2c11_clk),
+	TEGRA_PIN_FUNCTION(i2c11_dat),
+	TEGRA_PIN_FUNCTION(xhalt_trig),
+	TEGRA_PIN_FUNCTION(gp_pwm1),
+	TEGRA_PIN_FUNCTION(gp_pwm6),
+	TEGRA_PIN_FUNCTION(gp_pwm7),
+	TEGRA_PIN_FUNCTION(gp_pwm8),
+	TEGRA_PIN_FUNCTION(ufs0),
+	TEGRA_PIN_FUNCTION(pe1_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe1_rst_l),
+	TEGRA_PIN_FUNCTION(pe2_rst_l),
+	TEGRA_PIN_FUNCTION(pe2_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe3_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe3_rst_l),
+	TEGRA_PIN_FUNCTION(sgmii0_sma_mdio),
+	TEGRA_PIN_FUNCTION(sgmii0_sma_mdc),
+	TEGRA_PIN_FUNCTION(usb_vbus_en0),
+	TEGRA_PIN_FUNCTION(usb_vbus_en1),
+	TEGRA_PIN_FUNCTION(eth1_mdio),
+	TEGRA_PIN_FUNCTION(pe4_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe4_rst_l),
+	TEGRA_PIN_FUNCTION(pe5_clkreq_l),
+	TEGRA_PIN_FUNCTION(pe5_rst_l),
+	TEGRA_PIN_FUNCTION(eth0_mdio),
+	TEGRA_PIN_FUNCTION(eth0_mdc),
+	TEGRA_PIN_FUNCTION(eth1_mdc),
+	TEGRA_PIN_FUNCTION(eth2_mdio),
+	TEGRA_PIN_FUNCTION(eth2_mdc),
+	TEGRA_PIN_FUNCTION(eth3_mdio),
+	TEGRA_PIN_FUNCTION(eth3_mdc),
+	TEGRA_PIN_FUNCTION(qspi0_cs_n),
+	TEGRA_PIN_FUNCTION(qspi0_io0),
+	TEGRA_PIN_FUNCTION(qspi0_io1),
+	TEGRA_PIN_FUNCTION(qspi0_io2),
+	TEGRA_PIN_FUNCTION(qspi0_io3),
+	TEGRA_PIN_FUNCTION(qspi0_sck),
+	TEGRA_PIN_FUNCTION(sdmmc1_clk),
+	TEGRA_PIN_FUNCTION(sdmmc1_cmd),
+	TEGRA_PIN_FUNCTION(sdmmc1_comp),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat3),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat2),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat1),
+	TEGRA_PIN_FUNCTION(sdmmc1_dat0),
+	TEGRA_PIN_FUNCTION(qspi3_sck),
+	TEGRA_PIN_FUNCTION(qspi3_cs0),
+	TEGRA_PIN_FUNCTION(qspi3_io0),
+	TEGRA_PIN_FUNCTION(qspi3_io1),
+	TEGRA_PIN_FUNCTION(dcb_vsync),
+	TEGRA_PIN_FUNCTION(dcb_hsync),
+	TEGRA_PIN_FUNCTION(dsa_lspii),
+	TEGRA_PIN_FUNCTION(dce_vsync),
+	TEGRA_PIN_FUNCTION(dce_hsync),
+	TEGRA_PIN_FUNCTION(dch_vsync),
+	TEGRA_PIN_FUNCTION(dch_hsync),
+	TEGRA_PIN_FUNCTION(bl_en),
+	TEGRA_PIN_FUNCTION(bl_pwm_dim0),
+	TEGRA_PIN_FUNCTION(rsvd1),
+	TEGRA_PIN_FUNCTION(soc_therm_oc3),
+	TEGRA_PIN_FUNCTION(i2s5_sclk),
+	TEGRA_PIN_FUNCTION(i2s5_sdata_in),
+	TEGRA_PIN_FUNCTION(extperiph3_clk),
+	TEGRA_PIN_FUNCTION(extperiph4_clk),
+	TEGRA_PIN_FUNCTION(i2s5_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s5_lrck),
+	TEGRA_PIN_FUNCTION(sdmmc1_cd),
+	TEGRA_PIN_FUNCTION(i2s7_sdata_in),
+	TEGRA_PIN_FUNCTION(spi4_sck),
+	TEGRA_PIN_FUNCTION(spi4_din),
+	TEGRA_PIN_FUNCTION(spi4_dout),
+	TEGRA_PIN_FUNCTION(spi4_cs0),
+	TEGRA_PIN_FUNCTION(spi4_cs1),
+	TEGRA_PIN_FUNCTION(gp_pwm5),
+	TEGRA_PIN_FUNCTION(i2c14_clk),
+	TEGRA_PIN_FUNCTION(i2c14_dat),
+	TEGRA_PIN_FUNCTION(i2s8_sclk),
+	TEGRA_PIN_FUNCTION(i2s8_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s8_lrck),
+	TEGRA_PIN_FUNCTION(i2s8_sdata_in),
+	TEGRA_PIN_FUNCTION(i2c16_clk),
+	TEGRA_PIN_FUNCTION(i2c16_dat),
+	TEGRA_PIN_FUNCTION(i2s3_sclk),
+	TEGRA_PIN_FUNCTION(i2s3_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s3_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s3_lrck),
+	TEGRA_PIN_FUNCTION(pm_trig1),
+	TEGRA_PIN_FUNCTION(pm_trig0),
+	TEGRA_PIN_FUNCTION(qspi2_sck),
+	TEGRA_PIN_FUNCTION(qspi2_cs0),
+	TEGRA_PIN_FUNCTION(qspi2_io0),
+	TEGRA_PIN_FUNCTION(qspi2_io1),
+	TEGRA_PIN_FUNCTION(dcc_vsync),
+	TEGRA_PIN_FUNCTION(dcc_hsync),
+	TEGRA_PIN_FUNCTION(rsvd2),
+	TEGRA_PIN_FUNCTION(dcf_vsync),
+	TEGRA_PIN_FUNCTION(dcf_hsync),
+	TEGRA_PIN_FUNCTION(soundwire1_clk),
+	TEGRA_PIN_FUNCTION(soundwire1_dat0),
+	TEGRA_PIN_FUNCTION(soundwire1_dat1),
+	TEGRA_PIN_FUNCTION(soundwire1_dat2),
+	TEGRA_PIN_FUNCTION(dmic2_clk),
+	TEGRA_PIN_FUNCTION(dmic2_dat),
+	TEGRA_PIN_FUNCTION(nv_therm_fan_tach1),
+	TEGRA_PIN_FUNCTION(i2c15_clk),
+	TEGRA_PIN_FUNCTION(i2c15_dat),
+	TEGRA_PIN_FUNCTION(i2s7_lrck),
+	TEGRA_PIN_FUNCTION(ccla_la_trigger_mux),
+	TEGRA_PIN_FUNCTION(i2s7_sclk),
+	TEGRA_PIN_FUNCTION(i2s7_sdata_out),
+	TEGRA_PIN_FUNCTION(dmic1_dat),
+	TEGRA_PIN_FUNCTION(dmic1_clk),
+	TEGRA_PIN_FUNCTION(dcd_vsync),
+	TEGRA_PIN_FUNCTION(dcd_hsync),
+	TEGRA_PIN_FUNCTION(rsvd3),
+	TEGRA_PIN_FUNCTION(dcg_vsync),
+	TEGRA_PIN_FUNCTION(dcg_hsync),
+	TEGRA_PIN_FUNCTION(dspk1_clk),
+	TEGRA_PIN_FUNCTION(dspk1_dat),
+	TEGRA_PIN_FUNCTION(soc_therm_oc2),
+	TEGRA_PIN_FUNCTION(istctrl_ist_done_n),
+	TEGRA_PIN_FUNCTION(soc_therm_oc1),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0c),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0d),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0a),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0b),
+	TEGRA_PIN_FUNCTION(touch_clk),
+	TEGRA_PIN_FUNCTION(hdmi_cec),
+	TEGRA_PIN_FUNCTION(i2c2_clk),
+	TEGRA_PIN_FUNCTION(i2c2_dat),
+	TEGRA_PIN_FUNCTION(i2c3_clk),
+	TEGRA_PIN_FUNCTION(i2c3_dat),
+	TEGRA_PIN_FUNCTION(gp_pwm4),
+	TEGRA_PIN_FUNCTION(uarta_txd),
+	TEGRA_PIN_FUNCTION(uarta_rxd),
+	TEGRA_PIN_FUNCTION(spi2_sck),
+	TEGRA_PIN_FUNCTION(spi2_din),
+	TEGRA_PIN_FUNCTION(spi2_dout),
+	TEGRA_PIN_FUNCTION(spi2_cs0),
+	TEGRA_PIN_FUNCTION(tsc_sync1),
+	TEGRA_PIN_FUNCTION(tsc_edge_out3),
+	TEGRA_PIN_FUNCTION(tsc_edge_out0),
+	TEGRA_PIN_FUNCTION(tsc_edge_out1),
+	TEGRA_PIN_FUNCTION(tsc_sync0),
+	TEGRA_PIN_FUNCTION(soundwire0_clk),
+	TEGRA_PIN_FUNCTION(soundwire0_dat0),
+	TEGRA_PIN_FUNCTION(l0l1_rst_out_n),
+	TEGRA_PIN_FUNCTION(l2_rst_out_n),
+	TEGRA_PIN_FUNCTION(uartl_txd),
+	TEGRA_PIN_FUNCTION(uartl_rxd),
+	TEGRA_PIN_FUNCTION(i2s9_sclk),
+	TEGRA_PIN_FUNCTION(i2s9_sdata_out),
+	TEGRA_PIN_FUNCTION(i2s9_sdata_in),
+	TEGRA_PIN_FUNCTION(i2s9_lrck),
+	TEGRA_PIN_FUNCTION(dmic5_dat),
+	TEGRA_PIN_FUNCTION(dmic5_clk),
+	TEGRA_PIN_FUNCTION(tsc_edge_out2),
+};
+
+
+#define PINGROUP_REG_Y(r) ((r))
+#define PINGROUP_REG_N(r) -1
+
+#define DRV_PINGROUP_Y(r) ((r))
+#define DRV_PINGROUP_N(r) -1
+
+#define DRV_PINGROUP_ENTRY_N(pg_name)				\
+		.drv_reg = -1,					\
+		.drv_bank = -1,					\
+		.drvdn_bit = -1,				\
+		.drvup_bit = -1,				\
+		.slwr_bit = -1,					\
+		.slwf_bit = -1
+
+#define DRV_PINGROUP_ENTRY_Y(r, drvdn_b, drvdn_w, drvup_b,	\
+			     drvup_w, slwr_b, slwr_w, slwf_b,	\
+			     slwf_w, bank)			\
+		.drv_reg = DRV_PINGROUP_Y(r),			\
+		.drv_bank = bank,				\
+		.drvdn_bit = drvdn_b,				\
+		.drvdn_width = drvdn_w,				\
+		.drvup_bit = drvup_b,				\
+		.drvup_width = drvup_w,				\
+		.slwr_bit = slwr_b,				\
+		.slwr_width = slwr_w,				\
+		.slwf_bit = slwf_b,				\
+		.slwf_width = slwf_w
+
+#define PIN_PINGROUP_ENTRY_N(pg_name)				\
+		.mux_reg = -1,					\
+		.pupd_reg = -1,					\
+		.tri_reg = -1,					\
+		.einput_bit = -1,				\
+		.e_io_hv_bit = -1,				\
+		.odrain_bit = -1,				\
+		.lock_bit = -1,					\
+		.parked_bit = -1,				\
+		.lpmd_bit = -1,					\
+		.drvtype_bit = -1,				\
+		.lpdr_bit = -1,					\
+		.pbias_buf_bit = -1,				\
+		.preemp_bit = -1,				\
+		.rfu_in_bit = -1
+
+#define PIN_PINGROUP_ENTRY_Y(r, bank, pupd, e_io_hv, e_lpbk, e_input,	\
+				e_lpdr, e_pbias_buf, gpio_sfio_sel,	\
+				schmitt_b)				\
+		.mux_reg = PINGROUP_REG_Y(r),			\
+		.lpmd_bit = -1,					\
+		.lock_bit = -1,					\
+		.hsm_bit = -1,					\
+		.mux_bank = bank,				\
+		.mux_bit = 0,					\
+		.pupd_reg = PINGROUP_REG_##pupd(r),		\
+		.pupd_bank = bank,				\
+		.pupd_bit = 2,					\
+		.tri_reg = PINGROUP_REG_Y(r),			\
+		.tri_bank = bank,				\
+		.tri_bit = 4,					\
+		.einput_bit = e_input,				\
+		.sfsel_bit = gpio_sfio_sel,			\
+		.schmitt_bit = schmitt_b,			\
+		.drvtype_bit = 13,				\
+		.lpdr_bit = e_lpdr,				\
+		.drv_reg = -1,					\
+
+
+#define drive_eth1_mdio_pe0 DRV_PINGROUP_ENTRY_Y(0x4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l4_clkreq_n_pd0 DRV_PINGROUP_ENTRY_Y(0xc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l4_rst_n_pd1 DRV_PINGROUP_ENTRY_Y(0x14, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l5_clkreq_n_pd2 DRV_PINGROUP_ENTRY_Y(0x1c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l5_rst_n_pd3 DRV_PINGROUP_ENTRY_Y(0x24, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth0_mdio_pd4 DRV_PINGROUP_ENTRY_Y(0x2c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth0_mdc_pd5 DRV_PINGROUP_ENTRY_Y(0x34, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth1_mdc_pe1 DRV_PINGROUP_ENTRY_Y(0x3c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth2_mdio_pe2 DRV_PINGROUP_ENTRY_Y(0x44, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth2_mdc_pe3 DRV_PINGROUP_ENTRY_Y(0x4c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth3_mdio_pd6 DRV_PINGROUP_ENTRY_Y(0x54, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_eth3_mdc_pd7 DRV_PINGROUP_ENTRY_Y(0x5c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l1_clkreq_n_pb0 DRV_PINGROUP_ENTRY_Y(0x2004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l1_rst_n_pb1 DRV_PINGROUP_ENTRY_Y(0x200c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_wake_n_pc2 DRV_PINGROUP_ENTRY_Y(0x2014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l2_rst_n_pb3 DRV_PINGROUP_ENTRY_Y(0x201c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l2_clkreq_n_pb2 DRV_PINGROUP_ENTRY_Y(0x2024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l3_clkreq_n_pb4 DRV_PINGROUP_ENTRY_Y(0x202c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pex_l3_rst_n_pb5 DRV_PINGROUP_ENTRY_Y(0x2034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_sgmii0_sma_mdio_pc0 DRV_PINGROUP_ENTRY_Y(0x203c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_sgmii0_sma_mdc_pc1 DRV_PINGROUP_ENTRY_Y(0x2044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio113_pb6 DRV_PINGROUP_ENTRY_Y(0x204c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio114_pb7 DRV_PINGROUP_ENTRY_Y(0x2054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm1_pa0 DRV_PINGROUP_ENTRY_Y(0x3004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm6_pa1 DRV_PINGROUP_ENTRY_Y(0x300c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm7_pa2 DRV_PINGROUP_ENTRY_Y(0x3014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm8_pa3 DRV_PINGROUP_ENTRY_Y(0x301c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_ufs0_ref_clk_pa4 DRV_PINGROUP_ENTRY_Y(0x3024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_ufs0_rst_n_pa5 DRV_PINGROUP_ENTRY_Y(0x302c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+
+#define drive_cpu_pwr_req_ph0 DRV_PINGROUP_ENTRY_Y(0x4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gpu_pwr_req_ph1 DRV_PINGROUP_ENTRY_Y(0xc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_cts_n_ph5 DRV_PINGROUP_ENTRY_Y(0x14, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_rts_n_ph4 DRV_PINGROUP_ENTRY_Y(0x1c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_rx_ph3 DRV_PINGROUP_ENTRY_Y(0x24, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart10_tx_ph2 DRV_PINGROUP_ENTRY_Y(0x2c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_cs0_pj1 DRV_PINGROUP_ENTRY_Y(0x34, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_cs3_pj2 DRV_PINGROUP_ENTRY_Y(0x3c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_miso_ph7 DRV_PINGROUP_ENTRY_Y(0x44, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_mosi_pj0 DRV_PINGROUP_ENTRY_Y(0x4c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi3_sck_ph6 DRV_PINGROUP_ENTRY_Y(0x54, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_cts_n_pj6 DRV_PINGROUP_ENTRY_Y(0x5c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_rts_n_pj5 DRV_PINGROUP_ENTRY_Y(0x64, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_rx_pj4 DRV_PINGROUP_ENTRY_Y(0x6c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart5_tx_pj3 DRV_PINGROUP_ENTRY_Y(0x74, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_cs0_pk2 DRV_PINGROUP_ENTRY_Y(0x7c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_cs1_pk3 DRV_PINGROUP_ENTRY_Y(0x84, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_miso_pk0 DRV_PINGROUP_ENTRY_Y(0x8c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_mosi_pk1 DRV_PINGROUP_ENTRY_Y(0x94, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi1_sck_pj7 DRV_PINGROUP_ENTRY_Y(0x9c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_extperiph2_clk_pk5 DRV_PINGROUP_ENTRY_Y(0xa4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_extperiph1_clk_pk4 DRV_PINGROUP_ENTRY_Y(0xac, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen12_i2c_scl_pk6 DRV_PINGROUP_ENTRY_Y(0xb4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen12_i2c_sda_pk7 DRV_PINGROUP_ENTRY_Y(0xbc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio124_pl0 DRV_PINGROUP_ENTRY_Y(0x1004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio125_pl1 DRV_PINGROUP_ENTRY_Y(0x100c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_fan_tach0_pl2 DRV_PINGROUP_ENTRY_Y(0x1014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio127_pl3 DRV_PINGROUP_ENTRY_Y(0x101c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio128_pl4 DRV_PINGROUP_ENTRY_Y(0x1024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio129_pl5 DRV_PINGROUP_ENTRY_Y(0x102c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio130_pl6 DRV_PINGROUP_ENTRY_Y(0x1034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio131_pl7 DRV_PINGROUP_ENTRY_Y(0x103c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gp_pwm9_pm0 DRV_PINGROUP_ENTRY_Y(0x1044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio133_pm1 DRV_PINGROUP_ENTRY_Y(0x104c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_cts_n_pm5 DRV_PINGROUP_ENTRY_Y(0x1054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_rts_n_pm4 DRV_PINGROUP_ENTRY_Y(0x105c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_rx_pm3 DRV_PINGROUP_ENTRY_Y(0x1064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart9_tx_pm2 DRV_PINGROUP_ENTRY_Y(0x106c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_comp DRV_PINGROUP_ENTRY_N(no_entry)
+#define drive_sdmmc1_clk_px0 DRV_PINGROUP_ENTRY_Y(0x2004, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_cmd_px1 DRV_PINGROUP_ENTRY_Y(0x200c, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat3_px5 DRV_PINGROUP_ENTRY_Y(0x201c, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat2_px4 DRV_PINGROUP_ENTRY_Y(0x2024, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat1_px3 DRV_PINGROUP_ENTRY_Y(0x202c, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_sdmmc1_dat0_px2 DRV_PINGROUP_ENTRY_Y(0x2034, 28, 2, 30, 2, -1, -1, -1, -1, 0)
+#define drive_qspi0_cs_n_pt1 DRV_PINGROUP_ENTRY_Y(0x3004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io0_pt2 DRV_PINGROUP_ENTRY_Y(0x300c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io1_pt3 DRV_PINGROUP_ENTRY_Y(0x3014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io2_pt4 DRV_PINGROUP_ENTRY_Y(0x301c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_io3_pt5 DRV_PINGROUP_ENTRY_Y(0x3024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_qspi0_sck_pt0 DRV_PINGROUP_ENTRY_Y(0x302c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio192_pt6 DRV_PINGROUP_ENTRY_Y(0x3034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio138_pp0 DRV_PINGROUP_ENTRY_Y(0x5004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio139_pp1 DRV_PINGROUP_ENTRY_Y(0x500c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_din_pp4 DRV_PINGROUP_ENTRY_Y(0x5014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_dout_pp3 DRV_PINGROUP_ENTRY_Y(0x501c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_fs_pp5 DRV_PINGROUP_ENTRY_Y(0x5024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap6_sclk_pp2 DRV_PINGROUP_ENTRY_Y(0x502c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_dout_pp7 DRV_PINGROUP_ENTRY_Y(0x5034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_sclk_pp6 DRV_PINGROUP_ENTRY_Y(0x503c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_din_pq0 DRV_PINGROUP_ENTRY_Y(0x5044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap4_fs_pq1 DRV_PINGROUP_ENTRY_Y(0x504c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_cs0_pq5 DRV_PINGROUP_ENTRY_Y(0x5054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_miso_pq3 DRV_PINGROUP_ENTRY_Y(0x505c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_mosi_pq4 DRV_PINGROUP_ENTRY_Y(0x5064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi5_sck_pq2 DRV_PINGROUP_ENTRY_Y(0x506c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio152_pq6 DRV_PINGROUP_ENTRY_Y(0x5074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio153_pq7 DRV_PINGROUP_ENTRY_Y(0x507c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio155_pr1 DRV_PINGROUP_ENTRY_Y(0x5084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_aud_mclk_pr0 DRV_PINGROUP_ENTRY_Y(0x508c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_sclk_pr2 DRV_PINGROUP_ENTRY_Y(0x5094, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_in_pr4 DRV_PINGROUP_ENTRY_Y(0x509c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_out_pr3 DRV_PINGROUP_ENTRY_Y(0x50a4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap1_fs_pr5 DRV_PINGROUP_ENTRY_Y(0x50ac, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen11_i2c_scl_pr6 DRV_PINGROUP_ENTRY_Y(0x50b4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen11_i2c_sda_pr7 DRV_PINGROUP_ENTRY_Y(0x50bc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio350_ps0 DRV_PINGROUP_ENTRY_Y(0x50c4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio351_ps1 DRV_PINGROUP_ENTRY_Y(0x50cc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen0_i2c_scl_pw4 DRV_PINGROUP_ENTRY_Y(0x6004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen0_i2c_sda_pw5 DRV_PINGROUP_ENTRY_Y(0x600c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen1_i2c_scl_pw2 DRV_PINGROUP_ENTRY_Y(0x6014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen1_i2c_sda_pw3 DRV_PINGROUP_ENTRY_Y(0x601c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_fs_pw1 DRV_PINGROUP_ENTRY_Y(0x6044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_clk_pv6 DRV_PINGROUP_ENTRY_Y(0x604c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_din_pw0 DRV_PINGROUP_ENTRY_Y(0x6054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dap2_dout_pv7 DRV_PINGROUP_ENTRY_Y(0x605c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm10_pv1 DRV_PINGROUP_ENTRY_Y(0x6064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio170_pu0 DRV_PINGROUP_ENTRY_Y(0x606c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio171_pu1 DRV_PINGROUP_ENTRY_Y(0x6074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio172_pu2 DRV_PINGROUP_ENTRY_Y(0x607c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio173_pu3 DRV_PINGROUP_ENTRY_Y(0x6084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio174_pu4 DRV_PINGROUP_ENTRY_Y(0x608c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio175_pu5 DRV_PINGROUP_ENTRY_Y(0x6094, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio176_pu6 DRV_PINGROUP_ENTRY_Y(0x609c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio177_pu7 DRV_PINGROUP_ENTRY_Y(0x60a4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio178_pv0 DRV_PINGROUP_ENTRY_Y(0x60ac, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_cts_n_pv5 DRV_PINGROUP_ENTRY_Y(0x60b4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_rts_n_pv4 DRV_PINGROUP_ENTRY_Y(0x60bc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_rx_pv3 DRV_PINGROUP_ENTRY_Y(0x60c4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart4_tx_pv2 DRV_PINGROUP_ENTRY_Y(0x60cc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwr_i2c_sda_pw7 DRV_PINGROUP_ENTRY_Y(0x60d4, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwr_i2c_scl_pw6 DRV_PINGROUP_ENTRY_Y(0x60dc, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio250_pf0 DRV_PINGROUP_ENTRY_Y(0x7004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio251_pf1 DRV_PINGROUP_ENTRY_Y(0x700c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio252_pf2 DRV_PINGROUP_ENTRY_Y(0x7014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch0_hpd_pf3 DRV_PINGROUP_ENTRY_Y(0x701c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch1_hpd_pf4 DRV_PINGROUP_ENTRY_Y(0x7024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch2_hpd_pf5 DRV_PINGROUP_ENTRY_Y(0x702c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_dp_aux_ch3_hpd_pf6 DRV_PINGROUP_ENTRY_Y(0x7034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm2_pf7 DRV_PINGROUP_ENTRY_Y(0x703c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_pwm3_pg0 DRV_PINGROUP_ENTRY_Y(0x7044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen7_i2c_scl_pg1 DRV_PINGROUP_ENTRY_Y(0x704c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen7_i2c_sda_pg2 DRV_PINGROUP_ENTRY_Y(0x7054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen9_i2c_scl_pg3 DRV_PINGROUP_ENTRY_Y(0x705c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen9_i2c_sda_pg4 DRV_PINGROUP_ENTRY_Y(0x7064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio270_py0 DRV_PINGROUP_ENTRY_Y(0xa004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio271_py1 DRV_PINGROUP_ENTRY_Y(0xa00c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio272_py2 DRV_PINGROUP_ENTRY_Y(0xa014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio273_py3 DRV_PINGROUP_ENTRY_Y(0xa01c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio274_py4 DRV_PINGROUP_ENTRY_Y(0xa024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio275_py5 DRV_PINGROUP_ENTRY_Y(0xa02c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio276_py6 DRV_PINGROUP_ENTRY_Y(0xa034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio277_py7 DRV_PINGROUP_ENTRY_Y(0xa03c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio278_pz0 DRV_PINGROUP_ENTRY_Y(0xa044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio279_pz1 DRV_PINGROUP_ENTRY_Y(0xa04c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio282_pz4 DRV_PINGROUP_ENTRY_Y(0xa054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio283_pz5 DRV_PINGROUP_ENTRY_Y(0xa05c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio284_pz6 DRV_PINGROUP_ENTRY_Y(0xa064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio285_pz7 DRV_PINGROUP_ENTRY_Y(0xa06c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio286_pal0 DRV_PINGROUP_ENTRY_Y(0xa074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio287_pal1 DRV_PINGROUP_ENTRY_Y(0xa07c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio288_pal2 DRV_PINGROUP_ENTRY_Y(0xa084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_xhalt_trig_pz2 DRV_PINGROUP_ENTRY_Y(0xa08c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio281_pz3 DRV_PINGROUP_ENTRY_Y(0xa094, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+
+#define drive_ao_retention_n_paa2 DRV_PINGROUP_ENTRY_Y(0x2c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_batt_oc_paa3 DRV_PINGROUP_ENTRY_Y(0x34, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_power_on_paa5 DRV_PINGROUP_ENTRY_Y(0x3c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_vcomp_alert_paa1 DRV_PINGROUP_ENTRY_Y(0x44, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_bootv_ctl_n_paa4 DRV_PINGROUP_ENTRY_Y(0x4c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio00_paa0 DRV_PINGROUP_ENTRY_Y(0x54, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio07_paa7 DRV_PINGROUP_ENTRY_Y(0x5c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio08_pbb0 DRV_PINGROUP_ENTRY_Y(0x64, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio09_pbb1 DRV_PINGROUP_ENTRY_Y(0x6c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_hdmi_cec_paa6 DRV_PINGROUP_ENTRY_Y(0x74, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen2_i2c_scl_pcc0 DRV_PINGROUP_ENTRY_Y(0x1004, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen2_i2c_sda_pcc1 DRV_PINGROUP_ENTRY_Y(0x100c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen3_i2c_scl_pcc2 DRV_PINGROUP_ENTRY_Y(0x1014, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gen3_i2c_sda_pcc3 DRV_PINGROUP_ENTRY_Y(0x101c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_gp_pwm4_pcc4 DRV_PINGROUP_ENTRY_Y(0x1024, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart0_tx_pcc5 DRV_PINGROUP_ENTRY_Y(0x102c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_uart0_rx_pcc6 DRV_PINGROUP_ENTRY_Y(0x1034, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_sck_pcc7 DRV_PINGROUP_ENTRY_Y(0x103c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_miso_pdd0 DRV_PINGROUP_ENTRY_Y(0x1044, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_mosi_pdd1 DRV_PINGROUP_ENTRY_Y(0x104c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_spi2_cs0_n_pdd2 DRV_PINGROUP_ENTRY_Y(0x1054, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio21_pdd3 DRV_PINGROUP_ENTRY_Y(0x105c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio22_pdd4 DRV_PINGROUP_ENTRY_Y(0x1064, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio23_pdd5 DRV_PINGROUP_ENTRY_Y(0x106c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio24_pdd6 DRV_PINGROUP_ENTRY_Y(0x1074, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio25_pdd7 DRV_PINGROUP_ENTRY_Y(0x107c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio26_pee0 DRV_PINGROUP_ENTRY_Y(0x1084, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio27_pee1 DRV_PINGROUP_ENTRY_Y(0x108c, 12, 4, 20, 4, -1, -1, -1, -1, 0)
+#define drive_soc_gpio28_pee2 DRV_PINGROUP_ENTRY_N(no_entry)
+#define drive_soc_gpio29_pee3 DRV_PINGROUP_ENTRY_N(no_entry)
+
+
+#define PINGROUP(pg_name, f0, f1, f2, f3, r, bank, pupd, e_io_hv, e_lpbk, e_input, e_lpdr, e_pbias_buf,	\
+			gpio_sfio_sel, schmitt_b)							\
+	{								\
+		.name = #pg_name,					\
+		.pins = pg_name##_pins,					\
+		.npins = ARRAY_SIZE(pg_name##_pins),			\
+			.funcs = {					\
+				TEGRA_MUX_##f0,				\
+				TEGRA_MUX_##f1,				\
+				TEGRA_MUX_##f2,				\
+				TEGRA_MUX_##f3,				\
+			},						\
+		PIN_PINGROUP_ENTRY_Y(r, bank, pupd, e_io_hv, e_lpbk,	\
+					e_input, e_lpdr, e_pbias_buf,	\
+					gpio_sfio_sel, schmitt_b)	\
+		drive_##pg_name,					\
+	}
+
+static const struct tegra_pingroup tegra264_uphy_groups[] = {
+	PINGROUP(eth1_mdio_pe0, ETH1_MDIO, RSVD1, RSVD2, RSVD3, 0x0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l4_clkreq_n_pd0, PE4_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l4_rst_n_pd1, PE4_RST_L, RSVD1, RSVD2, RSVD3, 0x10, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l5_clkreq_n_pd2, PE5_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x18, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l5_rst_n_pd3, PE5_RST_L, RSVD1, RSVD2, RSVD3, 0x20, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth0_mdio_pd4, ETH0_MDIO, RSVD1, RSVD2, RSVD3, 0x28, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth0_mdc_pd5, ETH0_MDC, RSVD1, RSVD2, RSVD3, 0x30, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth1_mdc_pe1, ETH1_MDC, RSVD1, RSVD2, RSVD3, 0x38, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth2_mdio_pe2, ETH2_MDIO, RSVD1, RSVD2, RSVD3, 0x40, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth2_mdc_pe3, ETH2_MDC, RSVD1, RSVD2, RSVD3, 0x48, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth3_mdio_pd6, ETH3_MDIO, RSVD1, RSVD2, RSVD3, 0x50, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(eth3_mdc_pd7, ETH3_MDC, RSVD1, RSVD2, RSVD3, 0x58, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l1_clkreq_n_pb0, PE1_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x2000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l1_rst_n_pb1, PE1_RST_L, RSVD1, RSVD2, RSVD3, 0x2008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_wake_n_pc2, RSVD0, RSVD1, RSVD2, RSVD3, 0x2010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l2_rst_n_pb3, PE2_RST_L, RSVD1, RSVD2, RSVD3, 0x2018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l2_clkreq_n_pb2, PE2_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x2020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l3_clkreq_n_pb4, PE3_CLKREQ_L, RSVD1, RSVD2, RSVD3, 0x2028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pex_l3_rst_n_pb5, PE3_RST_L, RSVD1, RSVD2, RSVD3, 0x2030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(sgmii0_sma_mdio_pc0, SGMII0_SMA_MDIO, RSVD1, RSVD2, RSVD3, 0x2038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(sgmii0_sma_mdc_pc1, SGMII0_SMA_MDC, RSVD1, RSVD2, RSVD3, 0x2040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio113_pb6, USB_VBUS_EN0, RSVD1, RSVD2, RSVD3, 0x2048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio114_pb7, USB_VBUS_EN1, RSVD1, RSVD2, RSVD3, 0x2050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm1_pa0, GP_PWM1, RSVD1, RSVD2, RSVD3, 0x3000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm6_pa1, GP_PWM6, RSVD1, RSVD2, RSVD3, 0x3008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm7_pa2, GP_PWM7, RSVD1, RSVD2, RSVD3, 0x3010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm8_pa3, GP_PWM8, RSVD1, RSVD2, RSVD3, 0x3018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(ufs0_ref_clk_pa4, UFS0, RSVD1, RSVD2, RSVD3, 0x3020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(ufs0_rst_n_pa5, UFS0, RSVD1, RSVD2, RSVD3, 0x3028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+};
+
+static const struct tegra_pingroup tegra264_main_groups[] = {
+	PINGROUP(cpu_pwr_req_ph0, RSVD0, RSVD1, RSVD2, RSVD3, 0x0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gpu_pwr_req_ph1, RSVD0, RSVD1, RSVD2, RSVD3, 0x8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_cts_n_ph5, UARTK_CTS, RSVD1, RSVD2, RSVD3, 0x10, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_rts_n_ph4, UARTK_RTS, RSVD1, RSVD2, RSVD3, 0x18, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_rx_ph3, UARTK_RXD, RSVD1, RSVD2, RSVD3, 0x20, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart10_tx_ph2, UARTK_TXD, RSVD1, RSVD2, RSVD3, 0x28, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_cs0_pj1, SPI3_CS0, RSVD1, RSVD2, RSVD3, 0x30, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_cs3_pj2, SPI3_CS3, RSVD1, RSVD2, RSVD3, 0x38, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_miso_ph7, SPI3_DIN, RSVD1, RSVD2, RSVD3, 0x40, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_mosi_pj0, SPI3_DOUT, RSVD1, RSVD2, RSVD3, 0x48, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi3_sck_ph6, SPI3_SCK, RSVD1, RSVD2, RSVD3, 0x50, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_cts_n_pj6, UARTF_CTS, RSVD1, RSVD2, RSVD3, 0x58, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_rts_n_pj5, UARTF_RTS, RSVD1, RSVD2, RSVD3, 0x60, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_rx_pj4, UARTF_RXD, RSVD1, RSVD2, RSVD3, 0x68, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart5_tx_pj3, UARTF_TXD, RSVD1, RSVD2, RSVD3, 0x70, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_cs0_pk2, SPI1_CS0, RSVD1, RSVD2, RSVD3, 0x78, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_cs1_pk3, SPI1_CS1, RSVD1, RSVD2, RSVD3, 0x80, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_miso_pk0, SPI1_DIN, RSVD1, RSVD2, RSVD3, 0x88, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_mosi_pk1, SPI1_DOUT, RSVD1, RSVD2, RSVD3, 0x90, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi1_sck_pj7, SPI1_SCK, RSVD1, RSVD2, RSVD3, 0x98, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(extperiph2_clk_pk5, EXTPERIPH2_CLK, RSVD1, DMIC2_CLK, DSPK1_CLK, 0xa0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(extperiph1_clk_pk4, EXTPERIPH1_CLK, RSVD1, DMIC2_DAT, DSPK1_DAT, 0xa8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen12_i2c_scl_pk6, I2C12_CLK, RSVD1, RSVD2, RSVD3, 0xb0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen12_i2c_sda_pk7, I2C12_DAT, RSVD1, RSVD2, RSVD3, 0xb8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio124_pl0, RSVD0, SOC_THERM_OC3, RSVD2, RSVD3, 0x1000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio125_pl1, RSVD0, I2S5_SCLK, RSVD2, RSVD3, 0x1008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(fan_tach0_pl2, NV_THERM_FAN_TACH0, RSVD1, RSVD2, RSVD3, 0x1010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio127_pl3, RSVD0, RSVD1, NV_THERM_FAN_TACH1, RSVD3, 0x1018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio128_pl4, RSVD0, I2S5_SDATA_IN, RSVD2, RSVD3, 0x1020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio129_pl5, RSVD0, EXTPERIPH3_CLK, I2C15_CLK, RSVD3, 0x1028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio130_pl6, RSVD0, EXTPERIPH4_CLK, I2C15_DAT, RSVD3, 0x1030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio131_pl7, RSVD0, I2S5_SDATA_OUT, RSVD2, RSVD3, 0x1038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gp_pwm9_pm0, GP_PWM9, RSVD1, RSVD2, RSVD3, 0x1040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio133_pm1, RSVD0, I2S5_LRCK, RSVD2, RSVD3, 0x1048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_cts_n_pm5, UARTJ_CTS, RSVD1, RSVD2, RSVD3, 0x1050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_rts_n_pm4, UARTJ_RTS, RSVD1, RSVD2, RSVD3, 0x1058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_rx_pm3, UARTJ_RXD, RSVD1, RSVD2, RSVD3, 0x1060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart9_tx_pm2, UARTJ_TXD, RSVD1, RSVD2, RSVD3, 0x1068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(sdmmc1_clk_px0, SDMMC1_CLK, RSVD1, RSVD2, RSVD3, 0x2000, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_cmd_px1, SDMMC1_CMD, RSVD1, RSVD2, RSVD3, 0x2008, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_comp, SDMMC1_COMP, RSVD1, RSVD2, RSVD3, 0x2010, 0, N, -1, -1, -1, -1, -1, -1, -1),
+	PINGROUP(sdmmc1_dat3_px5, SDMMC1_DAT3, RSVD1, RSVD2, RSVD3, 0x2018, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_dat2_px4, SDMMC1_DAT2, RSVD1, RSVD2, RSVD3, 0x2020, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_dat1_px3, SDMMC1_DAT1, RSVD1, RSVD2, RSVD3, 0x2028, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(sdmmc1_dat0_px2, SDMMC1_DAT0, RSVD1, RSVD2, RSVD3, 0x2030, 0, Y, -1, 5, 6, 13, -1, 10, -1),
+	PINGROUP(qspi0_cs_n_pt1, QSPI0_CS_N, RSVD1, RSVD2, RSVD3, 0x3000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io0_pt2, QSPI0_IO0, RSVD1, RSVD2, RSVD3, 0x3008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io1_pt3, QSPI0_IO1, RSVD1, RSVD2, RSVD3, 0x3010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io2_pt4, QSPI0_IO2, RSVD1, RSVD2, RSVD3, 0x3018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_io3_pt5, QSPI0_IO3, RSVD1, RSVD2, RSVD3, 0x3020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(qspi0_sck_pt0, QSPI0_SCK, RSVD1, RSVD2, RSVD3, 0x3028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio192_pt6, RSVD0, RSVD1, RSVD2, RSVD3, 0x3030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio138_pp0, RSVD0, I2C14_CLK, DMIC1_DAT, RSVD3, 0x5000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio139_pp1, RSVD0, I2C14_DAT, DMIC1_CLK, RSVD3, 0x5008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_din_pp4, I2S6_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x5010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_dout_pp3, I2S6_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x5018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_fs_pp5, I2S6_LRCK, RSVD1, RSVD2, RSVD3, 0x5020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap6_sclk_pp2, I2S6_SCLK, RSVD1, RSVD2, RSVD3, 0x5028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_dout_pp7, I2S4_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x5030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_sclk_pp6, I2S4_SCLK, RSVD1, RSVD2, RSVD3, 0x5038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_din_pq0, I2S4_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x5040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap4_fs_pq1, I2S4_LRCK, RSVD1, RSVD2, RSVD3, 0x5048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_cs0_pq5, SPI5_CS0, RSVD1, RSVD2, RSVD3, 0x5050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_miso_pq3, SPI5_DIN, RSVD1, RSVD2, RSVD3, 0x5058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_mosi_pq4, SPI5_DOUT, RSVD1, RSVD2, RSVD3, 0x5060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi5_sck_pq2, SPI5_SCK, RSVD1, RSVD2, RSVD3, 0x5068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio152_pq6, RSVD0, I2S8_SCLK, RSVD2, RSVD3, 0x5070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio153_pq7, RSVD0, I2S8_SDATA_OUT, RSVD2, RSVD3, 0x5078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio155_pr1, RSVD0, I2S8_LRCK, RSVD2, RSVD3, 0x5080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(aud_mclk_pr0, AUD_MCLK, RSVD1, RSVD2, RSVD3, 0x5088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_sclk_pr2, I2S1_SCLK, RSVD1, RSVD2, RSVD3, 0x5090, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_in_pr4, I2S1_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x5098, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_out_pr3, I2S1_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x50a0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap1_fs_pr5, I2S1_LRCK, RSVD1, RSVD2, RSVD3, 0x50a8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen11_i2c_scl_pr6, I2C11_CLK, RSVD1, RSVD2, RSVD3, 0x50b0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen11_i2c_sda_pr7, I2C11_DAT, RSVD1, RSVD2, RSVD3, 0x50b8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio350_ps0, RSVD0, I2S8_SDATA_IN, RSVD2, RSVD3, 0x50c0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio351_ps1, RSVD0, RSVD1, RSVD2, RSVD3, 0x50c8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen0_i2c_scl_pw4, I2C0_CLK, RSVD1, RSVD2, RSVD3, 0x6000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen0_i2c_sda_pw5, I2C0_DAT, RSVD1, RSVD2, RSVD3, 0x6008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen1_i2c_scl_pw2, I2C1_CLK, RSVD1, RSVD2, RSVD3, 0x6010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen1_i2c_sda_pw3, I2C1_DAT, RSVD1, RSVD2, RSVD3, 0x6018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_fs_pw1, I2S2_LRCK, RSVD1, RSVD2, RSVD3, 0x6040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_clk_pv6, I2S2_SCLK, RSVD1, RSVD2, RSVD3, 0x6048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_din_pw0, I2S2_SDATA_IN, RSVD1, RSVD2, RSVD3, 0x6050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dap2_dout_pv7, I2S2_SDATA_OUT, RSVD1, RSVD2, RSVD3, 0x6058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm10_pv1, GP_PWM10, SDMMC1_CD, I2S7_LRCK, RSVD3, 0x6060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio170_pu0, RSVD0, I2S7_SDATA_IN, CCLA_LA_TRIGGER_MUX, RSVD3, 0x6068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio171_pu1, RSVD0, SPI4_SCK, RSVD2, RSVD3, 0x6070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio172_pu2, RSVD0, SPI4_DIN, RSVD2, RSVD3, 0x6078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio173_pu3, RSVD0, SPI4_DOUT, RSVD2, RSVD3, 0x6080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio174_pu4, RSVD0, SPI4_CS0, RSVD2, RSVD3, 0x6088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio175_pu5, RSVD0, SPI4_CS1, RSVD2, RSVD3, 0x6090, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio176_pu6, RSVD0, RSVD1, I2S7_SCLK, RSVD3, 0x6098, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio177_pu7, RSVD0, GP_PWM5, RSVD2, RSVD3, 0x60a0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio178_pv0, RSVD0, RSVD1, I2S7_SDATA_OUT, RSVD3, 0x60a8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_cts_n_pv5, UARTE_CTS, RSVD1, RSVD2, RSVD3, 0x60b0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_rts_n_pv4, UARTE_RTS, RSVD1, RSVD2, RSVD3, 0x60b8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_rx_pv3, UARTE_RXD, RSVD1, RSVD2, RSVD3, 0x60c0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart4_tx_pv2, UARTE_TXD, RSVD1, RSVD2, RSVD3, 0x60c8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwr_i2c_sda_pw7, I2C5_DAT, RSVD1, RSVD2, RSVD3, 0x60d0, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwr_i2c_scl_pw6, I2C5_CLK, RSVD1, RSVD2, RSVD3, 0x60d8, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio250_pf0, DCA_VSYNC, DCB_VSYNC, DCC_VSYNC, DCD_VSYNC, 0x7000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio251_pf1, DCA_HSYNC, DCB_HSYNC, DCC_HSYNC, DCD_HSYNC, 0x7008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio252_pf2, RSVD0, DSA_LSPII, RSVD2, RSVD3, 0x7010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch0_hpd_pf3, DP_AUX_CH0_HPD, DCE_VSYNC, DCF_VSYNC, DCG_VSYNC, 0x7018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch1_hpd_pf4, DP_AUX_CH1_HPD, DCE_HSYNC, DCF_HSYNC, DCG_HSYNC, 0x7020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch2_hpd_pf5, DP_AUX_CH2_HPD, DCH_VSYNC, RSVD2, RSVD3, 0x7028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(dp_aux_ch3_hpd_pf6, DP_AUX_CH3_HPD, DCH_HSYNC, RSVD2, RSVD3, 0x7030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm2_pf7, GP_PWM2, BL_EN, RSVD2, RSVD3, 0x7038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(pwm3_pg0, GP_PWM3, BL_PWM_DIM0, RSVD2, RSVD3, 0x7040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen7_i2c_scl_pg1, I2C7_CLK, RSVD1, SOUNDWIRE1_CLK, RSVD3, 0x7048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen7_i2c_sda_pg2, I2C7_DAT, RSVD1, SOUNDWIRE1_DAT0, RSVD3, 0x7050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen9_i2c_scl_pg3, I2C9_CLK, RSVD1, SOUNDWIRE1_DAT1, RSVD3, 0x7058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen9_i2c_sda_pg4, I2C9_DAT, RSVD1, SOUNDWIRE1_DAT2, RSVD3, 0x7060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio270_py0, RSVD0, I2C16_CLK, RSVD2, RSVD3, 0xa000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio271_py1, RSVD0, I2C16_DAT, RSVD2, RSVD3, 0xa008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio272_py2, RSVD0, I2S3_SCLK, RSVD2, RSVD3, 0xa010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio273_py3, RSVD0, I2S3_SDATA_OUT, RSVD2, RSVD3, 0xa018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio274_py4, RSVD0, I2S3_SDATA_IN, RSVD2, RSVD3, 0xa020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio275_py5, RSVD0, I2S3_LRCK, RSVD2, RSVD3, 0xa028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio276_py6, RSVD0, RSVD1, RSVD2, RSVD3, 0xa030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio277_py7, RSVD0, RSVD1, RSVD2, RSVD3, 0xa038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio278_pz0, RSVD0, RSVD1, RSVD2, RSVD3, 0xa040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio279_pz1, RSVD0, RSVD1, RSVD2, RSVD3, 0xa048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio282_pz4, RSVD0, PM_TRIG1, RSVD2, RSVD3, 0xa050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio283_pz5, RSVD0, RSVD1, RSVD2, RSVD3, 0xa058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio284_pz6, RSVD0, RSVD1, RSVD2, RSVD3, 0xa060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio285_pz7, RSVD0, RSVD1, RSVD2, RSVD3, 0xa068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio286_pal0, RSVD0, RSVD1, RSVD2, RSVD3, 0xa070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio287_pal1, RSVD0, RSVD1, RSVD2, RSVD3, 0xa078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio288_pal2, RSVD0, RSVD1, RSVD2, RSVD3, 0xa080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(xhalt_trig_pz2, XHALT_TRIG, RSVD1, RSVD2, RSVD3, 0xa088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio281_pz3, RSVD0, PM_TRIG0, RSVD2, RSVD3, 0xa090, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+};
+
+static const struct tegra_pingroup tegra264_aon_groups[] = {
+	PINGROUP(ao_retention_n_paa2, RSVD0, RSVD1, RSVD2, ISTCTRL_IST_DONE_N, 0x28, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(batt_oc_paa3, SOC_THERM_OC2, RSVD1, RSVD2, RSVD3, 0x30, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(power_on_paa5, RSVD0, RSVD1, RSVD2, RSVD3, 0x38, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(vcomp_alert_paa1, SOC_THERM_OC1, RSVD1, RSVD2, RSVD3, 0x40, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(bootv_ctl_n_paa4, RSVD0, RSVD1, RSVD2, RSVD3, 0x48, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio00_paa0, RSVD0, RSVD1, RSVD2, RSVD3, 0x50, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio07_paa7, RSVD0, RSVD1, RSVD2, RSVD3, 0x58, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio08_pbb0, RSVD0, RSVD1, RSVD2, RSVD3, 0x60, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio09_pbb1, RSVD0, RSVD1, RSVD2, RSVD3, 0x68, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(hdmi_cec_paa6, HDMI_CEC, RSVD1, RSVD2, RSVD3, 0x70, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen2_i2c_scl_pcc0, I2C2_CLK, RSVD1, RSVD2, RSVD3, 0x1000, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen2_i2c_sda_pcc1, I2C2_DAT, RSVD1, RSVD2, RSVD3, 0x1008, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen3_i2c_scl_pcc2, I2C3_CLK, RSVD1, RSVD2, RSVD3, 0x1010, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gen3_i2c_sda_pcc3, I2C3_DAT, RSVD1, RSVD2, RSVD3, 0x1018, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(gp_pwm4_pcc4, GP_PWM4, TOUCH_CLK, RSVD2, RSVD3, 0x1020, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart0_tx_pcc5, UARTA_TXD, RSVD1, UARTL_TXD, RSVD3, 0x1028, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(uart0_rx_pcc6, UARTA_RXD, RSVD1, UARTL_RXD, RSVD3, 0x1030, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_sck_pcc7, SPI2_SCK, RSVD1, I2S9_SCLK, SOUNDWIRE0_CLK, 0x1038, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_miso_pdd0, SPI2_DIN, RSVD1, I2S9_SDATA_OUT, SOUNDWIRE0_DAT0, 0x1040, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_mosi_pdd1, SPI2_DOUT, RSVD1, I2S9_SDATA_IN, RSVD3, 0x1048, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(spi2_cs0_n_pdd2, SPI2_CS0, RSVD1, I2S9_LRCK, RSVD3, 0x1050, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio21_pdd3, RSVD0, TSC_SYNC1, DMIC5_DAT, RSVD3, 0x1058, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio22_pdd4, RSVD0, RSVD1, DMIC5_CLK, RSVD3, 0x1060, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio23_pdd5, RSVD0, RSVD1, TSC_EDGE_OUT2, TSC_EDGE_OUT0C, 0x1068, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio24_pdd6, RSVD0, TSC_EDGE_OUT3, RSVD2, TSC_EDGE_OUT0D, 0x1070, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio25_pdd7, RSVD0, TSC_EDGE_OUT0, RSVD2, TSC_EDGE_OUT0A, 0x1078, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio26_pee0, RSVD0, TSC_EDGE_OUT1, RSVD2, TSC_EDGE_OUT0B, 0x1080, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio27_pee1, RSVD0, TSC_SYNC0, RSVD2, RSVD3, 0x1088, 0, Y, 5, 7, 6, 8, -1, 10, 11),
+	PINGROUP(soc_gpio28_pee2, L0L1_RST_OUT_N, RSVD1, RSVD2, RSVD3, 0x1090, 0, N, -1, -1, -1, -1, -1, 10, -1),
+	PINGROUP(soc_gpio29_pee3, L2_RST_OUT_N, RSVD1, RSVD2, RSVD3, 0x1098, 0, N, -1, -1, -1, -1, -1, 10, -1),
+};
+
+static const struct tegra_pinctrl_soc_data tegra264_uphy_pinctrl = {
+	.pins = tegra264_uphy_pins,
+	.npins = ARRAY_SIZE(tegra264_uphy_pins),
+	.functions = tegra264_functions,
+	.nfunctions = ARRAY_SIZE(tegra264_functions),
+	.groups = tegra264_uphy_groups,
+	.ngroups = ARRAY_SIZE(tegra264_uphy_groups),
+	.hsm_in_mux = false,
+	.schmitt_in_mux = true,
+	.drvtype_in_mux = true,
+	.sfsel_in_mux = true,
+};
+
+static const struct tegra_pinctrl_soc_data tegra264_main_pinctrl = {
+	.pins = tegra264_main_pins,
+	.npins = ARRAY_SIZE(tegra264_main_pins),
+	.functions = tegra264_functions,
+	.nfunctions = ARRAY_SIZE(tegra264_functions),
+	.groups = tegra264_main_groups,
+	.ngroups = ARRAY_SIZE(tegra264_main_groups),
+	.hsm_in_mux = false,
+	.schmitt_in_mux = true,
+	.drvtype_in_mux = true,
+	.sfsel_in_mux = true,
+};
+
+static const struct tegra_pinctrl_soc_data tegra264_aon_pinctrl = {
+	.pins = tegra264_aon_pins,
+	.npins = ARRAY_SIZE(tegra264_aon_pins),
+	.functions = tegra264_functions,
+	.nfunctions = ARRAY_SIZE(tegra264_functions),
+	.groups = tegra264_aon_groups,
+	.ngroups = ARRAY_SIZE(tegra264_aon_groups),
+	.hsm_in_mux = false,
+	.schmitt_in_mux = true,
+	.drvtype_in_mux = true,
+	.sfsel_in_mux = true,
+};
+
+static int tegra264_pinctrl_probe(struct platform_device *pdev)
+{
+	const struct tegra_pinctrl_soc_data *soc = device_get_match_data(&pdev->dev);
+
+	return tegra_pinctrl_probe(pdev, soc);
+}
+
+static const struct of_device_id tegra264_pinctrl_of_match[] = {
+	{ .compatible = "nvidia,tegra264-pinmux-uphy", .data = &tegra264_uphy_pinctrl},
+	{ .compatible = "nvidia,tegra264-pinmux-main", .data = &tegra264_main_pinctrl},
+	{ .compatible = "nvidia,tegra264-pinmux-aon", .data = &tegra264_aon_pinctrl},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tegra264_pinctrl_of_match);
+
+static struct platform_driver tegra264_pinctrl_driver = {
+	.driver = {
+		.name = "tegra264-pinctrl",
+		.of_match_table = tegra264_pinctrl_of_match,
+	},
+	.probe = tegra264_pinctrl_probe,
+};
+
+static int __init tegra264_pinctrl_init(void)
+{
+		return platform_driver_register(&tegra264_pinctrl_driver);
+}
+arch_initcall(tegra264_pinctrl_init);
-- 
2.51.0


From a648188a1869c4545382d5498eb9e3acfa946a11 Mon Sep 17 00:00:00 2001
From: Laxman Dewangan <ldewangan@nvidia.com>
Date: Sat, 24 Aug 2024 10:27:30 +0000
Subject: [PATCH 05/21] NVIDIA: SAUCE: pinctrl: Remove duplication of
 PINCTRL_TEGRA264 definition

Remove the duplication of conifg definition in the Kconfigs.

Add the PINCTRL_TEGRA264 in one place and select when
CONFIG_ARCH_TEGRA_264_SOC is enabled in defconfig.

Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/pinctrl/Kconfig   | 7 -------
 drivers/soc/tegra/Kconfig | 1 +
 2 files changed, 1 insertion(+), 7 deletions(-)

diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index d255c6fb137d..354536de564b 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -31,13 +31,6 @@ config DEBUG_PINCTRL
 	help
 	  Say Y here to add some extra checks and diagnostics to PINCTRL calls.
 
-config PINCTRL_TEGRA264
-	bool "NVIDIA Tegra264 Pinmux support"
-	select PINCTRL_TEGRA
-	default y
-	help
-	Support for the NVIDIA Tegra264 PINCTRL controller driver.
-
 config PINCTRL_AMD
 	bool "AMD GPIO pin control"
 	depends on HAS_IOMEM
diff --git a/drivers/soc/tegra/Kconfig b/drivers/soc/tegra/Kconfig
index 9392c2c43cc8..b838a8561c5e 100644
--- a/drivers/soc/tegra/Kconfig
+++ b/drivers/soc/tegra/Kconfig
@@ -133,6 +133,7 @@ config ARCH_TEGRA_264_SOC
 	bool "NVIDIA Tegra264 SoC"
 	depends on !CPU_BIG_ENDIAN
 	select MAILBOX
+	select PINCTRL_TEGRA264
 	select SOC_TEGRA_PMC
 	help
 	  Enable support for the NVIDIA Tegra264 SoC.
-- 
2.51.0


From 8ec52d08332d507cb5fddfb4b5c7a7468cf8ebf1 Mon Sep 17 00:00:00 2001
From: Gautham Srinivasan <gauthams@nvidia.com>
Date: Wed, 17 Jul 2024 10:22:32 +0000
Subject: [PATCH 06/21] NVIDIA: SAUCE: gpio-tegra: enable GTE for T264

Set has_gte flag to enable GTE for T264 AON pins.

Signed-off-by: Gautham Srinivasan <gauthams@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/gpio/gpio-tegra186.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/gpio/gpio-tegra186.c b/drivers/gpio/gpio-tegra186.c
index 76eaf4f44a29..fe63bc9a5be2 100644
--- a/drivers/gpio/gpio-tegra186.c
+++ b/drivers/gpio/gpio-tegra186.c
@@ -1361,6 +1361,7 @@ static const struct tegra_gpio_soc tegra264_aon_soc = {
 	.instance = 1,
 	.num_irqs_per_bank = 8,
 	.has_vm_support = true,
+	.has_gte = true,
 };
 
 static const struct of_device_id tegra186_gpio_of_match[] = {
-- 
2.51.0


From d142a0c31b2ea56f74ef201c2d07cdbce543f62c Mon Sep 17 00:00:00 2001
From: Nick Cao <nickcao@nichi.co>
Date: Mon, 27 Oct 2025 12:34:16 -0400
Subject: [PATCH 07/21] fixup! soc/tegra: pmc: Add Tegra264 support

---
 drivers/soc/tegra/pmc.c | 11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/drivers/soc/tegra/pmc.c b/drivers/soc/tegra/pmc.c
index da7309c1acfa..3eafe3fc7457 100644
--- a/drivers/soc/tegra/pmc.c
+++ b/drivers/soc/tegra/pmc.c
@@ -2892,9 +2892,14 @@ static int tegra_pmc_probe(struct platform_device *pdev)
 		if (IS_ERR(pmc->wake))
 			return PTR_ERR(pmc->wake);
 
-		pmc->aotag = devm_platform_ioremap_resource_byname(pdev, "aotag");
-		if (IS_ERR(pmc->aotag))
-			return PTR_ERR(pmc->aotag);
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "aotag");
+		if (res) {
+			pmc->aotag = devm_ioremap_resource(&pdev->dev, res);
+			if (IS_ERR(pmc->aotag))
+				return PTR_ERR(pmc->aotag);
+		} else {
+			pmc->aotag = NULL;
+		}
 
 		/* "scratch" is an optional aperture */
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-- 
2.51.0


From d6538159ad904c615e2ecc71aeab9b6c8ba74023 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Thu, 20 Jun 2024 06:11:39 +0000
Subject: [PATCH 08/21] NVIDIA: SAUCE: phy: xusb: skip USB2 PAD tracking and
 fuse

The USB2 PAD tracking clock is not necessary a dedicated clock.
And fuse settings is not ready for everyone in this stage.

http://nvbugs/4703456

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/phy/tegra/xusb-tegra186.c | 17 +++++++++++++----
 drivers/phy/tegra/xusb.h          |  1 +
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/drivers/phy/tegra/xusb-tegra186.c b/drivers/phy/tegra/xusb-tegra186.c
index b6dee225bc15..1a2fc809ebd5 100644
--- a/drivers/phy/tegra/xusb-tegra186.c
+++ b/drivers/phy/tegra/xusb-tegra186.c
@@ -905,6 +905,11 @@ static int tegra186_utmi_phy_power_on(struct phy *phy)
 	value = padctl_readl(padctl, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));
 	value &= ~USB2_OTG_PD_ZI;
 	value |= TERM_SEL;
+
+	if (padctl->soc->ignore_fuse) {
+                padctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL0(index));
+                goto ignore_fuse;
+	}
 	value &= ~HS_CURR_LEVEL(~0);
 
 	if (usb2->hs_curr_level_offset) {
@@ -932,6 +937,7 @@ static int tegra186_utmi_phy_power_on(struct phy *phy)
 	value |= RPD_CTRL(priv->calib.rpd_ctrl);
 	padctl_writel(padctl, value, XUSB_PADCTL_USB2_OTG_PADX_CTL1(index));
 
+ignore_fuse:
 	tegra186_utmi_pad_power_on(phy);
 
 	return 0;
@@ -1042,7 +1048,7 @@ tegra186_usb2_pad_probe(struct tegra_xusb_padctl *padctl,
 		goto out;
 	}
 
-	priv->usb2_trk_clk = devm_clk_get(&pad->dev, "trk");
+	priv->usb2_trk_clk = devm_clk_get_optional(&pad->dev, "trk");
 	if (IS_ERR(priv->usb2_trk_clk)) {
 		err = PTR_ERR(priv->usb2_trk_clk);
 		dev_dbg(&pad->dev, "failed to get usb2 trk clock: %d\n", err);
@@ -1524,9 +1530,11 @@ tegra186_xusb_padctl_probe(struct device *dev,
 	if (IS_ERR(priv->ao_regs))
 		return ERR_CAST(priv->ao_regs);
 
-	err = tegra186_xusb_read_fuse_calibration(priv);
-	if (err < 0)
-		return ERR_PTR(err);
+	if (!soc->ignore_fuse) {
+		err = tegra186_xusb_read_fuse_calibration(priv);
+		if (err < 0)
+			return ERR_PTR(err);
+	}
 
 	return &priv->base;
 }
@@ -1753,6 +1761,7 @@ const struct tegra_xusb_padctl_soc tegra264_xusb_padctl_soc = {
 	.poll_trk_completed = true,
 	.trk_hw_mode = true,
 	.supports_lp_cfg_en = true,
+	.ignore_fuse = true,
 };
 EXPORT_SYMBOL_GPL(tegra264_xusb_padctl_soc);
 #endif
diff --git a/drivers/phy/tegra/xusb.h b/drivers/phy/tegra/xusb.h
index b3302e9c7896..b6266b3ee1c9 100644
--- a/drivers/phy/tegra/xusb.h
+++ b/drivers/phy/tegra/xusb.h
@@ -436,6 +436,7 @@ struct tegra_xusb_padctl_soc {
 	bool trk_hw_mode;
 	bool trk_update_on_idle;
 	bool supports_lp_cfg_en;
+	bool ignore_fuse;
 };
 
 struct tegra_xusb_padctl {
-- 
2.51.0


From dfb7a1f94ef8303edee00a5b698ac5c9e9d928a6 Mon Sep 17 00:00:00 2001
From: Sing-Han Chen <singhanc@nvidia.com>
Date: Tue, 18 Jun 2024 06:59:42 +0000
Subject: [PATCH 09/21] NVIDIA: SAUCE: usb: xhci: skip mbox configuration

This change skips the mbox configuration for the
project that doesn't need this.

http://nvbugs/4703456

Signed-off-by: Sing-Han Chen <singhanc@nvidia.com>
Signed-off-by: Bodla Rakesh Babu <rbodla@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/usb/host/xhci-tegra.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/drivers/usb/host/xhci-tegra.c b/drivers/usb/host/xhci-tegra.c
index 718e2ae6cd21..2839f22c7f01 100644
--- a/drivers/usb/host/xhci-tegra.c
+++ b/drivers/usb/host/xhci-tegra.c
@@ -243,6 +243,7 @@ struct tegra_xusb_soc {
 	bool scale_ss_clock;
 	bool has_ipfs;
 	bool lpm_support;
+	bool skip_mbox_config;
 	bool otg_reset_sspi;
 
 	bool has_bar2;
@@ -1247,6 +1248,9 @@ static int __tegra_xusb_enable_firmware_messages(struct tegra_xusb *tegra)
 	struct tegra_xusb_mbox_msg msg;
 	int err;
 
+	if (tegra->soc->skip_mbox_config)
+		return 0;
+
 	/* Enable firmware messages from controller. */
 	msg.cmd = MBOX_CMD_MSG_ENABLED;
 	msg.data = 0;
@@ -2677,6 +2681,7 @@ static const struct tegra_xusb_soc tegra264_soc = {
 		.owner = XUSB_BAR2_ARU_MBOX_OWNER,
 		.smi_intr = XUSB_BAR2_ARU_SMI_INTR,
 	},
+	.skip_mbox_config = true,
 	.lpm_support = true,
 	.has_bar2 = true,
 };
-- 
2.51.0


From 002a2e585738b3412e32f42bc62e2ff8bb799e8d Mon Sep 17 00:00:00 2001
From: Wayne Chang <waynec@nvidia.com>
Date: Tue, 13 Aug 2024 02:40:11 +0000
Subject: [PATCH 10/21] NVIDIA: SAUCE: phy: tegra: Increase timeout for
 USB2_TRK_COMPLETED polling

BugLink: https://bugs.launchpad.net/bugs/2080908

The timeout for polling on USB2_TRK_COMPLETED in the UTMI bias pad
power-on sequence has been increased from 100 to 200 cycles.

This change is necessary due to the increased number of cycles required
to settle all biases in the new circuits. Additionally, the clock speed
of the tracking circuit has been reduced to 1 MHz, further contributing
to the need for a longer timeout.

http://nvbugs/4796326

Signed-off-by: Wayne Chang <waynec@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/phy/tegra/xusb-tegra186.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/phy/tegra/xusb-tegra186.c b/drivers/phy/tegra/xusb-tegra186.c
index 1a2fc809ebd5..a24e3db8d5b5 100644
--- a/drivers/phy/tegra/xusb-tegra186.c
+++ b/drivers/phy/tegra/xusb-tegra186.c
@@ -633,7 +633,7 @@ static void tegra186_utmi_bias_pad_power_on(struct tegra_xusb_padctl *padctl)
 
 	if (padctl->soc->poll_trk_completed) {
 		err = padctl_readl_poll(padctl, XUSB_PADCTL_USB2_BIAS_PAD_CTL1,
-					USB2_TRK_COMPLETED, USB2_TRK_COMPLETED, 100);
+					USB2_TRK_COMPLETED, USB2_TRK_COMPLETED, 200);
 		if (err) {
 			/* The failure with polling on trk complete will not
 			 * cause the failure of powering on the bias pad.
-- 
2.51.0


From b67c9fab9b83e0ce08e2fab52ca90fc96a20caa4 Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 4 Nov 2022 15:47:29 +0530
Subject: [PATCH 11/21] NVIDIA: SAUCE: dmaengine: tegra: Get slave channel
 based on DT

BugLink: https://bugs.launchpad.net/bugs/2072591

Add option for DMA clients to provide channel number and
stream-id in device tree. dma-cells need to be increased to 3
for accommodating additional details.

This is required in a virtualized environment where all channels
and clients are not allowed use the same stream id.

The channel number read from device tree is modified to match with
the hardware channel number in the driver. This is done to avoid
ABI breakage. Otherwise, it would require updating all the device
trees that provide this information

http://nvbugs/200761027

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Reviewed-by: Bitan Biswas <bbiswas@nvidia.com>
Reviewed-by: Abhilash G <abhilashg@nvidia.com>
Tested-by: Abhilash G <abhilashg@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 78 ++++++++++++++++++++++++++--------
 1 file changed, 61 insertions(+), 17 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index 4d6fe0efa76e..b1e02848d968 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -1288,10 +1288,54 @@ static void tegra_dma_free_chan_resources(struct dma_chan *dc)
 	vchan_free_chan_resources(&tdc->vc);
 }
 
-static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
-					   struct of_dma *ofdma)
+static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
+{
+	unsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+
+	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);
+	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
+
+	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);
+	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);
+
+	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);
+	return 0;
+}
+
+static struct dma_chan *tegra_dma_get_slave_channel(struct tegra_dma *tdma,
+					    struct of_phandle_args *dma_spec)
+{
+	struct tegra_dma_channel *tdc;
+	struct dma_chan *chan;
+	unsigned int chan_id;
+
+
+	chan_id = dma_spec->args[1];
+	if (chan_id > hweight_long(tdma->chan_mask))
+		return NULL;
+
+	/* Adjust the chan_id as channel id from
+	 * DT is starting from an offset
+	 */
+	chan_id += (ffs(tdma->chan_mask) - 1);
+
+	chan = dma_get_slave_channel(&tdma->channels[chan_id].vc.chan);
+	if (!chan)
+		return NULL;
+
+	tdc = to_tegra_dma_chan(chan);
+	tdc->slave_id = dma_spec->args[0];
+	tdc->stream_id = dma_spec->args[2];
+
+	/* Re-program stream-id for this channel */
+	tegra_dma_program_sid(tdc, tdc->stream_id);
+
+	return chan;
+}
+
+static struct dma_chan *tegra_dma_get_any_slave_channel(struct tegra_dma *tdma,
+					    struct of_phandle_args *dma_spec)
 {
-	struct tegra_dma *tdma = ofdma->of_dma_data;
 	struct tegra_dma_channel *tdc;
 	struct dma_chan *chan;
 
@@ -1305,6 +1349,20 @@ static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
 	return chan;
 }
 
+static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
+					   struct of_dma *ofdma)
+{
+	struct tegra_dma *tdma = ofdma->of_dma_data;
+
+	/* Check if channel no and stream-id are specified in devicetree.
+	 * Get any channel and program default stream-id otherwise
+	 */
+	if (dma_spec->args_count == 3)
+		return tegra_dma_get_slave_channel(tdma, dma_spec);
+
+	return tegra_dma_get_any_slave_channel(tdma, dma_spec);
+}
+
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
 	.channel_reg_size = SZ_64K,
@@ -1344,20 +1402,6 @@ static const struct of_device_id tegra_dma_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, tegra_dma_of_match);
 
-static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
-{
-	unsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
-
-	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);
-	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
-
-	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);
-	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);
-
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);
-	return 0;
-}
-
 static int tegra_dma_probe(struct platform_device *pdev)
 {
 	const struct tegra_dma_chip_data *cdata = NULL;
-- 
2.51.0


From c19e3d47b2a474e471028b7eb8f9641743278568 Mon Sep 17 00:00:00 2001
From: Manish Bhardwaj <mbhardwaj@nvidia.com>
Date: Sat, 15 Jun 2024 19:58:46 +0000
Subject: [PATCH 12/21] NVIDIA: SAUCE: gpcdma: fix crash in gpcdma driver

BugLink: https://bugs.launchpad.net/bugs/2080908

since we are using the dedicated channel for IPs
using gpcdma channel, check wether that channel
is enabled or not before assigning it.

https://jirasw.nvidia.com/browse/ESLC-7980

Signed-off-by: Manish Bhardwaj <mbhardwaj@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index b1e02848d968..b63dd0322050 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -1311,13 +1311,9 @@ static struct dma_chan *tegra_dma_get_slave_channel(struct tegra_dma *tdma,
 
 
 	chan_id = dma_spec->args[1];
-	if (chan_id > hweight_long(tdma->chan_mask))
+	if (!(tdma->chan_mask & (1 << (chan_id)))) {
 		return NULL;
-
-	/* Adjust the chan_id as channel id from
-	 * DT is starting from an offset
-	 */
-	chan_id += (ffs(tdma->chan_mask) - 1);
+	}
 
 	chan = dma_get_slave_channel(&tdma->channels[chan_id].vc.chan);
 	if (!chan)
-- 
2.51.0


From dc1813814725a8a565a5548ec58cd7d2cf9596f3 Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 28 Jul 2023 21:11:58 +0530
Subject: [PATCH 13/21] NVIDIA: SAUCE: dmaengine: tegra: Use struct for
 register offsets

Move all DMA channel registers to a struct and update all register reads
accordingly. This is done to accomodate Tegra264 GPCDMA where the
register offsets are different from what we have currently in the
driver.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
[nwager: Enum renaming due to new upstream noble commit:
dea982a7df4b ("dmaengine: tegra: Return correct DMA status when paused")]
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 282 +++++++++++++++++----------------
 1 file changed, 148 insertions(+), 134 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index b63dd0322050..9b5bca55b9dc 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -22,7 +22,6 @@
 #include "virt-dma.h"
 
 /* CSR register */
-#define TEGRA_GPCDMA_CHAN_CSR			0x00
 #define TEGRA_GPCDMA_CSR_ENB			BIT(31)
 #define TEGRA_GPCDMA_CSR_IE_EOC			BIT(30)
 #define TEGRA_GPCDMA_CSR_ONCE			BIT(27)
@@ -58,7 +57,6 @@
 #define TEGRA_GPCDMA_CSR_WEIGHT			GENMASK(13, 10)
 
 /* STATUS register */
-#define TEGRA_GPCDMA_CHAN_STATUS		0x004
 #define TEGRA_GPCDMA_STATUS_BUSY		BIT(31)
 #define TEGRA_GPCDMA_STATUS_ISE_EOC		BIT(30)
 #define TEGRA_GPCDMA_STATUS_PING_PONG		BIT(28)
@@ -70,22 +68,13 @@
 #define TEGRA_GPCDMA_STATUS_IRQ_STA		BIT(21)
 #define TEGRA_GPCDMA_STATUS_IRQ_TRIG_STA	BIT(20)
 
-#define TEGRA_GPCDMA_CHAN_CSRE			0x008
 #define TEGRA_GPCDMA_CHAN_CSRE_PAUSE		BIT(31)
 
-/* Source address */
-#define TEGRA_GPCDMA_CHAN_SRC_PTR		0x00C
-
-/* Destination address */
-#define TEGRA_GPCDMA_CHAN_DST_PTR		0x010
-
 /* High address pointer */
-#define TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR		0x014
 #define TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR		GENMASK(7, 0)
 #define TEGRA_GPCDMA_HIGH_ADDR_DST_PTR		GENMASK(23, 16)
 
 /* MC sequence register */
-#define TEGRA_GPCDMA_CHAN_MCSEQ			0x18
 #define TEGRA_GPCDMA_MCSEQ_DATA_SWAP		BIT(31)
 #define TEGRA_GPCDMA_MCSEQ_REQ_COUNT		GENMASK(30, 25)
 #define TEGRA_GPCDMA_MCSEQ_BURST		GENMASK(24, 23)
@@ -101,7 +90,6 @@
 #define TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK	GENMASK(6, 0)
 
 /* MMIO sequence register */
-#define TEGRA_GPCDMA_CHAN_MMIOSEQ			0x01c
 #define TEGRA_GPCDMA_MMIOSEQ_DBL_BUF		BIT(31)
 #define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH		GENMASK(30, 28)
 #define TEGRA_GPCDMA_MMIOSEQ_BUS_WIDTH_8	\
@@ -120,17 +108,7 @@
 #define TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD		GENMASK(18, 16)
 #define TEGRA_GPCDMA_MMIOSEQ_MMIO_PROT		GENMASK(8, 7)
 
-/* Channel WCOUNT */
-#define TEGRA_GPCDMA_CHAN_WCOUNT		0x20
-
-/* Transfer count */
-#define TEGRA_GPCDMA_CHAN_XFER_COUNT		0x24
-
-/* DMA byte count status */
-#define TEGRA_GPCDMA_CHAN_DMA_BYTE_STATUS	0x28
-
 /* Error Status Register */
-#define TEGRA_GPCDMA_CHAN_ERR_STATUS		0x30
 #define TEGRA_GPCDMA_CHAN_ERR_TYPE_SHIFT	8
 #define TEGRA_GPCDMA_CHAN_ERR_TYPE_MASK	0xF
 #define TEGRA_GPCDMA_CHAN_ERR_TYPE(err)	(			\
@@ -143,14 +121,9 @@
 #define TEGRA_DMA_MC_SLAVE_ERR			0xB
 #define TEGRA_DMA_MMIO_SLAVE_ERR		0xA
 
-/* Fixed Pattern */
-#define TEGRA_GPCDMA_CHAN_FIXED_PATTERN		0x34
-
-#define TEGRA_GPCDMA_CHAN_TZ			0x38
 #define TEGRA_GPCDMA_CHAN_TZ_MMIO_PROT_1	BIT(0)
 #define TEGRA_GPCDMA_CHAN_TZ_MC_PROT_1		BIT(1)
 
-#define TEGRA_GPCDMA_CHAN_SPARE			0x3c
 #define TEGRA_GPCDMA_CHAN_SPARE_EN_LEGACY_FC	BIT(16)
 
 /*
@@ -181,19 +154,27 @@ struct tegra_dma_chip_data {
 	unsigned int nr_channels;
 	unsigned int channel_reg_size;
 	unsigned int max_dma_count;
+	const struct tegra_dma_channel_regs *channel_regs;
 	int (*terminate)(struct tegra_dma_channel *tdc);
 };
 
 /* DMA channel registers */
 struct tegra_dma_channel_regs {
 	u32 csr;
-	u32 src_ptr;
-	u32 dst_ptr;
-	u32 high_addr_ptr;
+	u32 status;
+	u32 csre;
+	u32 src;
+	u32 dst;
+	u32 high_addr;
 	u32 mc_seq;
 	u32 mmio_seq;
 	u32 wcount;
+	u32 wxfer;
+	u32 wstatus;
+	u32 err_status;
 	u32 fixed_pattern;
+	u32 tz;
+	u32 spare;
 };
 
 /*
@@ -205,7 +186,14 @@ struct tegra_dma_channel_regs {
  */
 struct tegra_dma_sg_req {
 	unsigned int len;
-	struct tegra_dma_channel_regs ch_regs;
+	u32 csr;
+	u32 src;
+	u32 dst;
+	u32 high_addr;
+	u32 mc_seq;
+	u32 mmio_seq;
+	u32 wcount;
+	u32 fixed_pattern;
 };
 
 /*
@@ -228,33 +216,34 @@ struct tegra_dma_desc {
  * tegra_dma_channel: Channel specific information
  */
 struct tegra_dma_channel {
-	bool config_init;
-	char name[30];
-	enum dma_transfer_direction sid_dir;
-	enum dma_status status;
 	int id;
 	int irq;
 	int slave_id;
+	bool config_init;
+	char name[30];
+	unsigned int stream_id;
+	unsigned long chan_base_offset;
 	struct tegra_dma *tdma;
 	struct virt_dma_chan vc;
 	struct tegra_dma_desc *dma_desc;
 	struct dma_slave_config dma_sconfig;
-	unsigned int stream_id;
-	unsigned long chan_base_offset;
+	const struct tegra_dma_channel_regs *regs;
+	enum dma_status status;
+	enum dma_transfer_direction sid_dir;
 };
 
 /*
  * tegra_dma: Tegra DMA specific information
  */
 struct tegra_dma {
-	const struct tegra_dma_chip_data *chip_data;
+	u32 chan_mask;
 	unsigned long sid_m2d_reserved;
 	unsigned long sid_d2m_reserved;
-	u32 chan_mask;
 	void __iomem *base_addr;
 	struct device *dev;
 	struct dma_device dma_dev;
 	struct reset_control *rst;
+	const struct tegra_dma_chip_data *chip_data;
 	struct tegra_dma_channel channels[];
 };
 
@@ -288,22 +277,25 @@ static void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)
 {
 	dev_dbg(tdc2dev(tdc), "DMA Channel %d name %s register dump:\n",
 		tdc->id, tdc->name);
-	dev_dbg(tdc2dev(tdc), "CSR %x STA %x CSRE %x SRC %x DST %x\n",
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_DST_PTR)
+	dev_dbg(tdc2dev(tdc), "CSR %x STA %x CSRE %x\n",
+		tdc_read(tdc, tdc->regs->csr),
+		tdc_read(tdc, tdc->regs->status),
+		tdc_read(tdc, tdc->regs->csre)
+	);
+	dev_dbg(tdc2dev(tdc), "SRC %x DST %x HI ADDR %x\n",
+		tdc_read(tdc, tdc->regs->src),
+		tdc_read(tdc, tdc->regs->high_addr),
+		tdc_read(tdc, tdc->regs->dst)
 	);
-	dev_dbg(tdc2dev(tdc), "MCSEQ %x IOSEQ %x WCNT %x XFER %x BSTA %x\n",
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_MMIOSEQ),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_WCOUNT),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_XFER_COUNT),
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_DMA_BYTE_STATUS)
+	dev_dbg(tdc2dev(tdc), "MCSEQ %x IOSEQ %x WCNT %x XFER %x WSTA %x\n",
+		tdc_read(tdc, tdc->regs->mc_seq),
+		tdc_read(tdc, tdc->regs->mmio_seq),
+		tdc_read(tdc, tdc->regs->wcount),
+		tdc_read(tdc, tdc->regs->wxfer),
+		tdc_read(tdc, tdc->regs->wstatus)
 	);
 	dev_dbg(tdc2dev(tdc), "DMA ERR_STA %x\n",
-		tdc_read(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS));
+		tdc_read(tdc, tdc->regs->err_status));
 }
 
 static int tegra_dma_sid_reserve(struct tegra_dma_channel *tdc,
@@ -377,13 +369,13 @@ static int tegra_dma_pause(struct tegra_dma_channel *tdc)
 	int ret;
 	u32 val;
 
-	val = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE);
+	val = tdc_read(tdc, tdc->regs->csre);
 	val |= TEGRA_GPCDMA_CHAN_CSRE_PAUSE;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSRE, val);
+	tdc_write(tdc, tdc->regs->csre, val);
 
 	/* Wait until busy bit is de-asserted */
 	ret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +
-			tdc->chan_base_offset + TEGRA_GPCDMA_CHAN_STATUS,
+			tdc->chan_base_offset + tdc->regs->status,
 			val,
 			!(val & TEGRA_GPCDMA_STATUS_BUSY),
 			TEGRA_GPCDMA_BURST_COMPLETE_TIME,
@@ -419,10 +411,10 @@ static void tegra_dma_resume(struct tegra_dma_channel *tdc)
 {
 	u32 val;
 
-	val = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSRE);
+	val = tdc_read(tdc, tdc->regs->csre);
 	val &= ~TEGRA_GPCDMA_CHAN_CSRE_PAUSE;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSRE, val);
 
+	tdc_write(tdc, tdc->regs->csre, val);
 	tdc->status = DMA_IN_PROGRESS;
 }
 
@@ -456,27 +448,27 @@ static void tegra_dma_disable(struct tegra_dma_channel *tdc)
 {
 	u32 csr, status;
 
-	csr = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR);
+	csr = tdc_read(tdc, tdc->regs->csr);
 
 	/* Disable interrupts */
 	csr &= ~TEGRA_GPCDMA_CSR_IE_EOC;
 
 	/* Disable DMA */
 	csr &= ~TEGRA_GPCDMA_CSR_ENB;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, csr);
+	tdc_write(tdc, tdc->regs->csr, csr);
 
 	/* Clear interrupt status if it is there */
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);
+	status = tdc_read(tdc, tdc->regs->status);
 	if (status & TEGRA_GPCDMA_STATUS_ISE_EOC) {
 		dev_dbg(tdc2dev(tdc), "%s():clearing interrupt\n", __func__);
-		tdc_write(tdc, TEGRA_GPCDMA_CHAN_STATUS, status);
+		tdc_write(tdc, tdc->regs->status, status);
 	}
 }
 
 static void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)
 {
 	struct tegra_dma_desc *dma_desc = tdc->dma_desc;
-	struct tegra_dma_channel_regs *ch_regs;
+	struct tegra_dma_sg_req *sg_req;
 	int ret;
 	u32 val;
 
@@ -488,29 +480,29 @@ static void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)
 
 	/* Configure next transfer immediately after DMA is busy */
 	ret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +
-			tdc->chan_base_offset + TEGRA_GPCDMA_CHAN_STATUS,
+			tdc->chan_base_offset + tdc->regs->status,
 			val,
 			(val & TEGRA_GPCDMA_STATUS_BUSY), 0,
 			TEGRA_GPCDMA_BURST_COMPLETION_TIMEOUT);
 	if (ret)
 		return;
 
-	ch_regs = &dma_desc->sg_req[dma_desc->sg_idx].ch_regs;
+	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_WCOUNT, ch_regs->wcount);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR, ch_regs->src_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_DST_PTR, ch_regs->dst_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR, ch_regs->high_addr_ptr);
+	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
+	tdc_write(tdc, tdc->regs->src, sg_req->src);
+	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
+	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
 
 	/* Start DMA */
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR,
-		  ch_regs->csr | TEGRA_GPCDMA_CSR_ENB);
+	tdc_write(tdc, tdc->regs->csr,
+		  sg_req->csr | TEGRA_GPCDMA_CSR_ENB);
 }
 
 static void tegra_dma_start(struct tegra_dma_channel *tdc)
 {
 	struct tegra_dma_desc *dma_desc = tdc->dma_desc;
-	struct tegra_dma_channel_regs *ch_regs;
+	struct tegra_dma_sg_req *sg_req;
 	struct virt_dma_desc *vdesc;
 
 	if (!dma_desc) {
@@ -526,21 +518,21 @@ static void tegra_dma_start(struct tegra_dma_channel *tdc)
 		tegra_dma_resume(tdc);
 	}
 
-	ch_regs = &dma_desc->sg_req[dma_desc->sg_idx].ch_regs;
+	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_WCOUNT, ch_regs->wcount);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, 0);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_SRC_PTR, ch_regs->src_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_DST_PTR, ch_regs->dst_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_HIGH_ADDR_PTR, ch_regs->high_addr_ptr);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_FIXED_PATTERN, ch_regs->fixed_pattern);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MMIOSEQ, ch_regs->mmio_seq);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, ch_regs->mc_seq);
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, ch_regs->csr);
+	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
+	tdc_write(tdc, tdc->regs->csr, 0);
+	tdc_write(tdc, tdc->regs->src, sg_req->src);
+	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
+	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
+	tdc_write(tdc, tdc->regs->fixed_pattern, sg_req->fixed_pattern);
+	tdc_write(tdc, tdc->regs->mmio_seq, sg_req->mmio_seq);
+	tdc_write(tdc, tdc->regs->mc_seq, sg_req->mc_seq);
+	tdc_write(tdc, tdc->regs->csr, sg_req->csr);
 
 	/* Start DMA */
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR,
-		  ch_regs->csr | TEGRA_GPCDMA_CSR_ENB);
+	tdc_write(tdc, tdc->regs->csr,
+		  sg_req->csr | TEGRA_GPCDMA_CSR_ENB);
 }
 
 static void tegra_dma_xfer_complete(struct tegra_dma_channel *tdc)
@@ -601,19 +593,19 @@ static irqreturn_t tegra_dma_isr(int irq, void *dev_id)
 	u32 status;
 
 	/* Check channel error status register */
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS);
+	status = tdc_read(tdc, tdc->regs->err_status);
 	if (status) {
 		tegra_dma_chan_decode_error(tdc, status);
 		tegra_dma_dump_chan_regs(tdc);
-		tdc_write(tdc, TEGRA_GPCDMA_CHAN_ERR_STATUS, 0xFFFFFFFF);
+		tdc_write(tdc, tdc->regs->err_status, 0xFFFFFFFF);
 	}
 
 	spin_lock(&tdc->vc.lock);
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);
+	status = tdc_read(tdc, tdc->regs->status);
 	if (!(status & TEGRA_GPCDMA_STATUS_ISE_EOC))
 		goto irq_done;
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_STATUS,
+	tdc_write(tdc, tdc->regs->status,
 		  TEGRA_GPCDMA_STATUS_ISE_EOC);
 
 	if (!dma_desc)
@@ -673,10 +665,10 @@ static int tegra_dma_stop_client(struct tegra_dma_channel *tdc)
 	 * to stop DMA engine from starting any more bursts for
 	 * the given client and wait for in flight bursts to complete
 	 */
-	csr = tdc_read(tdc, TEGRA_GPCDMA_CHAN_CSR);
+	csr = tdc_read(tdc, tdc->regs->csr);
 	csr &= ~(TEGRA_GPCDMA_CSR_REQ_SEL_MASK);
 	csr |= TEGRA_GPCDMA_CSR_REQ_SEL_UNUSED;
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_CSR, csr);
+	tdc_write(tdc, tdc->regs->csr, csr);
 
 	/* Wait for in flight data transfer to finish */
 	udelay(TEGRA_GPCDMA_BURST_COMPLETE_TIME);
@@ -687,7 +679,7 @@ static int tegra_dma_stop_client(struct tegra_dma_channel *tdc)
 
 	ret = readl_relaxed_poll_timeout_atomic(tdc->tdma->base_addr +
 				tdc->chan_base_offset +
-				TEGRA_GPCDMA_CHAN_STATUS,
+				tdc->regs->status,
 				status,
 				!(status & (TEGRA_GPCDMA_STATUS_CHANNEL_TX |
 				TEGRA_GPCDMA_STATUS_CHANNEL_RX)),
@@ -739,14 +731,14 @@ static int tegra_dma_get_residual(struct tegra_dma_channel *tdc)
 	unsigned int bytes_xfer, residual;
 	u32 wcount = 0, status;
 
-	wcount = tdc_read(tdc, TEGRA_GPCDMA_CHAN_XFER_COUNT);
+	wcount = tdc_read(tdc, tdc->regs->wxfer);
 
 	/*
 	 * Set wcount = 0 if EOC bit is set. The transfer would have
 	 * already completed and the CHAN_XFER_COUNT could have updated
 	 * for the next transfer, specifically in case of cyclic transfers.
 	 */
-	status = tdc_read(tdc, TEGRA_GPCDMA_CHAN_STATUS);
+	status = tdc_read(tdc, tdc->regs->status);
 	if (status & TEGRA_GPCDMA_STATUS_ISE_EOC)
 		wcount = 0;
 
@@ -893,7 +885,7 @@ tegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,
 	/* Configure default priority weight for the channel */
 	csr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;
 
@@ -916,16 +908,16 @@ tegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].ch_regs.src_ptr = 0;
-	sg_req[0].ch_regs.dst_ptr = dest;
-	sg_req[0].ch_regs.high_addr_ptr =
+	sg_req[0].src = 0;
+	sg_req[0].dst = dest;
+	sg_req[0].high_addr =
 			FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
-	sg_req[0].ch_regs.fixed_pattern = value;
+	sg_req[0].fixed_pattern = value;
 	/* Word count reg takes value as (N +1) words */
-	sg_req[0].ch_regs.wcount = ((len - 4) >> 2);
-	sg_req[0].ch_regs.csr = csr;
-	sg_req[0].ch_regs.mmio_seq = 0;
-	sg_req[0].ch_regs.mc_seq = mc_seq;
+	sg_req[0].wcount = ((len - 4) >> 2);
+	sg_req[0].csr = csr;
+	sg_req[0].mmio_seq = 0;
+	sg_req[0].mc_seq = mc_seq;
 	sg_req[0].len = len;
 
 	dma_desc->cyclic = false;
@@ -961,7 +953,7 @@ tegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,
 	/* Configure default priority weight for the channel */
 	csr |= FIELD_PREP(TEGRA_GPCDMA_CSR_WEIGHT, 1);
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= (TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK) |
 		  (TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
@@ -985,17 +977,17 @@ tegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].ch_regs.src_ptr = src;
-	sg_req[0].ch_regs.dst_ptr = dest;
-	sg_req[0].ch_regs.high_addr_ptr =
+	sg_req[0].src = src;
+	sg_req[0].dst = dest;
+	sg_req[0].high_addr =
 		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (src >> 32));
-	sg_req[0].ch_regs.high_addr_ptr |=
+	sg_req[0].high_addr |=
 		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
 	/* Word count reg takes value as (N +1) words */
-	sg_req[0].ch_regs.wcount = ((len - 4) >> 2);
-	sg_req[0].ch_regs.csr = csr;
-	sg_req[0].ch_regs.mmio_seq = 0;
-	sg_req[0].ch_regs.mc_seq = mc_seq;
+	sg_req[0].wcount = ((len - 4) >> 2);
+	sg_req[0].csr = csr;
+	sg_req[0].mmio_seq = 0;
+	sg_req[0].mc_seq = mc_seq;
 	sg_req[0].len = len;
 
 	dma_desc->cyclic = false;
@@ -1049,7 +1041,7 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 	if (flags & DMA_PREP_INTERRUPT)
 		csr |= TEGRA_GPCDMA_CSR_IE_EOC;
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;
 
@@ -1096,14 +1088,14 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 		dma_desc->bytes_req += len;
 
 		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].ch_regs.src_ptr = mem;
-			sg_req[i].ch_regs.dst_ptr = apb_ptr;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = mem;
+			sg_req[i].dst = apb_ptr;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
 		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].ch_regs.src_ptr = apb_ptr;
-			sg_req[i].ch_regs.dst_ptr = mem;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = apb_ptr;
+			sg_req[i].dst = mem;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
 		}
 
@@ -1111,10 +1103,10 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 		 * Word count register takes input in words. Writing a value
 		 * of N into word count register means a req of (N+1) words.
 		 */
-		sg_req[i].ch_regs.wcount = ((len - 4) >> 2);
-		sg_req[i].ch_regs.csr = csr;
-		sg_req[i].ch_regs.mmio_seq = mmio_seq;
-		sg_req[i].ch_regs.mc_seq = mc_seq;
+		sg_req[i].wcount = ((len - 4) >> 2);
+		sg_req[i].csr = csr;
+		sg_req[i].mmio_seq = mmio_seq;
+		sg_req[i].mc_seq = mc_seq;
 		sg_req[i].len = len;
 	}
 
@@ -1186,7 +1178,7 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 
 	mmio_seq |= FIELD_PREP(TEGRA_GPCDMA_MMIOSEQ_WRAP_WORD, 1);
 
-	mc_seq =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	mc_seq =  tdc_read(tdc, tdc->regs->mc_seq);
 	/* retain stream-id and clean rest */
 	mc_seq &= TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK;
 
@@ -1218,24 +1210,24 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 	for (i = 0; i < period_count; i++) {
 		mmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);
 		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].ch_regs.src_ptr = mem;
-			sg_req[i].ch_regs.dst_ptr = apb_ptr;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = mem;
+			sg_req[i].dst = apb_ptr;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
 		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].ch_regs.src_ptr = apb_ptr;
-			sg_req[i].ch_regs.dst_ptr = mem;
-			sg_req[i].ch_regs.high_addr_ptr =
+			sg_req[i].src = apb_ptr;
+			sg_req[i].dst = mem;
+			sg_req[i].high_addr =
 				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
 		}
 		/*
 		 * Word count register takes input in words. Writing a value
 		 * of N into word count register means a req of (N+1) words.
 		 */
-		sg_req[i].ch_regs.wcount = ((len - 4) >> 2);
-		sg_req[i].ch_regs.csr = csr;
-		sg_req[i].ch_regs.mmio_seq = mmio_seq;
-		sg_req[i].ch_regs.mc_seq = mc_seq;
+		sg_req[i].wcount = ((len - 4) >> 2);
+		sg_req[i].csr = csr;
+		sg_req[i].mmio_seq = mmio_seq;
+		sg_req[i].mc_seq = mc_seq;
 		sg_req[i].len = len;
 
 		mem += len;
@@ -1290,7 +1282,7 @@ static void tegra_dma_free_chan_resources(struct dma_chan *dc)
 
 static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
 {
-	unsigned int reg_val =  tdc_read(tdc, TEGRA_GPCDMA_CHAN_MCSEQ);
+	unsigned int reg_val =  tdc_read(tdc, tdc->regs->mc_seq);
 
 	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK);
 	reg_val &= ~(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK);
@@ -1298,7 +1290,7 @@ static int tegra_dma_program_sid(struct tegra_dma_channel *tdc, int stream_id)
 	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID0_MASK, stream_id);
 	reg_val |= FIELD_PREP(TEGRA_GPCDMA_MCSEQ_STREAM_ID1_MASK, stream_id);
 
-	tdc_write(tdc, TEGRA_GPCDMA_CHAN_MCSEQ, reg_val);
+	tdc_write(tdc, tdc->regs->mc_seq, reg_val);
 	return 0;
 }
 
@@ -1359,11 +1351,30 @@ static struct dma_chan *tegra_dma_of_xlate(struct of_phandle_args *dma_spec,
 	return tegra_dma_get_any_slave_channel(tdma, dma_spec);
 }
 
+static const struct tegra_dma_channel_regs tegra186_reg_offsets = {
+	.csr = 0x0,
+	.status = 0x4,
+	.csre = 0x8,
+	.src = 0xc,
+	.dst = 0x10,
+	.high_addr = 0x14,
+	.mc_seq = 0x18,
+	.mmio_seq = 0x1c,
+	.wcount = 0x20,
+	.wxfer = 0x24,
+	.wstatus = 0x28,
+	.err_status = 0x30,
+	.fixed_pattern = 0x34,
+	.tz = 0x38,
+	.spare = 0x40,
+};
+
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = false,
+	.channel_regs = &tegra186_reg_offsets,
 	.terminate = tegra_dma_stop_client,
 };
 
@@ -1372,6 +1383,7 @@ static const struct tegra_dma_chip_data tegra194_dma_chip_data = {
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
+	.channel_regs = &tegra186_reg_offsets,
 	.terminate = tegra_dma_pause,
 };
 
@@ -1380,6 +1392,7 @@ static const struct tegra_dma_chip_data tegra234_dma_chip_data = {
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
+	.channel_regs = &tegra186_reg_offsets,
 	.terminate = tegra_dma_pause_noerr,
 };
 
@@ -1459,6 +1472,7 @@ static int tegra_dma_probe(struct platform_device *pdev)
 
 		tdc->chan_base_offset = TEGRA_GPCDMA_CHANNEL_BASE_ADDR_OFFSET +
 					i * cdata->channel_reg_size;
+		tdc->regs = cdata->channel_regs;
 		snprintf(tdc->name, sizeof(tdc->name), "gpcdma.%d", i);
 		tdc->tdma = tdma;
 		tdc->id = i;
-- 
2.51.0


From 7e7910a2f6a0547e689b7a90d56ba94163ef11ed Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 28 Jul 2023 21:59:37 +0530
Subject: [PATCH 14/21] NVIDIA: SAUCE: dmaengine: tegra: Support more than 40
 bits address width

Add support for address width of more than 40 bits. Till Tegra234 in
addition to 32 bit source/destination, only 8 bits each were supported.
In Tegra264, there is a separate register for high source and high
destination addresses. It can now support 48 bits addresses as well.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 107 +++++++++++++++++++--------------
 1 file changed, 63 insertions(+), 44 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index 9b5bca55b9dc..e4634966a633 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -151,6 +151,7 @@ struct tegra_dma_channel;
  */
 struct tegra_dma_chip_data {
 	bool hw_support_pause;
+	unsigned int addr_bits;
 	unsigned int nr_channels;
 	unsigned int channel_reg_size;
 	unsigned int max_dma_count;
@@ -166,6 +167,8 @@ struct tegra_dma_channel_regs {
 	u32 src;
 	u32 dst;
 	u32 high_addr;
+	u32 src_high;
+	u32 dst_high;
 	u32 mc_seq;
 	u32 mmio_seq;
 	u32 wcount;
@@ -190,6 +193,8 @@ struct tegra_dma_sg_req {
 	u32 src;
 	u32 dst;
 	u32 high_addr;
+	u32 src_high;
+	u32 dst_high;
 	u32 mc_seq;
 	u32 mmio_seq;
 	u32 wcount;
@@ -273,6 +278,40 @@ static inline struct device *tdc2dev(struct tegra_dma_channel *tdc)
 	return tdc->vc.chan.device->dev;
 }
 
+static inline void tegra_dma_program_addr(struct tegra_dma_channel *tdc,
+					struct tegra_dma_sg_req *sg_req)
+{
+	tdc_write(tdc, tdc->regs->src, sg_req->src);
+	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
+	if (tdc->tdma->chip_data->addr_bits > 40) {
+		tdc_write(tdc, tdc->regs->src_high,
+						sg_req->src_high);
+		tdc_write(tdc, tdc->regs->dst_high,
+						sg_req->dst_high);
+	} else {
+		tdc_write(tdc, tdc->regs->high_addr,
+				sg_req->src_high | sg_req->dst_high);
+	}
+}
+
+static inline void tegra_dma_configure_addr(struct tegra_dma_channel *tdc,
+				struct tegra_dma_sg_req *sg_req,
+				phys_addr_t src, phys_addr_t dst)
+{
+	sg_req->src = lower_32_bits(src);
+	sg_req->dst = lower_32_bits(dst);
+
+	if (tdc->tdma->chip_data->addr_bits > 40) {
+		sg_req->src_high = upper_32_bits(src);
+		sg_req->dst_high = upper_32_bits(dst);
+	} else {
+		sg_req->src_high = FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR,
+					upper_32_bits(src));
+		sg_req->dst_high = FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR,
+					upper_32_bits(dst));
+	}
+}
+
 static void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)
 {
 	dev_dbg(tdc2dev(tdc), "DMA Channel %d name %s register dump:\n",
@@ -282,10 +321,11 @@ static void tegra_dma_dump_chan_regs(struct tegra_dma_channel *tdc)
 		tdc_read(tdc, tdc->regs->status),
 		tdc_read(tdc, tdc->regs->csre)
 	);
-	dev_dbg(tdc2dev(tdc), "SRC %x DST %x HI ADDR %x\n",
+	dev_dbg(tdc2dev(tdc), "SRC %x SRC HI %x DST %x DST HI %x\n",
 		tdc_read(tdc, tdc->regs->src),
-		tdc_read(tdc, tdc->regs->high_addr),
-		tdc_read(tdc, tdc->regs->dst)
+		tdc_read(tdc, tdc->regs->src_high),
+		tdc_read(tdc, tdc->regs->dst),
+		tdc_read(tdc, tdc->regs->dst_high)
 	);
 	dev_dbg(tdc2dev(tdc), "MCSEQ %x IOSEQ %x WCNT %x XFER %x WSTA %x\n",
 		tdc_read(tdc, tdc->regs->mc_seq),
@@ -490,9 +530,7 @@ static void tegra_dma_configure_next_sg(struct tegra_dma_channel *tdc)
 	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
 	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
-	tdc_write(tdc, tdc->regs->src, sg_req->src);
-	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
-	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
+	tegra_dma_program_addr(tdc, sg_req);
 
 	/* Start DMA */
 	tdc_write(tdc, tdc->regs->csr,
@@ -520,11 +558,9 @@ static void tegra_dma_start(struct tegra_dma_channel *tdc)
 
 	sg_req = &dma_desc->sg_req[dma_desc->sg_idx];
 
+	tegra_dma_program_addr(tdc, sg_req);
 	tdc_write(tdc, tdc->regs->wcount, sg_req->wcount);
 	tdc_write(tdc, tdc->regs->csr, 0);
-	tdc_write(tdc, tdc->regs->src, sg_req->src);
-	tdc_write(tdc, tdc->regs->dst, sg_req->dst);
-	tdc_write(tdc, tdc->regs->high_addr, sg_req->high_addr);
 	tdc_write(tdc, tdc->regs->fixed_pattern, sg_req->fixed_pattern);
 	tdc_write(tdc, tdc->regs->mmio_seq, sg_req->mmio_seq);
 	tdc_write(tdc, tdc->regs->mc_seq, sg_req->mc_seq);
@@ -829,7 +865,7 @@ static unsigned int get_burst_size(struct tegra_dma_channel *tdc,
 
 static int get_transfer_param(struct tegra_dma_channel *tdc,
 			      enum dma_transfer_direction direction,
-			      u32 *apb_addr,
+			      dma_addr_t *apb_addr,
 			      u32 *mmio_seq,
 			      u32 *csr,
 			      unsigned int *burst_size,
@@ -908,10 +944,7 @@ tegra_dma_prep_dma_memset(struct dma_chan *dc, dma_addr_t dest, int value,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].src = 0;
-	sg_req[0].dst = dest;
-	sg_req[0].high_addr =
-			FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
+	tegra_dma_configure_addr(tdc, &sg_req[0], 0, dest);
 	sg_req[0].fixed_pattern = value;
 	/* Word count reg takes value as (N +1) words */
 	sg_req[0].wcount = ((len - 4) >> 2);
@@ -977,12 +1010,7 @@ tegra_dma_prep_dma_memcpy(struct dma_chan *dc, dma_addr_t dest,
 	dma_desc->sg_count = 1;
 	sg_req = dma_desc->sg_req;
 
-	sg_req[0].src = src;
-	sg_req[0].dst = dest;
-	sg_req[0].high_addr =
-		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (src >> 32));
-	sg_req[0].high_addr |=
-		FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (dest >> 32));
+	tegra_dma_configure_addr(tdc, &sg_req[0], src, dest);
 	/* Word count reg takes value as (N +1) words */
 	sg_req[0].wcount = ((len - 4) >> 2);
 	sg_req[0].csr = csr;
@@ -1002,7 +1030,8 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 	struct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);
 	unsigned int max_dma_count = tdc->tdma->chip_data->max_dma_count;
 	enum dma_slave_buswidth slave_bw = DMA_SLAVE_BUSWIDTH_UNDEFINED;
-	u32 csr, mc_seq, apb_ptr = 0, mmio_seq = 0;
+	u32 csr, mc_seq, mmio_seq = 0;
+	dma_addr_t apb_ptr = 0;
 	struct tegra_dma_sg_req *sg_req;
 	struct tegra_dma_desc *dma_desc;
 	struct scatterlist *sg;
@@ -1087,17 +1116,10 @@ tegra_dma_prep_slave_sg(struct dma_chan *dc, struct scatterlist *sgl,
 		mmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);
 		dma_desc->bytes_req += len;
 
-		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].src = mem;
-			sg_req[i].dst = apb_ptr;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
-		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].src = apb_ptr;
-			sg_req[i].dst = mem;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
-		}
+		if (direction == DMA_MEM_TO_DEV)
+			tegra_dma_configure_addr(tdc, &sg_req[i], mem, apb_ptr);
+		 else if (direction == DMA_DEV_TO_MEM)
+			tegra_dma_configure_addr(tdc, &sg_req[i], apb_ptr, mem);
 
 		/*
 		 * Word count register takes input in words. Writing a value
@@ -1120,7 +1142,8 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 			  unsigned long flags)
 {
 	enum dma_slave_buswidth slave_bw = DMA_SLAVE_BUSWIDTH_UNDEFINED;
-	u32 csr, mc_seq, apb_ptr = 0, mmio_seq = 0, burst_size;
+	u32 csr, mc_seq, mmio_seq = 0, burst_size;
+	dma_addr_t apb_ptr = 0;
 	unsigned int max_dma_count, len, period_count, i;
 	struct tegra_dma_channel *tdc = to_tegra_dma_chan(dc);
 	struct tegra_dma_desc *dma_desc;
@@ -1209,17 +1232,10 @@ tegra_dma_prep_dma_cyclic(struct dma_chan *dc, dma_addr_t buf_addr, size_t buf_l
 	/* Split transfer equal to period size */
 	for (i = 0; i < period_count; i++) {
 		mmio_seq |= get_burst_size(tdc, burst_size, slave_bw, len);
-		if (direction == DMA_MEM_TO_DEV) {
-			sg_req[i].src = mem;
-			sg_req[i].dst = apb_ptr;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_SRC_PTR, (mem >> 32));
-		} else if (direction == DMA_DEV_TO_MEM) {
-			sg_req[i].src = apb_ptr;
-			sg_req[i].dst = mem;
-			sg_req[i].high_addr =
-				FIELD_PREP(TEGRA_GPCDMA_HIGH_ADDR_DST_PTR, (mem >> 32));
-		}
+		if (direction == DMA_MEM_TO_DEV)
+			tegra_dma_configure_addr(tdc, &sg_req[i], mem, apb_ptr);
+		else if (direction == DMA_DEV_TO_MEM)
+			tegra_dma_configure_addr(tdc, &sg_req[i], apb_ptr, mem);
 		/*
 		 * Word count register takes input in words. Writing a value
 		 * of N into word count register means a req of (N+1) words.
@@ -1371,6 +1387,7 @@ static const struct tegra_dma_channel_regs tegra186_reg_offsets = {
 
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
+	.addr_bits = 40,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = false,
@@ -1380,6 +1397,7 @@ static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 
 static const struct tegra_dma_chip_data tegra194_dma_chip_data = {
 	.nr_channels = 32,
+	.addr_bits = 40,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
@@ -1389,6 +1407,7 @@ static const struct tegra_dma_chip_data tegra194_dma_chip_data = {
 
 static const struct tegra_dma_chip_data tegra234_dma_chip_data = {
 	.nr_channels = 32,
+	.addr_bits = 40,
 	.channel_reg_size = SZ_64K,
 	.max_dma_count = SZ_1G,
 	.hw_support_pause = true,
-- 
2.51.0


From 3f98f63ace5e87bcca63d3772234693b8f40ea6f Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Fri, 28 Jul 2023 22:18:39 +0530
Subject: [PATCH 15/21] NVIDIA: SAUCE: dmaengine: tegra: Add Tegra264 support

Update compatible and chip data to support GPCDMA in Tegra264.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index e4634966a633..2edce19f8e59 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -1385,6 +1385,25 @@ static const struct tegra_dma_channel_regs tegra186_reg_offsets = {
 	.spare = 0x40,
 };
 
+static const struct tegra_dma_channel_regs tegra264_reg_offsets = {
+	.csr = 0x0,
+	.status = 0x4,
+	.csre = 0x8,
+	.src = 0xc,
+	.dst = 0x10,
+	.src_high = 0x14,
+	.dst_high = 0x18,
+	.mc_seq = 0x1c,
+	.mmio_seq = 0x20,
+	.wcount = 0x24,
+	.wxfer = 0x28,
+	.wstatus = 0x2c,
+	.err_status = 0x34,
+	.fixed_pattern = 0x38,
+	.tz = 0x3c,
+	.spare = 0x44,
+};
+
 static const struct tegra_dma_chip_data tegra186_dma_chip_data = {
 	.nr_channels = 32,
 	.addr_bits = 40,
@@ -1415,6 +1434,17 @@ static const struct tegra_dma_chip_data tegra234_dma_chip_data = {
 	.terminate = tegra_dma_pause_noerr,
 };
 
+
+static const struct tegra_dma_chip_data tegra264_dma_chip_data = {
+	.nr_channels = 32,
+	.addr_bits = 48,
+	.channel_reg_size = SZ_64K,
+	.max_dma_count = SZ_1G,
+	.hw_support_pause = true,
+	.channel_regs = &tegra264_reg_offsets,
+	.terminate = tegra_dma_pause_noerr,
+};
+
 static const struct of_device_id tegra_dma_of_match[] = {
 	{
 		.compatible = "nvidia,tegra186-gpcdma",
@@ -1425,6 +1455,9 @@ static const struct of_device_id tegra_dma_of_match[] = {
 	}, {
 		.compatible = "nvidia,tegra234-gpcdma",
 		.data = &tegra234_dma_chip_data,
+	}, {
+		.compatible = "nvidia,tegra264-gpcdma",
+		.data = &tegra264_dma_chip_data,
 	}, {
 	},
 };
-- 
2.51.0


From 9e142590506b998fee3ede8d280700a96c355e82 Mon Sep 17 00:00:00 2001
From: Akhil R <akhilrajeev@nvidia.com>
Date: Wed, 16 Aug 2023 09:44:52 +0530
Subject: [PATCH 16/21] NVIDIA: SAUCE: dmaengine: tegra: Remove reset control

The reset is expected to be controlled from the bootloader and should
be done by the time it reaches kernel. Therefore a reset in the
driver is redundant.

Also, Linux does not have access to this reset in the upcoming chips.
To keep the drive agnostic, removing all the reset functionality from
the driver.

Signed-off-by: Akhil R <akhilrajeev@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/dma/tegra186-gpc-dma.c | 13 +------------
 1 file changed, 1 insertion(+), 12 deletions(-)

diff --git a/drivers/dma/tegra186-gpc-dma.c b/drivers/dma/tegra186-gpc-dma.c
index 2edce19f8e59..f98e19b3fe36 100644
--- a/drivers/dma/tegra186-gpc-dma.c
+++ b/drivers/dma/tegra186-gpc-dma.c
@@ -2,7 +2,7 @@
 /*
  * DMA driver for NVIDIA Tegra GPC DMA controller.
  *
- * Copyright (c) 2014-2022, NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2014-2023, NVIDIA CORPORATION.  All rights reserved.
  */
 
 #include <linux/bitfield.h>
@@ -16,7 +16,6 @@
 #include <linux/of.h>
 #include <linux/of_dma.h>
 #include <linux/platform_device.h>
-#include <linux/reset.h>
 #include <linux/slab.h>
 #include <dt-bindings/memory/tegra186-mc.h>
 #include "virt-dma.h"
@@ -247,7 +246,6 @@ struct tegra_dma {
 	void __iomem *base_addr;
 	struct device *dev;
 	struct dma_device dma_dev;
-	struct reset_control *rst;
 	const struct tegra_dma_chip_data *chip_data;
 	struct tegra_dma_channel channels[];
 };
@@ -1487,13 +1485,6 @@ static int tegra_dma_probe(struct platform_device *pdev)
 	if (IS_ERR(tdma->base_addr))
 		return PTR_ERR(tdma->base_addr);
 
-	tdma->rst = devm_reset_control_get_exclusive(&pdev->dev, "gpcdma");
-	if (IS_ERR(tdma->rst)) {
-		return dev_err_probe(&pdev->dev, PTR_ERR(tdma->rst),
-			      "Missing controller reset\n");
-	}
-	reset_control_reset(tdma->rst);
-
 	tdma->dma_dev.dev = &pdev->dev;
 
 	if (!tegra_dev_iommu_get_stream_id(&pdev->dev, &stream_id)) {
@@ -1623,8 +1614,6 @@ static int __maybe_unused tegra_dma_pm_resume(struct device *dev)
 	struct tegra_dma *tdma = dev_get_drvdata(dev);
 	unsigned int i;
 
-	reset_control_reset(tdma->rst);
-
 	for (i = 0; i < tdma->chip_data->nr_channels; i++) {
 		struct tegra_dma_channel *tdc = &tdma->channels[i];
 
-- 
2.51.0


From 7a7f62d17279fdb71354885394f67758df1447ee Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Tue, 4 Apr 2023 12:04:31 +0000
Subject: [PATCH 17/21] NVIDIA: SAUCE: spi: add "tegra-spidev" compatible
 string.

BugLink: https://bugs.launchpad.net/bugs/2072591

Add "tegra-spidev" compatible string.

http://nvbugs/3754288

Signed-off-by: Vishwaroop A <va@nvidia.com>
Reviewed-by: Laxman Dewangan <ldewangan@nvidia.com>
Tested-by: Abhilash G <abhilashg@nvidia.com>
Reviewed-by: Abhilash G <abhilashg@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spidev.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 5300c942a2a4..8fef8c6ffeff 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -751,6 +751,8 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "semtech,sx1301", .data = &spidev_of_check },
 	{ .compatible = "silabs,em3581", .data = &spidev_of_check },
 	{ .compatible = "silabs,si3210", .data = &spidev_of_check },
+	{ .compatible = "nvidia,tegra-spidev", .data = &spidev_of_check },
+	{ .compatible = "tegra-spidev", .data = &spidev_of_check },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
-- 
2.51.0


From 43442392ea94d3c97001c010b0005aa17dc6c590 Mon Sep 17 00:00:00 2001
From: Gautham Srinivasan <gauthams@nvidia.com>
Date: Wed, 24 May 2023 17:22:20 +0000
Subject: [PATCH 18/21] NVIDIA: SAUCE: spi: add "tegra-spidev" name string.

BugLink: https://bugs.launchpad.net/bugs/2072591

Add "tegra-spidev" name string to load spidev.ko driver
which allows user-space programs to access and communicate
with SPI devices connected to the system.

http://nvbugs/4130525

Signed-off-by: Gautham Srinivasan <gauthams@nvidia.com>
Reviewed-by: Prathamesh Shete <pshete@nvidia.com>
Tested-by: Prathamesh Shete <pshete@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spidev.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 8fef8c6ffeff..fe5033c24a68 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -718,6 +718,7 @@ static const struct spi_device_id spidev_spi_ids[] = {
 	{ .name = /* semtech */ "sx1301" },
 	{ .name = /* silabs */ "em3581" },
 	{ .name = /* silabs */ "si3210" },
+	{ .name = "tegra-spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
-- 
2.51.0


From d82fcfcb1011169eb4702649d3b3ed4938f935c0 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Tue, 12 Dec 2023 11:00:52 +0000
Subject: [PATCH 19/21] NVIDIA: SAUCE: drivers: spi: fix warnings in spi
 controller.

BugLink: https://bugs.launchpad.net/bugs/2072591

Fix the below listed warnings in SPI
controller driver.

>> spi spi0.0: Invalid delay unit 2, should be
SPI_DELAY_UNIT_SCK.

http://nvbugs/4346767

Signed-off-by: Vishwaroop A <va@nvidia.com>
Tested-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spi-tegra114.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/drivers/spi/spi-tegra114.c b/drivers/spi/spi-tegra114.c
index 795a8482c2c7..3ac19d4bb216 100644
--- a/drivers/spi/spi-tegra114.c
+++ b/drivers/spi/spi-tegra114.c
@@ -728,6 +728,10 @@ static int tegra_spi_set_hw_cs_timing(struct spi_device *spi)
 	u32 inactive_cycles;
 	u8 cs_state;
 
+	setup->unit = SPI_DELAY_UNIT_SCK;
+	hold->unit = SPI_DELAY_UNIT_SCK;
+	inactive->unit = SPI_DELAY_UNIT_SCK;
+
 	if ((setup->value && setup->unit != SPI_DELAY_UNIT_SCK) ||
 	    (hold->value && hold->unit != SPI_DELAY_UNIT_SCK) ||
 	    (inactive->value && inactive->unit != SPI_DELAY_UNIT_SCK)) {
-- 
2.51.0


From 75c9917855d8817e83e64ff5e30fd4fbf9b2c3f1 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Wed, 13 Dec 2023 09:13:37 +0000
Subject: [PATCH 20/21] NVIDIA: SAUCE: drivers: spi: fix warnings in spi core.

BugLink: https://bugs.launchpad.net/bugs/2072591

Fix the below listed warnings in SPI core framework
by adding check for prod.

>>spi_master spi0: cannot find modalias for
/bus@0/spi@3210000/prod-settings

http://nvbugs/4346767

Signed-off-by: Vishwaroop A <va@nvidia.com>
Tested-by: Laxman Dewangan <ldewangan@nvidia.com>
Reviewed-by: Laxman Dewangan <ldewangan@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spi.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 63681d837e6c..406197fb8bf0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2531,6 +2531,8 @@ static void of_register_spi_devices(struct spi_controller *ctlr)
 	for_each_available_child_of_node(ctlr->dev.of_node, nc) {
 		if (of_node_test_and_set_flag(nc, OF_POPULATED))
 			continue;
+		if (!strcmp(nc->name, "prod-settings"))
+			continue;
 		spi = of_register_spi_device(ctlr, nc);
 		if (IS_ERR(spi)) {
 			dev_warn(&ctlr->dev,
-- 
2.51.0


From 06938792afe28a3eb6c387b33053d9d5032874f5 Mon Sep 17 00:00:00 2001
From: Vishwaroop A <va@nvidia.com>
Date: Mon, 14 Aug 2023 20:33:31 +0000
Subject: [PATCH 21/21] NVIDIA: SAUCE: spi: spi-tegra114: retain the spi mode

BugLink: https://bugs.launchpad.net/bugs/2080908

Retain the spi mode in def_command1 register
after transfer completion.

http://nvbugs/4204673

Signed-off-by: Vishwaroop A <va@nvidia.com>
Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
Acked-by: Noah Wager <noah.wager@canonical.com>
Acked-by: Jacob Martin <jacob.martin@canonical.com>
Signed-off-by: Noah Wager <noah.wager@canonical.com>
---
 drivers/spi/spi-tegra114.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/drivers/spi/spi-tegra114.c b/drivers/spi/spi-tegra114.c
index 3ac19d4bb216..5c4f2e832023 100644
--- a/drivers/spi/spi-tegra114.c
+++ b/drivers/spi/spi-tegra114.c
@@ -57,6 +57,7 @@
 #define SPI_CONTROL_MODE_3			(3 << 28)
 #define SPI_CONTROL_MODE_MASK			(3 << 28)
 #define SPI_MODE_SEL(x)				(((x) & 0x3) << 28)
+#define SPI_MODE_VAL(x)				(((x) >> 28) & 0x3)
 #define SPI_M_S					(1 << 30)
 #define SPI_PIO					(1 << 31)
 
@@ -205,6 +206,7 @@ struct tegra_spi_data {
 	u32					spi_cs_timing1;
 	u32					spi_cs_timing2;
 	u8					last_used_cs;
+	u8					def_chip_select;
 
 	struct completion			xfer_completion;
 	struct spi_transfer			*curr_xfer;
@@ -827,7 +829,9 @@ static u32 tegra_spi_setup_transfer_one(struct spi_device *spi,
 				tegra_spi_writel(tspi, command1, SPI_COMMAND1);
 			tspi->cs_control = NULL;
 		} else
-			tegra_spi_writel(tspi, command1, SPI_COMMAND1);
+			if (SPI_MODE_VAL(command1) !=
+				SPI_MODE_VAL(tspi->def_command1_reg))
+				tegra_spi_writel(tspi, command1, SPI_COMMAND1);
 
 		/* GPIO based chip select control */
 		if (spi_get_csgpiod(spi, 0))
@@ -987,6 +991,8 @@ static int tegra_spi_setup(struct spi_device *spi)
 		val &= ~SPI_CS_POL_INACTIVE(spi_get_chipselect(spi, 0));
 	else
 		val |= SPI_CS_POL_INACTIVE(spi_get_chipselect(spi, 0));
+	if (tspi->def_chip_select == spi_get_chipselect(spi, 0))
+		val |= SPI_MODE_SEL(spi->mode & 0x3);
 	tspi->def_command1_reg = val;
 	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
 	spin_unlock_irqrestore(&tspi->lock, flags);
@@ -1341,6 +1347,8 @@ static int tegra_spi_probe(struct platform_device *pdev)
 		goto exit_free_host;
 	}
 
+	tspi->def_chip_select = 0;
+
 	tspi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);
 	if (IS_ERR(tspi->base)) {
 		ret = PTR_ERR(tspi->base);
@@ -1400,6 +1408,8 @@ static int tegra_spi_probe(struct platform_device *pdev)
 	reset_control_assert(tspi->rst);
 	udelay(2);
 	reset_control_deassert(tspi->rst);
+	tspi->def_command1_reg  = tegra_spi_readl(tspi, SPI_COMMAND1);
+	tspi->def_command1_reg |= SPI_CS_SEL(tspi->def_chip_select);
 	tspi->def_command1_reg  = SPI_M_S;
 	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
 	tspi->spi_cs_timing1 = tegra_spi_readl(tspi, SPI_CS_TIMING1);
-- 
2.51.0

